{"ast":null,"code":"import _classCallCheck from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _regeneratorRuntime from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator/index.js\";\nimport { __awaiter } from \"tslib\";\nimport { connect, ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { Volume } from \"../component/channel/Volume\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { assert } from \"../core/util/Debug\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { isDefined, isNumber } from \"../core/util/TypeCheck\";\n/**\n * UserMedia uses MediaDevices.getUserMedia to open up and external microphone or audio input.\n * Check [MediaDevices API Support](https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia)\n * to see which browsers are supported. Access to an external input\n * is limited to secure (HTTPS) connections.\n * @example\n * const meter = new Tone.Meter();\n * const mic = new Tone.UserMedia().connect(meter);\n * mic.open().then(() => {\n * \t// promise resolves when input is available\n * \tconsole.log(\"mic open\");\n * \t// print the incoming mic levels in decibels\n * \tsetInterval(() => console.log(meter.getValue()), 100);\n * }).catch(e => {\n * \t// promise is rejected when the user doesn't have or allow mic access\n * \tconsole.log(\"mic not open\");\n * });\n * @category Source\n */\n\nexport var UserMedia = /*#__PURE__*/function (_ToneAudioNode) {\n  _inherits(UserMedia, _ToneAudioNode);\n\n  var _super = _createSuper(UserMedia);\n\n  function UserMedia() {\n    var _this;\n\n    _classCallCheck(this, UserMedia);\n\n    _this = _super.call(this, optionsFromArguments(UserMedia.getDefaults(), arguments, [\"volume\"]));\n    _this.name = \"UserMedia\";\n    var options = optionsFromArguments(UserMedia.getDefaults(), arguments, [\"volume\"]);\n    _this._volume = _this.output = new Volume({\n      context: _this.context,\n      volume: options.volume\n    });\n    _this.volume = _this._volume.volume;\n    readOnly(_assertThisInitialized(_this), \"volume\");\n    _this.mute = options.mute;\n    return _this;\n  }\n\n  _createClass(UserMedia, [{\n    key: \"open\",\n    value:\n    /**\n     * Open the media stream. If a string is passed in, it is assumed\n     * to be the label or id of the stream, if a number is passed in,\n     * it is the input number of the stream.\n     * @param  labelOrId The label or id of the audio input media device.\n     *                   With no argument, the default stream is opened.\n     * @return The promise is resolved when the stream is open.\n     */\n    function open(labelOrId) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var devices, constraints, stream, mediaStreamNode;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                assert(UserMedia.supported, \"UserMedia is not supported\"); // close the previous stream\n\n                if (this.state === \"started\") {\n                  this.close();\n                }\n\n                _context.next = 4;\n                return UserMedia.enumerateDevices();\n\n              case 4:\n                devices = _context.sent;\n\n                if (isNumber(labelOrId)) {\n                  this._device = devices[labelOrId];\n                } else {\n                  this._device = devices.find(function (device) {\n                    return device.label === labelOrId || device.deviceId === labelOrId;\n                  }); // didn't find a matching device\n\n                  if (!this._device && devices.length > 0) {\n                    this._device = devices[0];\n                  }\n\n                  assert(isDefined(this._device), \"No matching device \".concat(labelOrId));\n                } // do getUserMedia\n\n\n                constraints = {\n                  audio: {\n                    echoCancellation: false,\n                    sampleRate: this.context.sampleRate,\n                    noiseSuppression: false,\n                    mozNoiseSuppression: false\n                  }\n                };\n\n                if (this._device) {\n                  // @ts-ignore\n                  constraints.audio.deviceId = this._device.deviceId;\n                }\n\n                _context.next = 10;\n                return navigator.mediaDevices.getUserMedia(constraints);\n\n              case 10:\n                stream = _context.sent;\n\n                // start a new source only if the previous one is closed\n                if (!this._stream) {\n                  this._stream = stream; // Wrap a MediaStreamSourceNode around the live input stream.\n\n                  mediaStreamNode = this.context.createMediaStreamSource(stream); // Connect the MediaStreamSourceNode to a gate gain node\n\n                  connect(mediaStreamNode, this.output);\n                  this._mediaStream = mediaStreamNode;\n                }\n\n                return _context.abrupt(\"return\", this);\n\n              case 13:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n    /**\n     * Close the media stream\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      if (this._stream && this._mediaStream) {\n        this._stream.getAudioTracks().forEach(function (track) {\n          track.stop();\n        });\n\n        this._stream = undefined; // remove the old media stream\n\n        this._mediaStream.disconnect();\n\n        this._mediaStream = undefined;\n      }\n\n      this._device = undefined;\n      return this;\n    }\n    /**\n     * Returns a promise which resolves with the list of audio input devices available.\n     * @return The promise that is resolved with the devices\n     * @example\n     * Tone.UserMedia.enumerateDevices().then((devices) => {\n     * \t// print the device labels\n     * \tconsole.log(devices.map(device => device.label));\n     * });\n     */\n\n  }, {\n    key: \"state\",\n    get:\n    /**\n     * Returns the playback state of the source, \"started\" when the microphone is open\n     * and \"stopped\" when the mic is closed.\n     */\n    function get() {\n      return this._stream && this._stream.active ? \"started\" : \"stopped\";\n    }\n    /**\n     * Returns an identifier for the represented device that is\n     * persisted across sessions. It is un-guessable by other applications and\n     * unique to the origin of the calling application. It is reset when the\n     * user clears cookies (for Private Browsing, a different identifier is\n     * used that is not persisted across sessions). Returns undefined when the\n     * device is not open.\n     */\n\n  }, {\n    key: \"deviceId\",\n    get: function get() {\n      if (this._device) {\n        return this._device.deviceId;\n      } else {\n        return undefined;\n      }\n    }\n    /**\n     * Returns a group identifier. Two devices have the\n     * same group identifier if they belong to the same physical device.\n     * Returns null  when the device is not open.\n     */\n\n  }, {\n    key: \"groupId\",\n    get: function get() {\n      if (this._device) {\n        return this._device.groupId;\n      } else {\n        return undefined;\n      }\n    }\n    /**\n     * Returns a label describing this device (for example \"Built-in Microphone\").\n     * Returns undefined when the device is not open or label is not available\n     * because of permissions.\n     */\n\n  }, {\n    key: \"label\",\n    get: function get() {\n      if (this._device) {\n        return this._device.label;\n      } else {\n        return undefined;\n      }\n    }\n    /**\n     * Mute the output.\n     * @example\n     * const mic = new Tone.UserMedia();\n     * mic.open().then(() => {\n     * \t// promise resolves when input is available\n     * });\n     * // mute the output\n     * mic.mute = true;\n     */\n\n  }, {\n    key: \"mute\",\n    get: function get() {\n      return this._volume.mute;\n    },\n    set: function set(mute) {\n      this._volume.mute = mute;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(UserMedia.prototype), \"dispose\", this).call(this);\n\n      this.close();\n\n      this._volume.dispose();\n\n      this.volume.dispose();\n      return this;\n    }\n    /**\n     * If getUserMedia is supported by the browser.\n     */\n\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(ToneAudioNode.getDefaults(), {\n        mute: false,\n        volume: 0\n      });\n    }\n  }, {\n    key: \"enumerateDevices\",\n    value: function enumerateDevices() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var allDevices;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return navigator.mediaDevices.enumerateDevices();\n\n              case 2:\n                allDevices = _context2.sent;\n                return _context2.abrupt(\"return\", allDevices.filter(function (device) {\n                  return device.kind === \"audioinput\";\n                }));\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n    }\n  }, {\n    key: \"supported\",\n    get: function get() {\n      return isDefined(navigator.mediaDevices) && isDefined(navigator.mediaDevices.getUserMedia);\n    }\n  }]);\n\n  return UserMedia;\n}(ToneAudioNode);","map":{"version":3,"mappings":"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","names":["connect","ToneAudioNode","Volume","optionsFromArguments","assert","readOnly","isDefined","isNumber","UserMedia","getDefaults","arguments","options","_volume","output","context","volume","mute","labelOrId","supported","state","close","enumerateDevices","devices","_device","find","device","label","deviceId","length","constraints","audio","echoCancellation","sampleRate","noiseSuppression","mozNoiseSuppression","navigator","mediaDevices","getUserMedia","stream","_stream","mediaStreamNode","createMediaStreamSource","_mediaStream","getAudioTracks","forEach","track","stop","undefined","disconnect","active","groupId","dispose","Object","assign","allDevices","filter","kind"],"sourceRoot":"","sources":["../../../Tone/source/UserMedia.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}