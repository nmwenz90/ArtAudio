{"ast":null,"code":"/*!\n * @pixi/filter-glitch - v4.1.5\n * Compiled Wed, 29 Sep 2021 14:05:57 UTC\n *\n * @pixi/filter-glitch is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nimport { Texture, Filter } from '@pixi/core';\nimport { SCALE_MODES } from '@pixi/constants';\nimport { DEG_TO_RAD } from '@pixi/math';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\n\nvar _extendStatics = function extendStatics(d, b) {\n  _extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (Object.prototype.hasOwnProperty.call(b, p)) {\n        d[p] = b[p];\n      }\n    }\n  };\n\n  return _extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  _extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar vertex = \"attribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\n\\nuniform mat3 projectionMatrix;\\n\\nvarying vec2 vTextureCoord;\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n    vTextureCoord = aTextureCoord;\\n}\";\nvar fragment = \"// precision highp float;\\n\\nvarying vec2 vTextureCoord;\\nuniform sampler2D uSampler;\\n\\nuniform vec4 filterArea;\\nuniform vec4 filterClamp;\\nuniform vec2 dimensions;\\nuniform float aspect;\\n\\nuniform sampler2D displacementMap;\\nuniform float offset;\\nuniform float sinDir;\\nuniform float cosDir;\\nuniform int fillMode;\\n\\nuniform float seed;\\nuniform vec2 red;\\nuniform vec2 green;\\nuniform vec2 blue;\\n\\nconst int TRANSPARENT = 0;\\nconst int ORIGINAL = 1;\\nconst int LOOP = 2;\\nconst int CLAMP = 3;\\nconst int MIRROR = 4;\\n\\nvoid main(void)\\n{\\n    vec2 coord = (vTextureCoord * filterArea.xy) / dimensions;\\n\\n    if (coord.x > 1.0 || coord.y > 1.0) {\\n        return;\\n    }\\n\\n    float cx = coord.x - 0.5;\\n    float cy = (coord.y - 0.5) * aspect;\\n    float ny = (-sinDir * cx + cosDir * cy) / aspect + 0.5;\\n\\n    // displacementMap: repeat\\n    // ny = ny > 1.0 ? ny - 1.0 : (ny < 0.0 ? 1.0 + ny : ny);\\n\\n    // displacementMap: mirror\\n    ny = ny > 1.0 ? 2.0 - ny : (ny < 0.0 ? -ny : ny);\\n\\n    vec4 dc = texture2D(displacementMap, vec2(0.5, ny));\\n\\n    float displacement = (dc.r - dc.g) * (offset / filterArea.x);\\n\\n    coord = vTextureCoord + vec2(cosDir * displacement, sinDir * displacement * aspect);\\n\\n    if (fillMode == CLAMP) {\\n        coord = clamp(coord, filterClamp.xy, filterClamp.zw);\\n    } else {\\n        if( coord.x > filterClamp.z ) {\\n            if (fillMode == TRANSPARENT) {\\n                discard;\\n            } else if (fillMode == LOOP) {\\n                coord.x -= filterClamp.z;\\n            } else if (fillMode == MIRROR) {\\n                coord.x = filterClamp.z * 2.0 - coord.x;\\n            }\\n        } else if( coord.x < filterClamp.x ) {\\n            if (fillMode == TRANSPARENT) {\\n                discard;\\n            } else if (fillMode == LOOP) {\\n                coord.x += filterClamp.z;\\n            } else if (fillMode == MIRROR) {\\n                coord.x *= -filterClamp.z;\\n            }\\n        }\\n\\n        if( coord.y > filterClamp.w ) {\\n            if (fillMode == TRANSPARENT) {\\n                discard;\\n            } else if (fillMode == LOOP) {\\n                coord.y -= filterClamp.w;\\n            } else if (fillMode == MIRROR) {\\n                coord.y = filterClamp.w * 2.0 - coord.y;\\n            }\\n        } else if( coord.y < filterClamp.y ) {\\n            if (fillMode == TRANSPARENT) {\\n                discard;\\n            } else if (fillMode == LOOP) {\\n                coord.y += filterClamp.w;\\n            } else if (fillMode == MIRROR) {\\n                coord.y *= -filterClamp.w;\\n            }\\n        }\\n    }\\n\\n    gl_FragColor.r = texture2D(uSampler, coord + red * (1.0 - seed * 0.4) / filterArea.xy).r;\\n    gl_FragColor.g = texture2D(uSampler, coord + green * (1.0 - seed * 0.3) / filterArea.xy).g;\\n    gl_FragColor.b = texture2D(uSampler, coord + blue * (1.0 - seed * 0.2) / filterArea.xy).b;\\n    gl_FragColor.a = texture2D(uSampler, coord).a;\\n}\\n\";\n/**\n * The GlitchFilter applies a glitch effect to an object.<br>\n * ![original](../tools/screenshots/dist/original.png)![filter](../tools/screenshots/dist/glitch.png)\n *\n * @class\n * @extends PIXI.Filter\n * @memberof PIXI.filters\n * @see {@link https://www.npmjs.com/package/@pixi/filter-glitch|@pixi/filter-glitch}\n * @see {@link https://www.npmjs.com/package/pixi-filters|pixi-filters}\n */\n\nvar GlitchFilter =\n/** @class */\nfunction (_super) {\n  __extends(GlitchFilter, _super);\n  /**\n   * @param {object} [options] - The more optional parameters of the filter.\n   * @param {number} [options.slices=5] - The maximum number of slices.\n   * @param {number} [options.offset=100] - The maximum offset amount of slices.\n   * @param {number} [options.direction=0] - The angle in degree of the offset of slices.\n   * @param {number} [options.fillMode=0] - The fill mode of the space after the offset. Acceptable values:\n   *  - `0` {@link PIXI.filters.GlitchFilter.TRANSPARENT TRANSPARENT}\n   *  - `1` {@link PIXI.filters.GlitchFilter.ORIGINAL ORIGINAL}\n   *  - `2` {@link PIXI.filters.GlitchFilter.LOOP LOOP}\n   *  - `3` {@link PIXI.filters.GlitchFilter.CLAMP CLAMP}\n   *  - `4` {@link PIXI.filters.GlitchFilter.MIRROR MIRROR}\n   * @param {number} [options.seed=0] - A seed value for randomizing glitch effect.\n   * @param {boolean} [options.average=false] - `true` will divide the bands roughly based on equal amounts\n   *                 where as setting to `false` will vary the band sizes dramatically (more random looking).\n   * @param {number} [options.minSize=8] - Minimum size of individual slice. Segment of total `sampleSize`\n   * @param {number} [options.sampleSize=512] - The resolution of the displacement map texture.\n   * @param {number[]} [options.red=[0,0]] - Red channel offset\n   * @param {number[]} [options.green=[0,0]] - Green channel offset.\n   * @param {number[]} [options.blue=[0,0]] - Blue channel offset.\n   */\n\n\n  function GlitchFilter(options) {\n    var _this = _super.call(this, vertex, fragment) || this;\n    /** The maximum offset value for each of the slices. */\n\n\n    _this.offset = 100;\n    /** The fill mode of the space after the offset. */\n\n    _this.fillMode = GlitchFilter.TRANSPARENT;\n    /**\n     * `true` will divide the bands roughly based on equal amounts\n     * where as setting to `false` will vary the band sizes dramatically (more random looking).\n     */\n\n    _this.average = false;\n    /**\n     * A seed value for randomizing color offset. Animating\n     * this value to `Math.random()` produces a twitching effect.\n     */\n\n    _this.seed = 0;\n    /** Minimum size of slices as a portion of the `sampleSize` */\n\n    _this.minSize = 8;\n    /** Height of the displacement map canvas. */\n\n    _this.sampleSize = 512;\n    /** Internal number of slices */\n\n    _this._slices = 0;\n    _this._offsets = new Float32Array(1);\n    _this._sizes = new Float32Array(1);\n    /** direction is actually a setter for uniform.cosDir and uniform.sinDir.\n     * Must be initialized to something different than the default value.\n    */\n\n    _this._direction = -1;\n    _this.uniforms.dimensions = new Float32Array(2);\n    _this._canvas = document.createElement('canvas');\n    _this._canvas.width = 4;\n    _this._canvas.height = _this.sampleSize;\n    _this.texture = Texture.from(_this._canvas, {\n      scaleMode: SCALE_MODES.NEAREST\n    });\n    Object.assign(_this, GlitchFilter.defaults, options);\n    return _this;\n  }\n  /**\n   * Override existing apply method in PIXI.Filter\n   * @private\n   */\n\n\n  GlitchFilter.prototype.apply = function (filterManager, input, output, clear) {\n    var _a = input.filterFrame,\n        width = _a.width,\n        height = _a.height;\n    this.uniforms.dimensions[0] = width;\n    this.uniforms.dimensions[1] = height;\n    this.uniforms.aspect = height / width;\n    this.uniforms.seed = this.seed;\n    this.uniforms.offset = this.offset;\n    this.uniforms.fillMode = this.fillMode;\n    filterManager.applyFilter(this, input, output, clear);\n  };\n  /**\n   * Randomize the slices size (heights).\n   *\n   * @private\n   */\n\n\n  GlitchFilter.prototype._randomizeSizes = function () {\n    var arr = this._sizes;\n    var last = this._slices - 1;\n    var size = this.sampleSize;\n    var min = Math.min(this.minSize / size, 0.9 / this._slices);\n\n    if (this.average) {\n      var count = this._slices;\n      var rest = 1;\n\n      for (var i = 0; i < last; i++) {\n        var averageWidth = rest / (count - i);\n        var w = Math.max(averageWidth * (1 - Math.random() * 0.6), min);\n        arr[i] = w;\n        rest -= w;\n      }\n\n      arr[last] = rest;\n    } else {\n      var rest = 1;\n      var ratio = Math.sqrt(1 / this._slices);\n\n      for (var i = 0; i < last; i++) {\n        var w = Math.max(ratio * rest * Math.random(), min);\n        arr[i] = w;\n        rest -= w;\n      }\n\n      arr[last] = rest;\n    }\n\n    this.shuffle();\n  };\n  /**\n   * Shuffle the sizes of the slices, advanced usage.\n   */\n\n\n  GlitchFilter.prototype.shuffle = function () {\n    var arr = this._sizes;\n    var last = this._slices - 1; // shuffle\n\n    for (var i = last; i > 0; i--) {\n      var rand = Math.random() * i >> 0;\n      var temp = arr[i];\n      arr[i] = arr[rand];\n      arr[rand] = temp;\n    }\n  };\n  /**\n   * Randomize the values for offset from -1 to 1\n   *\n   * @private\n   */\n\n\n  GlitchFilter.prototype._randomizeOffsets = function () {\n    for (var i = 0; i < this._slices; i++) {\n      this._offsets[i] = Math.random() * (Math.random() < 0.5 ? -1 : 1);\n    }\n  };\n  /**\n   * Regenerating random size, offsets for slices.\n   */\n\n\n  GlitchFilter.prototype.refresh = function () {\n    this._randomizeSizes();\n\n    this._randomizeOffsets();\n\n    this.redraw();\n  };\n  /**\n   * Redraw displacement bitmap texture, advanced usage.\n   */\n\n\n  GlitchFilter.prototype.redraw = function () {\n    var size = this.sampleSize;\n    var texture = this.texture;\n\n    var ctx = this._canvas.getContext('2d');\n\n    ctx.clearRect(0, 0, 8, size);\n    var offset;\n    var y = 0;\n\n    for (var i = 0; i < this._slices; i++) {\n      offset = Math.floor(this._offsets[i] * 256);\n      var height = this._sizes[i] * size;\n      var red = offset > 0 ? offset : 0;\n      var green = offset < 0 ? -offset : 0;\n      ctx.fillStyle = \"rgba(\" + red + \", \" + green + \", 0, 1)\";\n      ctx.fillRect(0, y >> 0, size, height + 1 >> 0);\n      y += height;\n    }\n\n    texture.baseTexture.update();\n    this.uniforms.displacementMap = texture;\n  };\n\n  Object.defineProperty(GlitchFilter.prototype, \"sizes\", {\n    get: function get() {\n      return this._sizes;\n    },\n\n    /**\n     * Manually custom slices size (height) of displacement bitmap\n     *\n     * @member {number[]|Float32Array}\n     */\n    set: function set(sizes) {\n      var len = Math.min(this._slices, sizes.length);\n\n      for (var i = 0; i < len; i++) {\n        this._sizes[i] = sizes[i];\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GlitchFilter.prototype, \"offsets\", {\n    get: function get() {\n      return this._offsets;\n    },\n\n    /**\n     * Manually set custom slices offset of displacement bitmap, this is\n     * a collection of values from -1 to 1. To change the max offset value\n     * set `offset`.\n     *\n     * @member {number[]|Float32Array}\n     */\n    set: function set(offsets) {\n      var len = Math.min(this._slices, offsets.length);\n\n      for (var i = 0; i < len; i++) {\n        this._offsets[i] = offsets[i];\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GlitchFilter.prototype, \"slices\", {\n    /**\n     * The count of slices.\n     * @default 5\n     */\n    get: function get() {\n      return this._slices;\n    },\n    set: function set(value) {\n      if (this._slices === value) {\n        return;\n      }\n\n      this._slices = value;\n      this.uniforms.slices = value;\n      this._sizes = this.uniforms.slicesWidth = new Float32Array(value);\n      this._offsets = this.uniforms.slicesOffset = new Float32Array(value);\n      this.refresh();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GlitchFilter.prototype, \"direction\", {\n    /**\n     * The angle in degree of the offset of slices.\n     * @default 0\n     */\n    get: function get() {\n      return this._direction;\n    },\n    set: function set(value) {\n      if (this._direction === value) {\n        return;\n      }\n\n      this._direction = value;\n      var radians = value * DEG_TO_RAD;\n      this.uniforms.sinDir = Math.sin(radians);\n      this.uniforms.cosDir = Math.cos(radians);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GlitchFilter.prototype, \"red\", {\n    /**\n     * Red channel offset.\n     *\n     * @member {PIXI.Point|number[]}\n     */\n    get: function get() {\n      return this.uniforms.red;\n    },\n    set: function set(value) {\n      this.uniforms.red = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GlitchFilter.prototype, \"green\", {\n    /**\n     * Green channel offset.\n     *\n     * @member {PIXI.Point|number[]}\n     */\n    get: function get() {\n      return this.uniforms.green;\n    },\n    set: function set(value) {\n      this.uniforms.green = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(GlitchFilter.prototype, \"blue\", {\n    /**\n     * Blue offset.\n     *\n     * @member {PIXI.Point|number[]}\n     */\n    get: function get() {\n      return this.uniforms.blue;\n    },\n    set: function set(value) {\n      this.uniforms.blue = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Removes all references\n   */\n\n  GlitchFilter.prototype.destroy = function () {\n    var _a;\n\n    (_a = this.texture) === null || _a === void 0 ? void 0 : _a.destroy(true);\n    this.texture = this._canvas = this.red = this.green = this.blue = this._sizes = this._offsets = null;\n  };\n  /** Default constructor options. */\n\n\n  GlitchFilter.defaults = {\n    slices: 5,\n    offset: 100,\n    direction: 0,\n    fillMode: 0,\n    average: false,\n    seed: 0,\n    red: [0, 0],\n    green: [0, 0],\n    blue: [0, 0],\n    minSize: 8,\n    sampleSize: 512\n  };\n  /** Fill mode as transparent */\n\n  GlitchFilter.TRANSPARENT = 0;\n  /** Fill mode as original */\n\n  GlitchFilter.ORIGINAL = 1;\n  /** Fill mode as loop */\n\n  GlitchFilter.LOOP = 2;\n  /** Fill mode as clamp */\n\n  GlitchFilter.CLAMP = 3;\n  /** Fill mode as mirror */\n\n  GlitchFilter.MIRROR = 4;\n  return GlitchFilter;\n}(Filter);\n\nexport { GlitchFilter };","map":{"version":3,"mappings":"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","names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","__extends","__","constructor","create","options","_super","vertex","fragment","_this","GlitchFilter","TRANSPARENT","Float32Array","uniforms","dimensions","_canvas","document","createElement","width","height","sampleSize","texture","Texture","from","scaleMode","SCALE_MODES","NEAREST","assign","defaults","filterManager","input","output","clear","filterFrame","aspect","seed","offset","fillMode","applyFilter","arr","_sizes","last","_slices","size","min","Math","minSize","average","count","rest","i","averageWidth","w","max","random","ratio","sqrt","shuffle","rand","temp","_offsets","_randomizeSizes","_randomizeOffsets","redraw","ctx","getContext","clearRect","y","floor","red","green","fillStyle","fillRect","baseTexture","update","displacementMap","sizes","len","length","offsets","value","slices","slicesWidth","slicesOffset","refresh","_direction","radians","DEG_TO_RAD","sinDir","sin","cosDir","cos","blue","_a","destroy","direction","Filter"],"sources":["../../../node_modules/tslib/tslib.es6.js","../../../glitch/src/GlitchFilter.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { vertex } from '@tools/fragments';\nimport fragment from './glitch.frag';\nimport { Filter, Texture } from '@pixi/core';\nimport { SCALE_MODES } from '@pixi/constants';\nimport { DEG_TO_RAD, Rectangle } from '@pixi/math';\nimport type { IPoint } from '@pixi/math';\nimport type { FilterSystem, RenderTexture } from '@pixi/core';\nimport type { CLEAR_MODES } from '@pixi/constants';\n\ntype PointLike = IPoint | number[];\n\ninterface GlitchFilterOptions {\n    slices: number;\n    offset: number;\n    direction: number;\n    fillMode: number;\n    seed: number;\n    average: boolean;\n    minSize: number;\n    sampleSize: number;\n    red: PointLike;\n    green: PointLike;\n    blue: PointLike;\n}\n\n/**\n * The GlitchFilter applies a glitch effect to an object.<br>\n * ![original](../tools/screenshots/dist/original.png)![filter](../tools/screenshots/dist/glitch.png)\n *\n * @class\n * @extends PIXI.Filter\n * @memberof PIXI.filters\n * @see {@link https://www.npmjs.com/package/@pixi/filter-glitch|@pixi/filter-glitch}\n * @see {@link https://www.npmjs.com/package/pixi-filters|pixi-filters}\n */\nclass GlitchFilter extends Filter\n{\n    /** Default constructor options. */\n    public static readonly defaults: GlitchFilterOptions = {\n        slices: 5,\n        offset: 100,\n        direction: 0,\n        fillMode: 0,\n        average: false,\n        seed: 0,\n        red: [0, 0],\n        green: [0, 0],\n        blue: [0, 0],\n        minSize: 8,\n        sampleSize: 512,\n    };\n\n    /** Fill mode as transparent */\n    static readonly TRANSPARENT = 0;\n\n    /** Fill mode as original */\n    static readonly ORIGINAL = 1;\n\n    /** Fill mode as loop */\n    static readonly LOOP = 2;\n\n    /** Fill mode as clamp */\n    static readonly CLAMP = 3;\n\n    /** Fill mode as mirror */\n    static readonly MIRROR = 4;\n\n    /** The maximum offset value for each of the slices. */\n    public offset = 100;\n\n    /** The fill mode of the space after the offset. */\n    public fillMode: number = GlitchFilter.TRANSPARENT;\n\n    /**\n     * `true` will divide the bands roughly based on equal amounts\n     * where as setting to `false` will vary the band sizes dramatically (more random looking).\n     */\n    public average = false;\n\n    /**\n     * A seed value for randomizing color offset. Animating\n     * this value to `Math.random()` produces a twitching effect.\n     */\n    public seed = 0;\n\n    /** Minimum size of slices as a portion of the `sampleSize` */\n    public minSize = 8;\n\n    /** Height of the displacement map canvas. */\n    public sampleSize = 512;\n\n    /** Internally generated canvas. */\n    private _canvas: HTMLCanvasElement;\n\n    /**\n     * The displacement map is used to generate the bands.\n     * If using your own texture, `slices` will be ignored.\n     *\n     * @member {PIXI.Texture}\n     * @readonly\n     */\n    public texture: Texture;\n\n    /** Internal number of slices */\n    private _slices = 0;\n\n    private _offsets: Float32Array = new Float32Array(1);\n    private _sizes: Float32Array = new Float32Array(1);\n\n    /** direction is actually a setter for uniform.cosDir and uniform.sinDir.\n     * Must be initialized to something different than the default value.\n    */\n    private _direction = -1;\n\n    /**\n     * @param {object} [options] - The more optional parameters of the filter.\n     * @param {number} [options.slices=5] - The maximum number of slices.\n     * @param {number} [options.offset=100] - The maximum offset amount of slices.\n     * @param {number} [options.direction=0] - The angle in degree of the offset of slices.\n     * @param {number} [options.fillMode=0] - The fill mode of the space after the offset. Acceptable values:\n     *  - `0` {@link PIXI.filters.GlitchFilter.TRANSPARENT TRANSPARENT}\n     *  - `1` {@link PIXI.filters.GlitchFilter.ORIGINAL ORIGINAL}\n     *  - `2` {@link PIXI.filters.GlitchFilter.LOOP LOOP}\n     *  - `3` {@link PIXI.filters.GlitchFilter.CLAMP CLAMP}\n     *  - `4` {@link PIXI.filters.GlitchFilter.MIRROR MIRROR}\n     * @param {number} [options.seed=0] - A seed value for randomizing glitch effect.\n     * @param {boolean} [options.average=false] - `true` will divide the bands roughly based on equal amounts\n     *                 where as setting to `false` will vary the band sizes dramatically (more random looking).\n     * @param {number} [options.minSize=8] - Minimum size of individual slice. Segment of total `sampleSize`\n     * @param {number} [options.sampleSize=512] - The resolution of the displacement map texture.\n     * @param {number[]} [options.red=[0,0]] - Red channel offset\n     * @param {number[]} [options.green=[0,0]] - Green channel offset.\n     * @param {number[]} [options.blue=[0,0]] - Blue channel offset.\n     */\n    constructor(options?: Partial<GlitchFilterOptions>)\n    {\n        super(vertex, fragment);\n        this.uniforms.dimensions = new Float32Array(2);\n\n        this._canvas = document.createElement('canvas');\n        this._canvas.width = 4;\n        this._canvas.height = this.sampleSize;\n        this.texture = Texture.from(this._canvas, { scaleMode: SCALE_MODES.NEAREST });\n\n        Object.assign(this, GlitchFilter.defaults, options);\n    }\n\n    /**\n     * Override existing apply method in PIXI.Filter\n     * @private\n     */\n    apply(filterManager: FilterSystem, input: RenderTexture, output: RenderTexture, clear: CLEAR_MODES): void\n    {\n        const { width, height } = input.filterFrame as Rectangle;\n\n        this.uniforms.dimensions[0] = width;\n        this.uniforms.dimensions[1] = height;\n        this.uniforms.aspect = height / width;\n\n        this.uniforms.seed = this.seed;\n        this.uniforms.offset = this.offset;\n        this.uniforms.fillMode = this.fillMode;\n\n        filterManager.applyFilter(this, input, output, clear);\n    }\n\n    /**\n     * Randomize the slices size (heights).\n     *\n     * @private\n     */\n    private _randomizeSizes()\n    {\n        const arr = this._sizes;\n        const last = this._slices - 1;\n        const size = this.sampleSize;\n        const min = Math.min(this.minSize / size, 0.9 / this._slices);\n\n        if (this.average)\n        {\n            const count = this._slices;\n            let rest = 1;\n\n            for (let i = 0; i < last; i++)\n            {\n                const averageWidth = rest / (count - i);\n                const w =  Math.max(averageWidth * (1 - (Math.random() * 0.6)), min);\n\n                arr[i] = w;\n                rest -= w;\n            }\n            arr[last] = rest;\n        }\n        else\n        {\n            let rest = 1;\n            const ratio = Math.sqrt(1 / this._slices);\n\n            for (let i = 0; i < last; i++)\n            {\n                const w = Math.max(ratio * rest * Math.random(), min);\n\n                arr[i] = w;\n                rest -= w;\n            }\n            arr[last] = rest;\n        }\n\n        this.shuffle();\n    }\n\n    /**\n     * Shuffle the sizes of the slices, advanced usage.\n     */\n    shuffle(): void\n    {\n        const arr = this._sizes;\n        const last = this._slices - 1;\n\n        // shuffle\n        for (let i = last; i > 0; i--)\n        {\n            const rand = (Math.random() * i) >> 0;\n            const temp = arr[i];\n\n            arr[i] = arr[rand];\n            arr[rand] = temp;\n        }\n    }\n\n    /**\n     * Randomize the values for offset from -1 to 1\n     *\n     * @private\n     */\n    private _randomizeOffsets(): void\n    {\n        for (let i = 0; i < this._slices; i++)\n        {\n            this._offsets[i] = Math.random() * (Math.random() < 0.5 ? -1 : 1);\n        }\n    }\n\n    /**\n     * Regenerating random size, offsets for slices.\n     */\n    refresh(): void\n    {\n        this._randomizeSizes();\n        this._randomizeOffsets();\n        this.redraw();\n    }\n\n    /**\n     * Redraw displacement bitmap texture, advanced usage.\n     */\n    redraw(): void\n    {\n        const size = this.sampleSize;\n        const texture = this.texture;\n        const ctx = this._canvas.getContext('2d') as CanvasRenderingContext2D;\n\n        ctx.clearRect(0, 0, 8, size);\n\n        let offset;\n        let y = 0;\n\n        for (let i = 0; i < this._slices; i++)\n        {\n            offset = Math.floor(this._offsets[i] * 256);\n            const height = this._sizes[i] * size;\n            const red = offset > 0 ? offset : 0;\n            const green = offset < 0 ? -offset : 0;\n\n            ctx.fillStyle = `rgba(${red}, ${green}, 0, 1)`;\n            ctx.fillRect(0, y >> 0, size, height + 1 >> 0);\n            y += height;\n        }\n\n        texture.baseTexture.update();\n        this.uniforms.displacementMap = texture;\n    }\n\n    /**\n     * Manually custom slices size (height) of displacement bitmap\n     *\n     * @member {number[]|Float32Array}\n     */\n    set sizes(sizes: Float32Array)\n    {\n        const len = Math.min(this._slices, sizes.length);\n\n        for (let i = 0; i < len; i++)\n        {\n            this._sizes[i] = sizes[i];\n        }\n    }\n    get sizes(): Float32Array\n    {\n        return this._sizes;\n    }\n\n    /**\n     * Manually set custom slices offset of displacement bitmap, this is\n     * a collection of values from -1 to 1. To change the max offset value\n     * set `offset`.\n     *\n     * @member {number[]|Float32Array}\n     */\n    set offsets(offsets: Float32Array)\n    {\n        const len = Math.min(this._slices, offsets.length);\n\n        for (let i = 0; i < len; i++)\n        {\n            this._offsets[i] = offsets[i];\n        }\n    }\n    get offsets(): Float32Array\n    {\n        return this._offsets;\n    }\n\n    /**\n     * The count of slices.\n     * @default 5\n     */\n    get slices(): number\n    {\n        return this._slices;\n    }\n    set slices(value: number)\n    {\n        if (this._slices === value)\n        {\n            return;\n        }\n        this._slices = value;\n        this.uniforms.slices = value;\n        this._sizes = this.uniforms.slicesWidth = new Float32Array(value);\n        this._offsets = this.uniforms.slicesOffset = new Float32Array(value);\n        this.refresh();\n    }\n\n    /**\n     * The angle in degree of the offset of slices.\n     * @default 0\n     */\n    get direction(): number\n    {\n        return this._direction;\n    }\n    set direction(value: number)\n    {\n        if (this._direction === value)\n        {\n            return;\n        }\n        this._direction = value;\n\n        const radians = value * DEG_TO_RAD;\n\n        this.uniforms.sinDir = Math.sin(radians);\n        this.uniforms.cosDir = Math.cos(radians);\n    }\n\n    /**\n     * Red channel offset.\n     *\n     * @member {PIXI.Point|number[]}\n     */\n    get red(): PointLike\n    {\n        return this.uniforms.red;\n    }\n    set red(value: PointLike)\n    {\n        this.uniforms.red = value;\n    }\n\n    /**\n     * Green channel offset.\n     *\n     * @member {PIXI.Point|number[]}\n     */\n    get green(): PointLike\n    {\n        return this.uniforms.green;\n    }\n    set green(value: PointLike)\n    {\n        this.uniforms.green = value;\n    }\n\n    /**\n     * Blue offset.\n     *\n     * @member {PIXI.Point|number[]}\n     */\n    get blue(): PointLike\n    {\n        return this.uniforms.blue;\n    }\n    set blue(value: PointLike)\n    {\n        this.uniforms.blue = value;\n    }\n\n    /**\n     * Removes all references\n     */\n    destroy(): void\n    {\n        this.texture?.destroy(true);\n        this.texture\n        = this._canvas\n        = this.red\n        = this.green\n        = this.blue\n        = this._sizes\n        = this._offsets = null as any;\n    }\n}\n\nexport { GlitchFilter };\nexport type { GlitchFilterOptions };\n"]},"metadata":{},"sourceType":"module"}