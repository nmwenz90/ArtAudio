{"ast":null,"code":"import _classCallCheck from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _regeneratorRuntime from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator/index.js\";\nimport { __awaiter } from \"tslib\";\nimport { createOfflineAudioContext } from \"../context/AudioContext\";\nimport { Context } from \"../context/Context\";\nimport { isOfflineAudioContext } from \"../util/AdvancedTypeCheck\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer\";\n/**\n * Wrapper around the OfflineAudioContext\n * @category Core\n * @example\n * // generate a single channel, 0.5 second buffer\n * const context = new Tone.OfflineContext(1, 0.5, 44100);\n * const osc = new Tone.Oscillator({ context });\n * context.render().then(buffer => {\n * \tconsole.log(buffer.numberOfChannels, buffer.duration);\n * });\n */\n\nexport var OfflineContext = /*#__PURE__*/function (_Context) {\n  _inherits(OfflineContext, _Context);\n\n  var _super = _createSuper(OfflineContext);\n\n  function OfflineContext() {\n    var _this;\n\n    _classCallCheck(this, OfflineContext);\n\n    _this = _super.call(this, {\n      clockSource: \"offline\",\n      context: isOfflineAudioContext(arguments[0]) ? arguments[0] : createOfflineAudioContext(arguments[0], arguments[1] * arguments[2], arguments[2]),\n      lookAhead: 0,\n      updateInterval: isOfflineAudioContext(arguments[0]) ? 128 / arguments[0].sampleRate : 128 / arguments[2]\n    });\n    _this.name = \"OfflineContext\";\n    /**\n     * An artificial clock source\n     */\n\n    _this._currentTime = 0;\n    _this.isOffline = true;\n    _this._duration = isOfflineAudioContext(arguments[0]) ? arguments[0].length / arguments[0].sampleRate : arguments[1];\n    return _this;\n  }\n  /**\n   * Override the now method to point to the internal clock time\n   */\n\n\n  _createClass(OfflineContext, [{\n    key: \"now\",\n    value: function now() {\n      return this._currentTime;\n    }\n    /**\n     * Same as this.now()\n     */\n\n  }, {\n    key: \"currentTime\",\n    get: function get() {\n      return this._currentTime;\n    }\n    /**\n     * Render just the clock portion of the audio context.\n     */\n\n  }, {\n    key: \"_renderClock\",\n    value: function _renderClock(asynchronous) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var index, yieldEvery;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                index = 0;\n\n              case 1:\n                if (!(this._duration - this._currentTime >= 0)) {\n                  _context.next = 11;\n                  break;\n                }\n\n                // invoke all the callbacks on that time\n                this.emit(\"tick\"); // increment the clock in block-sized chunks\n\n                this._currentTime += 128 / this.sampleRate; // yield once a second of audio\n\n                index++;\n                yieldEvery = Math.floor(this.sampleRate / 128);\n\n                if (!(asynchronous && index % yieldEvery === 0)) {\n                  _context.next = 9;\n                  break;\n                }\n\n                _context.next = 9;\n                return new Promise(function (done) {\n                  return setTimeout(done, 1);\n                });\n\n              case 9:\n                _context.next = 1;\n                break;\n\n              case 11:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n    /**\n     * Render the output of the OfflineContext\n     * @param asynchronous If the clock should be rendered asynchronously, which will not block the main thread, but be slightly slower.\n     */\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      var asynchronous = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var buffer;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.workletsAreReady();\n\n              case 2:\n                _context2.next = 4;\n                return this._renderClock(asynchronous);\n\n              case 4:\n                _context2.next = 6;\n                return this._context.startRendering();\n\n              case 6:\n                buffer = _context2.sent;\n                return _context2.abrupt(\"return\", new ToneAudioBuffer(buffer));\n\n              case 8:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n    /**\n     * Close the context\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      return Promise.resolve();\n    }\n  }]);\n\n  return OfflineContext;\n}(Context);","map":{"version":3,"mappings":";;;;;;AAAA,SAASA,yBAAT,QAA0C,yBAA1C;AACA,SAASC,OAAT,QAAwB,oBAAxB;AAEA,SAASC,qBAAT,QAAsC,2BAAtC;AACA,SAASC,eAAT,QAAgC,mBAAhC;AAEA;;;;;;;;;;;;AAWA,WAAaC,cAAb;AAAA;;AAAA;;AAgCC;AAAA;;AAAA;;AAEC,8BAAM;AACLC,iBAAW,EAAE,SADR;AAELC,aAAO,EAAEJ,qBAAqB,CAACK,SAAS,CAAC,CAAD,CAAV,CAArB,GACRA,SAAS,CAAC,CAAD,CADD,GACOP,yBAAyB,CAACO,SAAS,CAAC,CAAD,CAAV,EAAeA,SAAS,CAAC,CAAD,CAAT,GAAeA,SAAS,CAAC,CAAD,CAAvC,EAA4CA,SAAS,CAAC,CAAD,CAArD,CAHpC;AAILC,eAAS,EAAE,CAJN;AAKLC,oBAAc,EAAEP,qBAAqB,CAACK,SAAS,CAAC,CAAD,CAAV,CAArB,GACf,MAAMA,SAAS,CAAC,CAAD,CAAT,CAAaG,UADJ,GACiB,MAAMH,SAAS,CAAC,CAAD;AAN3C,KAAN;AAhCQ,iBAAe,gBAAf;AAOT;;;;AAGQ,yBAAwB,CAAxB;AAOC,sBAAqB,IAArB;AAwBR,UAAKI,SAAL,GAAiBT,qBAAqB,CAACK,SAAS,CAAC,CAAD,CAAV,CAArB,GAChBA,SAAS,CAAC,CAAD,CAAT,CAAaK,MAAb,GAAsBL,SAAS,CAAC,CAAD,CAAT,CAAaG,UADnB,GACgCH,SAAS,CAAC,CAAD,CAD1D;AAXD;AAaC;AAED;;;;;AA/CD;AAAA;AAAA,WAkDC,eAAG;AACF,aAAO,KAAKM,YAAZ;AACA;AAED;;;;AAtDD;AAAA;AAAA,SAyDC,eAAe;AACd,aAAO,KAAKA,YAAZ;AACA;AAED;;;;AA7DD;AAAA;AAAA,WAgEe,sBAAaC,YAAb,EAAkC;;;;;;;AAC3CC,wBAAQ;;;sBACL,KAAKJ,SAAL,GAAiB,KAAKE,YAAtB,IAAsC;;;;;AAE5C;AACA,qBAAKG,IAAL,CAAU,MAAV,GAEA;;AACA,qBAAKH,YAAL,IAAqB,MAAM,KAAKH,UAAhC,EAEA;;AACAK,qBAAK;AACCE,6BAAaC,IAAI,CAACC,KAAL,CAAW,KAAKT,UAAL,GAAkB,GAA7B;;sBACfI,YAAY,IAAIC,KAAK,GAAGE,UAAR,KAAuB;;;;;;AAC1C,uBAAM,IAAIG,OAAJ,CAAY,cAAI;AAAA,yBAAIC,UAAU,CAACC,IAAD,EAAO,CAAP,CAAd;AAAA,iBAAhB,CAAN;;;;;;;;;;;;;AAGF;AAED;;;;;AAnFD;AAAA;AAAA,WAuFO,kBAA0B;AAAA,UAAnBR,YAAmB,uEAAJ,IAAI;;;;;;;;AAC/B,uBAAM,KAAKS,gBAAL,EAAN;;;;AACA,uBAAM,KAAKC,YAAL,CAAkBV,YAAlB,CAAN;;;;AACe,uBAAM,KAAKW,QAAL,CAAcC,cAAd,EAAN;;;AAATC;kDACC,IAAIxB,eAAJ,CAAoBwB,MAApB;;;;;;;;;AACP;AAED;;;;AA9FD;AAAA;AAAA,WAiGC,iBAAK;AACJ,aAAOP,OAAO,CAACQ,OAAR,EAAP;AACA;AAnGF;;AAAA;AAAA,EAAoC3B,OAApC","names":["createOfflineAudioContext","Context","isOfflineAudioContext","ToneAudioBuffer","OfflineContext","clockSource","context","arguments","lookAhead","updateInterval","sampleRate","_duration","length","_currentTime","asynchronous","index","emit","yieldEvery","Math","floor","Promise","setTimeout","done","workletsAreReady","_renderClock","_context","startRendering","buffer","resolve"],"sourceRoot":"","sources":["../../../../Tone/core/context/OfflineContext.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}