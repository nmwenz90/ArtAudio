{"ast":null,"code":"import _classCallCheck from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _regeneratorRuntime from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator/index.js\";\nimport { __awaiter } from \"tslib\";\nimport { Merge } from \"../component/channel/Merge\";\nimport { Gain } from \"../core/context/Gain\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Noise } from \"../source/Noise\";\nimport { Effect } from \"./Effect\";\nimport { OfflineContext } from \"../core/context/OfflineContext\";\nimport { noOp } from \"../core/util/Interface\";\nimport { assertRange } from \"../core/util/Debug\";\n/**\n * Simple convolution created with decaying noise.\n * Generates an Impulse Response Buffer\n * with Tone.Offline then feeds the IR into ConvolverNode.\n * The impulse response generation is async, so you have\n * to wait until [[ready]] resolves before it will make a sound.\n *\n * Inspiration from [ReverbGen](https://github.com/adelespinasse/reverbGen).\n * Copyright (c) 2014 Alan deLespinasse Apache 2.0 License.\n *\n * @category Effect\n */\n\nexport var Reverb = /*#__PURE__*/function (_Effect) {\n  _inherits(Reverb, _Effect);\n\n  var _super = _createSuper(Reverb);\n\n  function Reverb() {\n    var _this;\n\n    _classCallCheck(this, Reverb);\n\n    _this = _super.call(this, optionsFromArguments(Reverb.getDefaults(), arguments, [\"decay\"]));\n    _this.name = \"Reverb\";\n    /**\n     * Convolver node\n     */\n\n    _this._convolver = _this.context.createConvolver();\n    /**\n     * Resolves when the reverb buffer is generated. Whenever either [[decay]]\n     * or [[preDelay]] are set, you have to wait until [[ready]] resolves\n     * before the IR is generated with the latest values.\n     */\n\n    _this.ready = Promise.resolve();\n    var options = optionsFromArguments(Reverb.getDefaults(), arguments, [\"decay\"]);\n    _this._decay = options.decay;\n    _this._preDelay = options.preDelay;\n\n    _this.generate();\n\n    _this.connectEffect(_this._convolver);\n\n    return _this;\n  }\n\n  _createClass(Reverb, [{\n    key: \"decay\",\n    get:\n    /**\n     * The duration of the reverb.\n     */\n    function get() {\n      return this._decay;\n    },\n    set: function set(time) {\n      time = this.toSeconds(time);\n      assertRange(time, 0.001);\n      this._decay = time;\n      this.generate();\n    }\n    /**\n     * The amount of time before the reverb is fully ramped in.\n     */\n\n  }, {\n    key: \"preDelay\",\n    get: function get() {\n      return this._preDelay;\n    },\n    set: function set(time) {\n      time = this.toSeconds(time);\n      assertRange(time, 0);\n      this._preDelay = time;\n      this.generate();\n    }\n    /**\n     * Generate the Impulse Response. Returns a promise while the IR is being generated.\n     * @return Promise which returns this object.\n     */\n\n  }, {\n    key: \"generate\",\n    value: function generate() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var previousReady, context, noiseL, noiseR, merge, gainNode, renderPromise;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                previousReady = this.ready; // create a noise burst which decays over the duration in each channel\n\n                context = new OfflineContext(2, this._decay + this._preDelay, this.context.sampleRate);\n                noiseL = new Noise({\n                  context: context\n                });\n                noiseR = new Noise({\n                  context: context\n                });\n                merge = new Merge({\n                  context: context\n                });\n                noiseL.connect(merge, 0, 0);\n                noiseR.connect(merge, 0, 1);\n                gainNode = new Gain({\n                  context: context\n                }).toDestination();\n                merge.connect(gainNode);\n                noiseL.start(0);\n                noiseR.start(0); // predelay\n\n                gainNode.gain.setValueAtTime(0, 0);\n                gainNode.gain.setValueAtTime(1, this._preDelay); // decay\n\n                gainNode.gain.exponentialApproachValueAtTime(0, this._preDelay, this.decay); // render the buffer\n\n                renderPromise = context.render();\n                this.ready = renderPromise.then(noOp); // wait for the previous `ready` to resolve\n\n                _context.next = 18;\n                return previousReady;\n\n              case 18:\n                _context.next = 20;\n                return renderPromise;\n\n              case 20:\n                this._convolver.buffer = _context.sent.get();\n                return _context.abrupt(\"return\", this);\n\n              case 22:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(Reverb.prototype), \"dispose\", this).call(this);\n\n      this._convolver.disconnect();\n\n      return this;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(Effect.getDefaults(), {\n        decay: 1.5,\n        preDelay: 0.01\n      });\n    }\n  }]);\n\n  return Reverb;\n}(Effect);","map":{"version":3,"mappings":"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","names":["Merge","Gain","optionsFromArguments","Noise","Effect","OfflineContext","noOp","assertRange","Reverb","getDefaults","arguments","context","createConvolver","Promise","resolve","options","_decay","decay","_preDelay","preDelay","generate","connectEffect","_convolver","time","toSeconds","previousReady","ready","sampleRate","noiseL","noiseR","merge","connect","gainNode","toDestination","start","gain","setValueAtTime","exponentialApproachValueAtTime","renderPromise","render","then","buffer","get","disconnect","Object","assign"],"sourceRoot":"","sources":["../../../Tone/effect/Reverb.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}