{"ast":null,"code":"import _classCallCheck from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { ToneWithContext } from \"../context/ToneWithContext\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { StateTimeline } from \"../util/StateTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { TickSignal } from \"./TickSignal\";\nimport { EQ } from \"../util/Math\";\n/**\n * Uses [TickSignal](TickSignal) to track elapsed ticks with complex automation curves.\n */\n\nexport var TickSource = /*#__PURE__*/function (_ToneWithContext) {\n  _inherits(TickSource, _ToneWithContext);\n\n  var _super = _createSuper(TickSource);\n\n  function TickSource() {\n    var _this;\n\n    _classCallCheck(this, TickSource);\n\n    _this = _super.call(this, optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]));\n    _this.name = \"TickSource\";\n    /**\n     * The state timeline\n     */\n\n    _this._state = new StateTimeline();\n    /**\n     * The offset values of the ticks\n     */\n\n    _this._tickOffset = new Timeline();\n    var options = optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]);\n    _this.frequency = new TickSignal({\n      context: _this.context,\n      units: options.units,\n      value: options.frequency\n    });\n    readOnly(_assertThisInitialized(_this), \"frequency\"); // set the initial state\n\n    _this._state.setStateAtTime(\"stopped\", 0); // add the first event\n\n\n    _this.setTicksAtTime(0, 0);\n\n    return _this;\n  }\n\n  _createClass(TickSource, [{\n    key: \"state\",\n    get:\n    /**\n     * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n     */\n    function get() {\n      return this.getStateAtTime(this.now());\n    }\n    /**\n     * Start the clock at the given time. Optionally pass in an offset\n     * of where to start the tick counter from.\n     * @param  time    The time the clock should start\n     * @param offset The number of ticks to start the source at\n     */\n\n  }, {\n    key: \"start\",\n    value: function start(time, offset) {\n      var computedTime = this.toSeconds(time);\n\n      if (this._state.getValueAtTime(computedTime) !== \"started\") {\n        this._state.setStateAtTime(\"started\", computedTime);\n\n        if (isDefined(offset)) {\n          this.setTicksAtTime(offset, computedTime);\n        }\n      }\n\n      return this;\n    }\n    /**\n     * Stop the clock. Stopping the clock resets the tick counter to 0.\n     * @param time The time when the clock should stop.\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop(time) {\n      var computedTime = this.toSeconds(time); // cancel the previous stop\n\n      if (this._state.getValueAtTime(computedTime) === \"stopped\") {\n        var event = this._state.get(computedTime);\n\n        if (event && event.time > 0) {\n          this._tickOffset.cancel(event.time);\n\n          this._state.cancel(event.time);\n        }\n      }\n\n      this._state.cancel(computedTime);\n\n      this._state.setStateAtTime(\"stopped\", computedTime);\n\n      this.setTicksAtTime(0, computedTime);\n      return this;\n    }\n    /**\n     * Pause the clock. Pausing does not reset the tick counter.\n     * @param time The time when the clock should stop.\n     */\n\n  }, {\n    key: \"pause\",\n    value: function pause(time) {\n      var computedTime = this.toSeconds(time);\n\n      if (this._state.getValueAtTime(computedTime) === \"started\") {\n        this._state.setStateAtTime(\"paused\", computedTime);\n      }\n\n      return this;\n    }\n    /**\n     * Cancel start/stop/pause and setTickAtTime events scheduled after the given time.\n     * @param time When to clear the events after\n     */\n\n  }, {\n    key: \"cancel\",\n    value: function cancel(time) {\n      time = this.toSeconds(time);\n\n      this._state.cancel(time);\n\n      this._tickOffset.cancel(time);\n\n      return this;\n    }\n    /**\n     * Get the elapsed ticks at the given time\n     * @param  time  When to get the tick value\n     * @return The number of ticks\n     */\n\n  }, {\n    key: \"getTicksAtTime\",\n    value: function getTicksAtTime(time) {\n      var _this2 = this;\n\n      var computedTime = this.toSeconds(time);\n\n      var stopEvent = this._state.getLastState(\"stopped\", computedTime); // this event allows forEachBetween to iterate until the current time\n\n\n      var tmpEvent = {\n        state: \"paused\",\n        time: computedTime\n      };\n\n      this._state.add(tmpEvent); // keep track of the previous offset event\n\n\n      var lastState = stopEvent;\n      var elapsedTicks = 0; // iterate through all the events since the last stop\n\n      this._state.forEachBetween(stopEvent.time, computedTime + this.sampleTime, function (e) {\n        var periodStartTime = lastState.time; // if there is an offset event in this period use that\n\n        var offsetEvent = _this2._tickOffset.get(e.time);\n\n        if (offsetEvent && offsetEvent.time >= lastState.time) {\n          elapsedTicks = offsetEvent.ticks;\n          periodStartTime = offsetEvent.time;\n        }\n\n        if (lastState.state === \"started\" && e.state !== \"started\") {\n          elapsedTicks += _this2.frequency.getTicksAtTime(e.time) - _this2.frequency.getTicksAtTime(periodStartTime);\n        }\n\n        lastState = e;\n      }); // remove the temporary event\n\n\n      this._state.remove(tmpEvent); // return the ticks\n\n\n      return elapsedTicks;\n    }\n    /**\n     * The number of times the callback was invoked. Starts counting at 0\n     * and increments after the callback was invoked. Returns -1 when stopped.\n     */\n\n  }, {\n    key: \"ticks\",\n    get: function get() {\n      return this.getTicksAtTime(this.now());\n    },\n    set: function set(t) {\n      this.setTicksAtTime(t, this.now());\n    }\n    /**\n     * The time since ticks=0 that the TickSource has been running. Accounts\n     * for tempo curves\n     */\n\n  }, {\n    key: \"seconds\",\n    get: function get() {\n      return this.getSecondsAtTime(this.now());\n    },\n    set: function set(s) {\n      var now = this.now();\n      var ticks = this.frequency.timeToTicks(s, now);\n      this.setTicksAtTime(ticks, now);\n    }\n    /**\n     * Return the elapsed seconds at the given time.\n     * @param  time  When to get the elapsed seconds\n     * @return  The number of elapsed seconds\n     */\n\n  }, {\n    key: \"getSecondsAtTime\",\n    value: function getSecondsAtTime(time) {\n      var _this3 = this;\n\n      time = this.toSeconds(time);\n\n      var stopEvent = this._state.getLastState(\"stopped\", time); // this event allows forEachBetween to iterate until the current time\n\n\n      var tmpEvent = {\n        state: \"paused\",\n        time: time\n      };\n\n      this._state.add(tmpEvent); // keep track of the previous offset event\n\n\n      var lastState = stopEvent;\n      var elapsedSeconds = 0; // iterate through all the events since the last stop\n\n      this._state.forEachBetween(stopEvent.time, time + this.sampleTime, function (e) {\n        var periodStartTime = lastState.time; // if there is an offset event in this period use that\n\n        var offsetEvent = _this3._tickOffset.get(e.time);\n\n        if (offsetEvent && offsetEvent.time >= lastState.time) {\n          elapsedSeconds = offsetEvent.seconds;\n          periodStartTime = offsetEvent.time;\n        }\n\n        if (lastState.state === \"started\" && e.state !== \"started\") {\n          elapsedSeconds += e.time - periodStartTime;\n        }\n\n        lastState = e;\n      }); // remove the temporary event\n\n\n      this._state.remove(tmpEvent); // return the ticks\n\n\n      return elapsedSeconds;\n    }\n    /**\n     * Set the clock's ticks at the given time.\n     * @param  ticks The tick value to set\n     * @param  time  When to set the tick value\n     */\n\n  }, {\n    key: \"setTicksAtTime\",\n    value: function setTicksAtTime(ticks, time) {\n      time = this.toSeconds(time);\n\n      this._tickOffset.cancel(time);\n\n      this._tickOffset.add({\n        seconds: this.frequency.getDurationOfTicks(ticks, time),\n        ticks: ticks,\n        time: time\n      });\n\n      return this;\n    }\n    /**\n     * Returns the scheduled state at the given time.\n     * @param  time  The time to query.\n     */\n\n  }, {\n    key: \"getStateAtTime\",\n    value: function getStateAtTime(time) {\n      time = this.toSeconds(time);\n      return this._state.getValueAtTime(time);\n    }\n    /**\n     * Get the time of the given tick. The second argument\n     * is when to test before. Since ticks can be set (with setTicksAtTime)\n     * there may be multiple times for a given tick value.\n     * @param  tick The tick number.\n     * @param  before When to measure the tick value from.\n     * @return The time of the tick\n     */\n\n  }, {\n    key: \"getTimeOfTick\",\n    value: function getTimeOfTick(tick) {\n      var before = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.now();\n\n      var offset = this._tickOffset.get(before);\n\n      var event = this._state.get(before);\n\n      var startTime = Math.max(offset.time, event.time);\n      var absoluteTicks = this.frequency.getTicksAtTime(startTime) + tick - offset.ticks;\n      return this.frequency.getTimeOfTick(absoluteTicks);\n    }\n    /**\n     * Invoke the callback event at all scheduled ticks between the\n     * start time and the end time\n     * @param  startTime  The beginning of the search range\n     * @param  endTime    The end of the search range\n     * @param  callback   The callback to invoke with each tick\n     */\n\n  }, {\n    key: \"forEachTickBetween\",\n    value: function forEachTickBetween(startTime, endTime, callback) {\n      var _this4 = this;\n\n      // only iterate through the sections where it is \"started\"\n      var lastStateEvent = this._state.get(startTime);\n\n      this._state.forEachBetween(startTime, endTime, function (event) {\n        if (lastStateEvent && lastStateEvent.state === \"started\" && event.state !== \"started\") {\n          _this4.forEachTickBetween(Math.max(lastStateEvent.time, startTime), event.time - _this4.sampleTime, callback);\n        }\n\n        lastStateEvent = event;\n      });\n\n      var error = null;\n\n      if (lastStateEvent && lastStateEvent.state === \"started\") {\n        var maxStartTime = Math.max(lastStateEvent.time, startTime); // figure out the difference between the frequency ticks and the\n\n        var startTicks = this.frequency.getTicksAtTime(maxStartTime);\n        var ticksAtStart = this.frequency.getTicksAtTime(lastStateEvent.time);\n        var diff = startTicks - ticksAtStart;\n        var offset = Math.ceil(diff) - diff; // guard against floating point issues\n\n        offset = EQ(offset, 1) ? 0 : offset;\n        var nextTickTime = this.frequency.getTimeOfTick(startTicks + offset);\n\n        while (nextTickTime < endTime) {\n          try {\n            callback(nextTickTime, Math.round(this.getTicksAtTime(nextTickTime)));\n          } catch (e) {\n            error = e;\n            break;\n          }\n\n          nextTickTime += this.frequency.getDurationOfTicks(1, nextTickTime);\n        }\n      }\n\n      if (error) {\n        throw error;\n      }\n\n      return this;\n    }\n    /**\n     * Clean up\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(TickSource.prototype), \"dispose\", this).call(this);\n\n      this._state.dispose();\n\n      this._tickOffset.dispose();\n\n      this.frequency.dispose();\n      return this;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign({\n        frequency: 1,\n        units: \"hertz\"\n      }, ToneWithContext.getDefaults());\n    }\n  }]);\n\n  return TickSource;\n}(ToneWithContext);","map":{"version":3,"mappings":"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","names":["ToneWithContext","optionsFromArguments","readOnly","StateTimeline","Timeline","isDefined","TickSignal","EQ","TickSource","getDefaults","arguments","options","frequency","context","units","value","_state","setStateAtTime","setTicksAtTime","getStateAtTime","now","time","offset","computedTime","toSeconds","getValueAtTime","event","get","_tickOffset","cancel","stopEvent","getLastState","tmpEvent","state","add","lastState","elapsedTicks","forEachBetween","sampleTime","periodStartTime","offsetEvent","e","ticks","getTicksAtTime","remove","t","getSecondsAtTime","s","timeToTicks","elapsedSeconds","seconds","getDurationOfTicks","tick","before","startTime","Math","max","absoluteTicks","getTimeOfTick","endTime","callback","lastStateEvent","forEachTickBetween","error","maxStartTime","startTicks","ticksAtStart","diff","ceil","nextTickTime","round","dispose","Object","assign"],"sourceRoot":"","sources":["../../../../Tone/core/clock/TickSource.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}