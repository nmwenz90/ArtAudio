{"ast":null,"code":"import _classCallCheck from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Volume } from \"../component/channel/Volume\";\nimport \"../core/context/Destination\";\nimport \"../core/clock/Transport\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { defaultArg } from \"../core/util/Defaults\";\nimport { noOp, readOnly } from \"../core/util/Interface\";\nimport { StateTimeline } from \"../core/util/StateTimeline\";\nimport { isDefined, isUndef } from \"../core/util/TypeCheck\";\nimport { assert, assertContextRunning } from \"../core/util/Debug\";\nimport { GT } from \"../core/util/Math\";\n/**\n * Base class for sources.\n * start/stop of this.context.transport.\n *\n * ```\n * // Multiple state change events can be chained together,\n * // but must be set in the correct order and with ascending times\n * // OK\n * state.start().stop(\"+0.2\");\n * // OK\n * state.start().stop(\"+0.2\").start(\"+0.4\").stop(\"+0.7\")\n * // BAD\n * state.stop(\"+0.2\").start();\n * // BAD\n * state.start(\"+0.3\").stop(\"+0.2\");\n * ```\n */\n\nexport var Source = /*#__PURE__*/function (_ToneAudioNode) {\n  _inherits(Source, _ToneAudioNode);\n\n  var _super = _createSuper(Source);\n\n  function Source(options) {\n    var _this;\n\n    _classCallCheck(this, Source);\n\n    _this = _super.call(this, options);\n    /**\n     * Sources have no inputs\n     */\n\n    _this.input = undefined;\n    /**\n     * Keep track of the scheduled state.\n     */\n\n    _this._state = new StateTimeline(\"stopped\");\n    /**\n     * The synced `start` callback function from the transport\n     */\n\n    _this._synced = false;\n    /**\n     * Keep track of all of the scheduled event ids\n     */\n\n    _this._scheduled = [];\n    /**\n     * Placeholder functions for syncing/unsyncing to transport\n     */\n\n    _this._syncedStart = noOp;\n    _this._syncedStop = noOp;\n    _this._state.memory = 100;\n    _this._state.increasing = true;\n    _this._volume = _this.output = new Volume({\n      context: _this.context,\n      mute: options.mute,\n      volume: options.volume\n    });\n    _this.volume = _this._volume.volume;\n    readOnly(_assertThisInitialized(_this), \"volume\");\n    _this.onstop = options.onstop;\n    return _this;\n  }\n\n  _createClass(Source, [{\n    key: \"state\",\n    get:\n    /**\n     * Returns the playback state of the source, either \"started\" or \"stopped\".\n     * @example\n     * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/ahntone_c3.mp3\", () => {\n     * \tplayer.start();\n     * \tconsole.log(player.state);\n     * }).toDestination();\n     */\n    function get() {\n      if (this._synced) {\n        if (this.context.transport.state === \"started\") {\n          return this._state.getValueAtTime(this.context.transport.seconds);\n        } else {\n          return \"stopped\";\n        }\n      } else {\n        return this._state.getValueAtTime(this.now());\n      }\n    }\n    /**\n     * Mute the output.\n     * @example\n     * const osc = new Tone.Oscillator().toDestination().start();\n     * // mute the output\n     * osc.mute = true;\n     */\n\n  }, {\n    key: \"mute\",\n    get: function get() {\n      return this._volume.mute;\n    },\n    set: function set(mute) {\n      this._volume.mute = mute;\n    }\n    /**\n     * Ensure that the scheduled time is not before the current time.\n     * Should only be used when scheduled unsynced.\n     */\n\n  }, {\n    key: \"_clampToCurrentTime\",\n    value: function _clampToCurrentTime(time) {\n      if (this._synced) {\n        return time;\n      } else {\n        return Math.max(time, this.context.currentTime);\n      }\n    }\n    /**\n     * Start the source at the specified time. If no time is given,\n     * start the source now.\n     * @param  time When the source should be started.\n     * @example\n     * const source = new Tone.Oscillator().toDestination();\n     * source.start(\"+0.5\"); // starts the source 0.5 seconds from now\n     */\n\n  }, {\n    key: \"start\",\n    value: function start(time, offset, duration) {\n      var _this2 = this;\n\n      var computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);\n      computedTime = this._clampToCurrentTime(computedTime); // if it's started, stop it and restart it\n\n      if (!this._synced && this._state.getValueAtTime(computedTime) === \"started\") {\n        // time should be strictly greater than the previous start time\n        assert(GT(computedTime, this._state.get(computedTime).time), \"Start time must be strictly greater than previous start time\");\n\n        this._state.cancel(computedTime);\n\n        this._state.setStateAtTime(\"started\", computedTime);\n\n        this.log(\"restart\", computedTime);\n        this.restart(computedTime, offset, duration);\n      } else {\n        this.log(\"start\", computedTime);\n\n        this._state.setStateAtTime(\"started\", computedTime);\n\n        if (this._synced) {\n          // add the offset time to the event\n          var event = this._state.get(computedTime);\n\n          if (event) {\n            event.offset = this.toSeconds(defaultArg(offset, 0));\n            event.duration = duration ? this.toSeconds(duration) : undefined;\n          }\n\n          var sched = this.context.transport.schedule(function (t) {\n            _this2._start(t, offset, duration);\n          }, computedTime);\n\n          this._scheduled.push(sched); // if the transport is already started\n          // and the time is greater than where the transport is\n\n\n          if (this.context.transport.state === \"started\" && this.context.transport.getSecondsAtTime(this.immediate()) > computedTime) {\n            this._syncedStart(this.now(), this.context.transport.seconds);\n          }\n        } else {\n          assertContextRunning(this.context);\n\n          this._start(computedTime, offset, duration);\n        }\n      }\n\n      return this;\n    }\n    /**\n     * Stop the source at the specified time. If no time is given,\n     * stop the source now.\n     * @param  time When the source should be stopped.\n     * @example\n     * const source = new Tone.Oscillator().toDestination();\n     * source.start();\n     * source.stop(\"+0.5\"); // stops the source 0.5 seconds from now\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop(time) {\n      var computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);\n      computedTime = this._clampToCurrentTime(computedTime);\n\n      if (this._state.getValueAtTime(computedTime) === \"started\" || isDefined(this._state.getNextState(\"started\", computedTime))) {\n        this.log(\"stop\", computedTime);\n\n        if (!this._synced) {\n          this._stop(computedTime);\n        } else {\n          var sched = this.context.transport.schedule(this._stop.bind(this), computedTime);\n\n          this._scheduled.push(sched);\n        }\n\n        this._state.cancel(computedTime);\n\n        this._state.setStateAtTime(\"stopped\", computedTime);\n      }\n\n      return this;\n    }\n    /**\n     * Restart the source.\n     */\n\n  }, {\n    key: \"restart\",\n    value: function restart(time, offset, duration) {\n      time = this.toSeconds(time);\n\n      if (this._state.getValueAtTime(time) === \"started\") {\n        this._state.cancel(time);\n\n        this._restart(time, offset, duration);\n      }\n\n      return this;\n    }\n    /**\n     * Sync the source to the Transport so that all subsequent\n     * calls to `start` and `stop` are synced to the TransportTime\n     * instead of the AudioContext time.\n     *\n     * @example\n     * const osc = new Tone.Oscillator().toDestination();\n     * // sync the source so that it plays between 0 and 0.3 on the Transport's timeline\n     * osc.sync().start(0).stop(0.3);\n     * // start the transport.\n     * Tone.Transport.start();\n     * // set it to loop once a second\n     * Tone.Transport.loop = true;\n     * Tone.Transport.loopEnd = 1;\n     */\n\n  }, {\n    key: \"sync\",\n    value: function sync() {\n      var _this3 = this;\n\n      if (!this._synced) {\n        this._synced = true;\n\n        this._syncedStart = function (time, offset) {\n          if (offset > 0) {\n            // get the playback state at that time\n            var stateEvent = _this3._state.get(offset); // listen for start events which may occur in the middle of the sync'ed time\n\n\n            if (stateEvent && stateEvent.state === \"started\" && stateEvent.time !== offset) {\n              // get the offset\n              var startOffset = offset - _this3.toSeconds(stateEvent.time);\n\n              var duration;\n\n              if (stateEvent.duration) {\n                duration = _this3.toSeconds(stateEvent.duration) - startOffset;\n              }\n\n              _this3._start(time, _this3.toSeconds(stateEvent.offset) + startOffset, duration);\n            }\n          }\n        };\n\n        this._syncedStop = function (time) {\n          var seconds = _this3.context.transport.getSecondsAtTime(Math.max(time - _this3.sampleTime, 0));\n\n          if (_this3._state.getValueAtTime(seconds) === \"started\") {\n            _this3._stop(time);\n          }\n        };\n\n        this.context.transport.on(\"start\", this._syncedStart);\n        this.context.transport.on(\"loopStart\", this._syncedStart);\n        this.context.transport.on(\"stop\", this._syncedStop);\n        this.context.transport.on(\"pause\", this._syncedStop);\n        this.context.transport.on(\"loopEnd\", this._syncedStop);\n      }\n\n      return this;\n    }\n    /**\n     * Unsync the source to the Transport. See Source.sync\n     */\n\n  }, {\n    key: \"unsync\",\n    value: function unsync() {\n      var _this4 = this;\n\n      if (this._synced) {\n        this.context.transport.off(\"stop\", this._syncedStop);\n        this.context.transport.off(\"pause\", this._syncedStop);\n        this.context.transport.off(\"loopEnd\", this._syncedStop);\n        this.context.transport.off(\"start\", this._syncedStart);\n        this.context.transport.off(\"loopStart\", this._syncedStart);\n      }\n\n      this._synced = false; // clear all of the scheduled ids\n\n      this._scheduled.forEach(function (id) {\n        return _this4.context.transport.clear(id);\n      });\n\n      this._scheduled = [];\n\n      this._state.cancel(0); // stop it also\n\n\n      this._stop(0);\n\n      return this;\n    }\n    /**\n     * Clean up.\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(Source.prototype), \"dispose\", this).call(this);\n\n      this.onstop = noOp;\n      this.unsync();\n\n      this._volume.dispose();\n\n      this._state.dispose();\n\n      return this;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(ToneAudioNode.getDefaults(), {\n        mute: false,\n        onstop: noOp,\n        volume: 0\n      });\n    }\n  }]);\n\n  return Source;\n}(ToneAudioNode);","map":{"version":3,"mappings":"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","names":["Volume","ToneAudioNode","defaultArg","noOp","readOnly","StateTimeline","isDefined","isUndef","assert","assertContextRunning","GT","Source","options","undefined","_state","memory","increasing","_volume","output","context","mute","volume","onstop","_synced","transport","state","getValueAtTime","seconds","now","time","Math","max","currentTime","offset","duration","computedTime","toSeconds","_clampToCurrentTime","get","cancel","setStateAtTime","log","restart","event","sched","schedule","_start","t","_scheduled","push","getSecondsAtTime","immediate","_syncedStart","getNextState","_stop","bind","_restart","stateEvent","startOffset","_syncedStop","sampleTime","on","off","forEach","clear","id","unsync","dispose","Object","assign","getDefaults"],"sourceRoot":"","sources":["../../../Tone/source/Source.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}