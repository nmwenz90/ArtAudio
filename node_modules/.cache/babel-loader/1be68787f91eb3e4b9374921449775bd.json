{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _regeneratorRuntime from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator/index.js\";\nimport { __awaiter } from \"tslib\";\nimport { getContext } from \"../Global\";\nimport { Tone } from \"../Tone\";\nimport { isAudioBuffer } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { noOp } from \"../util/Interface\";\nimport { isArray, isNumber, isString } from \"../util/TypeCheck\";\nimport { assert } from \"../util/Debug\";\n/**\n * AudioBuffer loading and storage. ToneAudioBuffer is used internally by all\n * classes that make requests for audio files such as Tone.Player,\n * Tone.Sampler and Tone.Convolver.\n * @example\n * const buffer = new Tone.ToneAudioBuffer(\"https://tonejs.github.io/audio/casio/A1.mp3\", () => {\n * \tconsole.log(\"loaded\");\n * });\n * @category Core\n */\n\nexport var ToneAudioBuffer = /*#__PURE__*/function (_Tone) {\n  _inherits(ToneAudioBuffer, _Tone);\n\n  var _super = _createSuper(ToneAudioBuffer);\n\n  function ToneAudioBuffer() {\n    var _this;\n\n    _classCallCheck(this, ToneAudioBuffer);\n\n    _this = _super.call(this);\n    _this.name = \"ToneAudioBuffer\";\n    /**\n     * Callback when the buffer is loaded.\n     */\n\n    _this.onload = noOp;\n    var options = optionsFromArguments(ToneAudioBuffer.getDefaults(), arguments, [\"url\", \"onload\", \"onerror\"]);\n    _this.reverse = options.reverse;\n    _this.onload = options.onload;\n\n    if (options.url && isAudioBuffer(options.url) || options.url instanceof ToneAudioBuffer) {\n      _this.set(options.url);\n    } else if (isString(options.url)) {\n      // initiate the download\n      _this.load(options.url).catch(options.onerror);\n    }\n\n    return _this;\n  }\n\n  _createClass(ToneAudioBuffer, [{\n    key: \"sampleRate\",\n    get:\n    /**\n     * The sample rate of the AudioBuffer\n     */\n    function get() {\n      if (this._buffer) {\n        return this._buffer.sampleRate;\n      } else {\n        return getContext().sampleRate;\n      }\n    }\n    /**\n     * Pass in an AudioBuffer or ToneAudioBuffer to set the value of this buffer.\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(buffer) {\n      var _this2 = this;\n\n      if (buffer instanceof ToneAudioBuffer) {\n        // if it's loaded, set it\n        if (buffer.loaded) {\n          this._buffer = buffer.get();\n        } else {\n          // otherwise when it's loaded, invoke it's callback\n          buffer.onload = function () {\n            _this2.set(buffer);\n\n            _this2.onload(_this2);\n          };\n        }\n      } else {\n        this._buffer = buffer;\n      } // reverse it initially\n\n\n      if (this._reversed) {\n        this._reverse();\n      }\n\n      return this;\n    }\n    /**\n     * The audio buffer stored in the object.\n     */\n\n  }, {\n    key: \"get\",\n    value: function get() {\n      return this._buffer;\n    }\n    /**\n     * Makes an fetch request for the selected url then decodes the file as an audio buffer.\n     * Invokes the callback once the audio buffer loads.\n     * @param url The url of the buffer to load. filetype support depends on the browser.\n     * @returns A Promise which resolves with this ToneAudioBuffer\n     */\n\n  }, {\n    key: \"load\",\n    value: function load(url) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _this3 = this;\n\n        var doneLoading, index;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                doneLoading = ToneAudioBuffer.load(url).then(function (audioBuffer) {\n                  _this3.set(audioBuffer); // invoke the onload method\n\n\n                  _this3.onload(_this3);\n                });\n                ToneAudioBuffer.downloads.push(doneLoading);\n                _context.prev = 2;\n                _context.next = 5;\n                return doneLoading;\n\n              case 5:\n                _context.prev = 5;\n                // remove the downloaded file\n                index = ToneAudioBuffer.downloads.indexOf(doneLoading);\n                ToneAudioBuffer.downloads.splice(index, 1);\n                return _context.finish(5);\n\n              case 9:\n                return _context.abrupt(\"return\", this);\n\n              case 10:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[2,, 5, 9]]);\n      }));\n    }\n    /**\n     * clean up\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(ToneAudioBuffer.prototype), \"dispose\", this).call(this);\n\n      this._buffer = undefined;\n      return this;\n    }\n    /**\n     * Set the audio buffer from the array.\n     * To create a multichannel AudioBuffer, pass in a multidimensional array.\n     * @param array The array to fill the audio buffer\n     */\n\n  }, {\n    key: \"fromArray\",\n    value: function fromArray(array) {\n      var isMultidimensional = isArray(array) && array[0].length > 0;\n      var channels = isMultidimensional ? array.length : 1;\n      var len = isMultidimensional ? array[0].length : array.length;\n      var context = getContext();\n      var buffer = context.createBuffer(channels, len, context.sampleRate);\n      var multiChannelArray = !isMultidimensional && channels === 1 ? [array] : array;\n\n      for (var c = 0; c < channels; c++) {\n        buffer.copyToChannel(multiChannelArray[c], c);\n      }\n\n      this._buffer = buffer;\n      return this;\n    }\n    /**\n     * Sums multiple channels into 1 channel\n     * @param chanNum Optionally only copy a single channel from the array.\n     */\n\n  }, {\n    key: \"toMono\",\n    value: function toMono(chanNum) {\n      if (isNumber(chanNum)) {\n        this.fromArray(this.toArray(chanNum));\n      } else {\n        var outputArray = new Float32Array(this.length);\n        var numChannels = this.numberOfChannels;\n\n        for (var channel = 0; channel < numChannels; channel++) {\n          var channelArray = this.toArray(channel);\n\n          for (var i = 0; i < channelArray.length; i++) {\n            outputArray[i] += channelArray[i];\n          }\n        } // divide by the number of channels\n\n\n        outputArray = outputArray.map(function (sample) {\n          return sample / numChannels;\n        });\n        this.fromArray(outputArray);\n      }\n\n      return this;\n    }\n    /**\n     * Get the buffer as an array. Single channel buffers will return a 1-dimensional\n     * Float32Array, and multichannel buffers will return multidimensional arrays.\n     * @param channel Optionally only copy a single channel from the array.\n     */\n\n  }, {\n    key: \"toArray\",\n    value: function toArray(channel) {\n      if (isNumber(channel)) {\n        return this.getChannelData(channel);\n      } else if (this.numberOfChannels === 1) {\n        return this.toArray(0);\n      } else {\n        var ret = [];\n\n        for (var c = 0; c < this.numberOfChannels; c++) {\n          ret[c] = this.getChannelData(c);\n        }\n\n        return ret;\n      }\n    }\n    /**\n     * Returns the Float32Array representing the PCM audio data for the specific channel.\n     * @param  channel  The channel number to return\n     * @return The audio as a TypedArray\n     */\n\n  }, {\n    key: \"getChannelData\",\n    value: function getChannelData(channel) {\n      if (this._buffer) {\n        return this._buffer.getChannelData(channel);\n      } else {\n        return new Float32Array(0);\n      }\n    }\n    /**\n     * Cut a subsection of the array and return a buffer of the\n     * subsection. Does not modify the original buffer\n     * @param start The time to start the slice\n     * @param end The end time to slice. If none is given will default to the end of the buffer\n     */\n\n  }, {\n    key: \"slice\",\n    value: function slice(start) {\n      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.duration;\n      var startSamples = Math.floor(start * this.sampleRate);\n      var endSamples = Math.floor(end * this.sampleRate);\n      assert(startSamples < endSamples, \"The start time must be less than the end time\");\n      var length = endSamples - startSamples;\n      var retBuffer = getContext().createBuffer(this.numberOfChannels, length, this.sampleRate);\n\n      for (var channel = 0; channel < this.numberOfChannels; channel++) {\n        retBuffer.copyToChannel(this.getChannelData(channel).subarray(startSamples, endSamples), channel);\n      }\n\n      return new ToneAudioBuffer(retBuffer);\n    }\n    /**\n     * Reverse the buffer.\n     */\n\n  }, {\n    key: \"_reverse\",\n    value: function _reverse() {\n      if (this.loaded) {\n        for (var i = 0; i < this.numberOfChannels; i++) {\n          this.getChannelData(i).reverse();\n        }\n      }\n\n      return this;\n    }\n    /**\n     * If the buffer is loaded or not\n     */\n\n  }, {\n    key: \"loaded\",\n    get: function get() {\n      return this.length > 0;\n    }\n    /**\n     * The duration of the buffer in seconds.\n     */\n\n  }, {\n    key: \"duration\",\n    get: function get() {\n      if (this._buffer) {\n        return this._buffer.duration;\n      } else {\n        return 0;\n      }\n    }\n    /**\n     * The length of the buffer in samples\n     */\n\n  }, {\n    key: \"length\",\n    get: function get() {\n      if (this._buffer) {\n        return this._buffer.length;\n      } else {\n        return 0;\n      }\n    }\n    /**\n     * The number of discrete audio channels. Returns 0 if no buffer is loaded.\n     */\n\n  }, {\n    key: \"numberOfChannels\",\n    get: function get() {\n      if (this._buffer) {\n        return this._buffer.numberOfChannels;\n      } else {\n        return 0;\n      }\n    }\n    /**\n     * Reverse the buffer.\n     */\n\n  }, {\n    key: \"reverse\",\n    get: function get() {\n      return this._reversed;\n    },\n    set: function set(rev) {\n      if (this._reversed !== rev) {\n        this._reversed = rev;\n\n        this._reverse();\n      }\n    }\n    /**\n     * Create a ToneAudioBuffer from the array. To create a multichannel AudioBuffer,\n     * pass in a multidimensional array.\n     * @param array The array to fill the audio buffer\n     * @return A ToneAudioBuffer created from the array\n     */\n\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return {\n        onerror: noOp,\n        onload: noOp,\n        reverse: false\n      };\n    }\n  }, {\n    key: \"fromArray\",\n    value: function fromArray(array) {\n      return new ToneAudioBuffer().fromArray(array);\n    }\n    /**\n     * Creates a ToneAudioBuffer from a URL, returns a promise which resolves to a ToneAudioBuffer\n     * @param  url The url to load.\n     * @return A promise which resolves to a ToneAudioBuffer\n     */\n\n  }, {\n    key: \"fromUrl\",\n    value: function fromUrl(url) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var buffer;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                buffer = new ToneAudioBuffer();\n                _context2.next = 3;\n                return buffer.load(url);\n\n              case 3:\n                return _context2.abrupt(\"return\", _context2.sent);\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n    }\n    /**\n     * Loads a url using fetch and returns the AudioBuffer.\n     */\n\n  }, {\n    key: \"load\",\n    value: function load(url) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var matches, extensions, extension, _iterator, _step, ext, baseUrl, response, arrayBuffer, audioBuffer;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                // test if the url contains multiple extensions\n                matches = url.match(/\\[([^\\]\\[]+\\|.+)\\]$/);\n\n                if (!matches) {\n                  _context3.next = 23;\n                  break;\n                }\n\n                extensions = matches[1].split(\"|\");\n                extension = extensions[0];\n                _iterator = _createForOfIteratorHelper(extensions);\n                _context3.prev = 5;\n\n                _iterator.s();\n\n              case 7:\n                if ((_step = _iterator.n()).done) {\n                  _context3.next = 14;\n                  break;\n                }\n\n                ext = _step.value;\n\n                if (!ToneAudioBuffer.supportsType(ext)) {\n                  _context3.next = 12;\n                  break;\n                }\n\n                extension = ext;\n                return _context3.abrupt(\"break\", 14);\n\n              case 12:\n                _context3.next = 7;\n                break;\n\n              case 14:\n                _context3.next = 19;\n                break;\n\n              case 16:\n                _context3.prev = 16;\n                _context3.t0 = _context3[\"catch\"](5);\n\n                _iterator.e(_context3.t0);\n\n              case 19:\n                _context3.prev = 19;\n\n                _iterator.f();\n\n                return _context3.finish(19);\n\n              case 22:\n                url = url.replace(matches[0], extension);\n\n              case 23:\n                // make sure there is a slash between the baseUrl and the url\n                baseUrl = ToneAudioBuffer.baseUrl === \"\" || ToneAudioBuffer.baseUrl.endsWith(\"/\") ? ToneAudioBuffer.baseUrl : ToneAudioBuffer.baseUrl + \"/\";\n                _context3.next = 26;\n                return fetch(baseUrl + url);\n\n              case 26:\n                response = _context3.sent;\n\n                if (response.ok) {\n                  _context3.next = 29;\n                  break;\n                }\n\n                throw new Error(\"could not load url: \".concat(url));\n\n              case 29:\n                _context3.next = 31;\n                return response.arrayBuffer();\n\n              case 31:\n                arrayBuffer = _context3.sent;\n                _context3.next = 34;\n                return getContext().decodeAudioData(arrayBuffer);\n\n              case 34:\n                audioBuffer = _context3.sent;\n                return _context3.abrupt(\"return\", audioBuffer);\n\n              case 36:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, null, [[5, 16, 19, 22]]);\n      }));\n    }\n    /**\n     * Checks a url's extension to see if the current browser can play that file type.\n     * @param url The url/extension to test\n     * @return If the file extension can be played\n     * @static\n     * @example\n     * Tone.ToneAudioBuffer.supportsType(\"wav\"); // returns true\n     * Tone.ToneAudioBuffer.supportsType(\"path/to/file.wav\"); // returns true\n     */\n\n  }, {\n    key: \"supportsType\",\n    value: function supportsType(url) {\n      var extensions = url.split(\".\");\n      var extension = extensions[extensions.length - 1];\n      var response = document.createElement(\"audio\").canPlayType(\"audio/\" + extension);\n      return response !== \"\";\n    }\n    /**\n     * Returns a Promise which resolves when all of the buffers have loaded\n     */\n\n  }, {\n    key: \"loaded\",\n    value: function loaded() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return Promise.resolve();\n\n              case 2:\n                if (!ToneAudioBuffer.downloads.length) {\n                  _context4.next = 7;\n                  break;\n                }\n\n                _context4.next = 5;\n                return ToneAudioBuffer.downloads[0];\n\n              case 5:\n                _context4.next = 2;\n                break;\n\n              case 7:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n    }\n  }]);\n\n  return ToneAudioBuffer;\n}(Tone); //-------------------------------------\n// STATIC METHODS\n//-------------------------------------\n\n/**\n * A path which is prefixed before every url.\n */\n\nToneAudioBuffer.baseUrl = \"\";\n/**\n * All of the downloads\n */\n\nToneAudioBuffer.downloads = [];","map":{"version":3,"mappings":"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","names":["getContext","Tone","isAudioBuffer","optionsFromArguments","noOp","isArray","isNumber","isString","assert","ToneAudioBuffer","options","getDefaults","arguments","reverse","onload","url","set","load","catch","onerror","_buffer","sampleRate","buffer","loaded","get","_reversed","_reverse","doneLoading","then","audioBuffer","downloads","push","index","indexOf","splice","undefined","array","isMultidimensional","length","channels","len","context","createBuffer","multiChannelArray","c","copyToChannel","chanNum","fromArray","toArray","outputArray","Float32Array","numChannels","numberOfChannels","channel","channelArray","i","map","sample","getChannelData","ret","start","end","duration","startSamples","Math","floor","endSamples","retBuffer","subarray","rev","matches","match","extensions","split","extension","ext","supportsType","replace","baseUrl","endsWith","fetch","response","ok","Error","arrayBuffer","decodeAudioData","document","createElement","canPlayType","Promise","resolve"],"sourceRoot":"","sources":["../../../../Tone/core/context/ToneAudioBuffer.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}