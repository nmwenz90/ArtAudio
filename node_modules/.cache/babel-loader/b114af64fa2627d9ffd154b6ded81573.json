{"ast":null,"code":"import _classCallCheck from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _regeneratorRuntime from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator/index.js\";\nimport { __awaiter, __decorate } from \"tslib\";\nimport { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { isArray, isObject, isString } from \"../../core/util/TypeCheck\";\nimport { connectSignal, Signal } from \"../../signal/Signal\";\nimport { OfflineContext } from \"../../core/context/OfflineContext\";\nimport { assert } from \"../../core/util/Debug\";\nimport { range, timeRange } from \"../../core/util/Decorator\";\n/**\n * Envelope is an [ADSR](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope)\n * envelope generator. Envelope outputs a signal which\n * can be connected to an AudioParam or Tone.Signal.\n * ```\n *           /\\\n *          /  \\\n *         /    \\\n *        /      \\\n *       /        \\___________\n *      /                     \\\n *     /                       \\\n *    /                         \\\n *   /                           \\\n * ```\n * @example\n * return Tone.Offline(() => {\n * \tconst env = new Tone.Envelope({\n * \t\tattack: 0.1,\n * \t\tdecay: 0.2,\n * \t\tsustain: 0.5,\n * \t\trelease: 0.8,\n * \t}).toDestination();\n * \tenv.triggerAttackRelease(0.5);\n * }, 1.5, 1);\n * @category Component\n */\n\nexport var Envelope = /*#__PURE__*/function (_ToneAudioNode) {\n  _inherits(Envelope, _ToneAudioNode);\n\n  var _super = _createSuper(Envelope);\n\n  function Envelope() {\n    var _this;\n\n    _classCallCheck(this, Envelope);\n\n    _this = _super.call(this, optionsFromArguments(Envelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]));\n    _this.name = \"Envelope\";\n    /**\n     * the signal which is output.\n     */\n\n    _this._sig = new Signal({\n      context: _this.context,\n      value: 0\n    });\n    /**\n     * The output signal of the envelope\n     */\n\n    _this.output = _this._sig;\n    /**\n     * Envelope has no input\n     */\n\n    _this.input = undefined;\n    var options = optionsFromArguments(Envelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]);\n    _this.attack = options.attack;\n    _this.decay = options.decay;\n    _this.sustain = options.sustain;\n    _this.release = options.release;\n    _this.attackCurve = options.attackCurve;\n    _this.releaseCurve = options.releaseCurve;\n    _this.decayCurve = options.decayCurve;\n    return _this;\n  }\n\n  _createClass(Envelope, [{\n    key: \"value\",\n    get:\n    /**\n     * Read the current value of the envelope. Useful for\n     * synchronizing visual output to the envelope.\n     */\n    function get() {\n      return this.getValueAtTime(this.now());\n    }\n    /**\n     * Get the curve\n     * @param  curve\n     * @param  direction  In/Out\n     * @return The curve name\n     */\n\n  }, {\n    key: \"_getCurve\",\n    value: function _getCurve(curve, direction) {\n      if (isString(curve)) {\n        return curve;\n      } else {\n        // look up the name in the curves array\n        var curveName;\n\n        for (curveName in EnvelopeCurves) {\n          if (EnvelopeCurves[curveName][direction] === curve) {\n            return curveName;\n          }\n        } // return the custom curve\n\n\n        return curve;\n      }\n    }\n    /**\n     * Assign a the curve to the given name using the direction\n     * @param  name\n     * @param  direction In/Out\n     * @param  curve\n     */\n\n  }, {\n    key: \"_setCurve\",\n    value: function _setCurve(name, direction, curve) {\n      // check if it's a valid type\n      if (isString(curve) && Reflect.has(EnvelopeCurves, curve)) {\n        var curveDef = EnvelopeCurves[curve];\n\n        if (isObject(curveDef)) {\n          if (name !== \"_decayCurve\") {\n            this[name] = curveDef[direction];\n          }\n        } else {\n          this[name] = curveDef;\n        }\n      } else if (isArray(curve) && name !== \"_decayCurve\") {\n        this[name] = curve;\n      } else {\n        throw new Error(\"Envelope: invalid curve: \" + curve);\n      }\n    }\n    /**\n     * The shape of the attack.\n     * Can be any of these strings:\n     * * \"linear\"\n     * * \"exponential\"\n     * * \"sine\"\n     * * \"cosine\"\n     * * \"bounce\"\n     * * \"ripple\"\n     * * \"step\"\n     *\n     * Can also be an array which describes the curve. Values\n     * in the array are evenly subdivided and linearly\n     * interpolated over the duration of the attack.\n     * @example\n     * return Tone.Offline(() => {\n     * \tconst env = new Tone.Envelope(0.4).toDestination();\n     * \tenv.attackCurve = \"linear\";\n     * \tenv.triggerAttack();\n     * }, 1, 1);\n     */\n\n  }, {\n    key: \"attackCurve\",\n    get: function get() {\n      return this._getCurve(this._attackCurve, \"In\");\n    },\n    set: function set(curve) {\n      this._setCurve(\"_attackCurve\", \"In\", curve);\n    }\n    /**\n     * The shape of the release. See the attack curve types.\n     * @example\n     * return Tone.Offline(() => {\n     * \tconst env = new Tone.Envelope({\n     * \t\trelease: 0.8\n     * \t}).toDestination();\n     * \tenv.triggerAttack();\n     * \t// release curve could also be defined by an array\n     * \tenv.releaseCurve = [1, 0.3, 0.4, 0.2, 0.7, 0];\n     * \tenv.triggerRelease(0.2);\n     * }, 1, 1);\n     */\n\n  }, {\n    key: \"releaseCurve\",\n    get: function get() {\n      return this._getCurve(this._releaseCurve, \"Out\");\n    },\n    set: function set(curve) {\n      this._setCurve(\"_releaseCurve\", \"Out\", curve);\n    }\n    /**\n     * The shape of the decay either \"linear\" or \"exponential\"\n     * @example\n     * return Tone.Offline(() => {\n     * \tconst env = new Tone.Envelope({\n     * \t\tsustain: 0.1,\n     * \t\tdecay: 0.5\n     * \t}).toDestination();\n     * \tenv.decayCurve = \"linear\";\n     * \tenv.triggerAttack();\n     * }, 1, 1);\n     */\n\n  }, {\n    key: \"decayCurve\",\n    get: function get() {\n      return this._decayCurve;\n    },\n    set: function set(curve) {\n      assert([\"linear\", \"exponential\"].some(function (c) {\n        return c === curve;\n      }), \"Invalid envelope curve: \".concat(curve));\n      this._decayCurve = curve;\n    }\n    /**\n     * Trigger the attack/decay portion of the ADSR envelope.\n     * @param  time When the attack should start.\n     * @param velocity The velocity of the envelope scales the vales.\n     *                             number between 0-1\n     * @example\n     * const env = new Tone.AmplitudeEnvelope().toDestination();\n     * const osc = new Tone.Oscillator().connect(env).start();\n     * // trigger the attack 0.5 seconds from now with a velocity of 0.2\n     * env.triggerAttack(\"+0.5\", 0.2);\n     */\n\n  }, {\n    key: \"triggerAttack\",\n    value: function triggerAttack(time) {\n      var velocity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      this.log(\"triggerAttack\", time, velocity);\n      time = this.toSeconds(time);\n      var originalAttack = this.toSeconds(this.attack);\n      var attack = originalAttack;\n      var decay = this.toSeconds(this.decay); // check if it's not a complete attack\n\n      var currentValue = this.getValueAtTime(time);\n\n      if (currentValue > 0) {\n        // subtract the current value from the attack time\n        var attackRate = 1 / attack;\n        var remainingDistance = 1 - currentValue; // the attack is now the remaining time\n\n        attack = remainingDistance / attackRate;\n      } // attack\n\n\n      if (attack < this.sampleTime) {\n        this._sig.cancelScheduledValues(time); // case where the attack time is 0 should set instantly\n\n\n        this._sig.setValueAtTime(velocity, time);\n      } else if (this._attackCurve === \"linear\") {\n        this._sig.linearRampTo(velocity, attack, time);\n      } else if (this._attackCurve === \"exponential\") {\n        this._sig.targetRampTo(velocity, attack, time);\n      } else {\n        this._sig.cancelAndHoldAtTime(time);\n\n        var curve = this._attackCurve; // find the starting position in the curve\n\n        for (var i = 1; i < curve.length; i++) {\n          // the starting index is between the two values\n          if (curve[i - 1] <= currentValue && currentValue <= curve[i]) {\n            curve = this._attackCurve.slice(i); // the first index is the current value\n\n            curve[0] = currentValue;\n            break;\n          }\n        }\n\n        this._sig.setValueCurveAtTime(curve, time, attack, velocity);\n      } // decay\n\n\n      if (decay && this.sustain < 1) {\n        var decayValue = velocity * this.sustain;\n        var decayStart = time + attack;\n        this.log(\"decay\", decayStart);\n\n        if (this._decayCurve === \"linear\") {\n          this._sig.linearRampToValueAtTime(decayValue, decay + decayStart);\n        } else {\n          this._sig.exponentialApproachValueAtTime(decayValue, decayStart, decay);\n        }\n      }\n\n      return this;\n    }\n    /**\n     * Triggers the release of the envelope.\n     * @param  time When the release portion of the envelope should start.\n     * @example\n     * const env = new Tone.AmplitudeEnvelope().toDestination();\n     * const osc = new Tone.Oscillator({\n     * \ttype: \"sawtooth\"\n     * }).connect(env).start();\n     * env.triggerAttack();\n     * // trigger the release half a second after the attack\n     * env.triggerRelease(\"+0.5\");\n     */\n\n  }, {\n    key: \"triggerRelease\",\n    value: function triggerRelease(time) {\n      this.log(\"triggerRelease\", time);\n      time = this.toSeconds(time);\n      var currentValue = this.getValueAtTime(time);\n\n      if (currentValue > 0) {\n        var release = this.toSeconds(this.release);\n\n        if (release < this.sampleTime) {\n          this._sig.setValueAtTime(0, time);\n        } else if (this._releaseCurve === \"linear\") {\n          this._sig.linearRampTo(0, release, time);\n        } else if (this._releaseCurve === \"exponential\") {\n          this._sig.targetRampTo(0, release, time);\n        } else {\n          assert(isArray(this._releaseCurve), \"releaseCurve must be either 'linear', 'exponential' or an array\");\n\n          this._sig.cancelAndHoldAtTime(time);\n\n          this._sig.setValueCurveAtTime(this._releaseCurve, time, release, currentValue);\n        }\n      }\n\n      return this;\n    }\n    /**\n     * Get the scheduled value at the given time. This will\n     * return the unconverted (raw) value.\n     * @example\n     * const env = new Tone.Envelope(0.5, 1, 0.4, 2);\n     * env.triggerAttackRelease(2);\n     * setInterval(() => console.log(env.getValueAtTime(Tone.now())), 100);\n     */\n\n  }, {\n    key: \"getValueAtTime\",\n    value: function getValueAtTime(time) {\n      return this._sig.getValueAtTime(time);\n    }\n    /**\n     * triggerAttackRelease is shorthand for triggerAttack, then waiting\n     * some duration, then triggerRelease.\n     * @param duration The duration of the sustain.\n     * @param time When the attack should be triggered.\n     * @param velocity The velocity of the envelope.\n     * @example\n     * const env = new Tone.AmplitudeEnvelope().toDestination();\n     * const osc = new Tone.Oscillator().connect(env).start();\n     * // trigger the release 0.5 seconds after the attack\n     * env.triggerAttackRelease(0.5);\n     */\n\n  }, {\n    key: \"triggerAttackRelease\",\n    value: function triggerAttackRelease(duration, time) {\n      var velocity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      time = this.toSeconds(time);\n      this.triggerAttack(time, velocity);\n      this.triggerRelease(time + this.toSeconds(duration));\n      return this;\n    }\n    /**\n     * Cancels all scheduled envelope changes after the given time.\n     */\n\n  }, {\n    key: \"cancel\",\n    value: function cancel(after) {\n      this._sig.cancelScheduledValues(this.toSeconds(after));\n\n      return this;\n    }\n    /**\n     * Connect the envelope to a destination node.\n     */\n\n  }, {\n    key: \"connect\",\n    value: function connect(destination) {\n      var outputNumber = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var inputNumber = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      connectSignal(this, destination, outputNumber, inputNumber);\n      return this;\n    }\n    /**\n     * Render the envelope curve to an array of the given length.\n     * Good for visualizing the envelope curve. Rescales the duration of the\n     * envelope to fit the length.\n     */\n\n  }, {\n    key: \"asArray\",\n    value: function asArray() {\n      var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1024;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var duration, context, attackPortion, envelopeDuration, sustainTime, totalDuration, clone, buffer;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                duration = length / this.context.sampleRate;\n                context = new OfflineContext(1, duration, this.context.sampleRate); // normalize the ADSR for the given duration with 20% sustain time\n\n                attackPortion = this.toSeconds(this.attack) + this.toSeconds(this.decay);\n                envelopeDuration = attackPortion + this.toSeconds(this.release);\n                sustainTime = envelopeDuration * 0.1;\n                totalDuration = envelopeDuration + sustainTime; // @ts-ignore\n\n                clone = new this.constructor(Object.assign(this.get(), {\n                  attack: duration * this.toSeconds(this.attack) / totalDuration,\n                  decay: duration * this.toSeconds(this.decay) / totalDuration,\n                  release: duration * this.toSeconds(this.release) / totalDuration,\n                  context: context\n                }));\n\n                clone._sig.toDestination();\n\n                clone.triggerAttackRelease(duration * (attackPortion + sustainTime) / totalDuration, 0);\n                _context.next = 11;\n                return context.render();\n\n              case 11:\n                buffer = _context.sent;\n                return _context.abrupt(\"return\", buffer.getChannelData(0));\n\n              case 13:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(Envelope.prototype), \"dispose\", this).call(this);\n\n      this._sig.dispose();\n\n      return this;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(ToneAudioNode.getDefaults(), {\n        attack: 0.01,\n        attackCurve: \"linear\",\n        decay: 0.1,\n        decayCurve: \"exponential\",\n        release: 1,\n        releaseCurve: \"exponential\",\n        sustain: 0.5\n      });\n    }\n  }]);\n\n  return Envelope;\n}(ToneAudioNode);\n\n__decorate([timeRange(0)], Envelope.prototype, \"attack\", void 0);\n\n__decorate([timeRange(0)], Envelope.prototype, \"decay\", void 0);\n\n__decorate([range(0, 1)], Envelope.prototype, \"sustain\", void 0);\n\n__decorate([timeRange(0)], Envelope.prototype, \"release\", void 0);\n/**\n * Generate some complex envelope curves.\n */\n\n\nvar EnvelopeCurves = function () {\n  var curveLen = 128;\n  var i;\n  var k; // cosine curve\n\n  var cosineCurve = [];\n\n  for (i = 0; i < curveLen; i++) {\n    cosineCurve[i] = Math.sin(i / (curveLen - 1) * (Math.PI / 2));\n  } // ripple curve\n\n\n  var rippleCurve = [];\n  var rippleCurveFreq = 6.4;\n\n  for (i = 0; i < curveLen - 1; i++) {\n    k = i / (curveLen - 1);\n    var sineWave = Math.sin(k * (Math.PI * 2) * rippleCurveFreq - Math.PI / 2) + 1;\n    rippleCurve[i] = sineWave / 10 + k * 0.83;\n  }\n\n  rippleCurve[curveLen - 1] = 1; // stairs curve\n\n  var stairsCurve = [];\n  var steps = 5;\n\n  for (i = 0; i < curveLen; i++) {\n    stairsCurve[i] = Math.ceil(i / (curveLen - 1) * steps) / steps;\n  } // in-out easing curve\n\n\n  var sineCurve = [];\n\n  for (i = 0; i < curveLen; i++) {\n    k = i / (curveLen - 1);\n    sineCurve[i] = 0.5 * (1 - Math.cos(Math.PI * k));\n  } // a bounce curve\n\n\n  var bounceCurve = [];\n\n  for (i = 0; i < curveLen; i++) {\n    k = i / (curveLen - 1);\n    var freq = Math.pow(k, 3) * 4 + 0.2;\n    var val = Math.cos(freq * Math.PI * 2 * k);\n    bounceCurve[i] = Math.abs(val * (1 - k));\n  }\n  /**\n   * Invert a value curve to make it work for the release\n   */\n\n\n  function invertCurve(curve) {\n    var out = new Array(curve.length);\n\n    for (var j = 0; j < curve.length; j++) {\n      out[j] = 1 - curve[j];\n    }\n\n    return out;\n  }\n  /**\n   * reverse the curve\n   */\n\n\n  function reverseCurve(curve) {\n    return curve.slice(0).reverse();\n  }\n  /**\n   * attack and release curve arrays\n   */\n\n\n  return {\n    bounce: {\n      In: invertCurve(bounceCurve),\n      Out: bounceCurve\n    },\n    cosine: {\n      In: cosineCurve,\n      Out: reverseCurve(cosineCurve)\n    },\n    exponential: \"exponential\",\n    linear: \"linear\",\n    ripple: {\n      In: rippleCurve,\n      Out: invertCurve(rippleCurve)\n    },\n    sine: {\n      In: sineCurve,\n      Out: invertCurve(sineCurve)\n    },\n    step: {\n      In: stairsCurve,\n      Out: invertCurve(stairsCurve)\n    }\n  };\n}();","map":{"version":3,"mappings":"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","names":["ToneAudioNode","optionsFromArguments","isArray","isObject","isString","connectSignal","Signal","OfflineContext","assert","range","timeRange","Envelope","getDefaults","arguments","context","value","_sig","undefined","options","attack","decay","sustain","release","attackCurve","releaseCurve","decayCurve","getValueAtTime","now","curve","direction","curveName","EnvelopeCurves","name","Reflect","has","curveDef","Error","_getCurve","_attackCurve","_setCurve","_releaseCurve","_decayCurve","some","c","time","velocity","log","toSeconds","originalAttack","currentValue","attackRate","remainingDistance","sampleTime","cancelScheduledValues","setValueAtTime","linearRampTo","targetRampTo","cancelAndHoldAtTime","i","length","slice","setValueCurveAtTime","decayValue","decayStart","linearRampToValueAtTime","exponentialApproachValueAtTime","duration","triggerAttack","triggerRelease","after","destination","outputNumber","inputNumber","sampleRate","attackPortion","envelopeDuration","sustainTime","totalDuration","clone","constructor","Object","assign","get","toDestination","triggerAttackRelease","render","buffer","getChannelData","dispose","__decorate","curveLen","k","cosineCurve","Math","sin","PI","rippleCurve","rippleCurveFreq","sineWave","stairsCurve","steps","ceil","sineCurve","cos","bounceCurve","freq","pow","val","abs","invertCurve","out","Array","j","reverseCurve","reverse","bounce","In","Out","cosine","exponential","linear","ripple","sine","step"],"sourceRoot":"","sources":["../../../../Tone/component/envelope/Envelope.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}