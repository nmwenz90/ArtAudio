{"ast":null,"code":"import _classCallCheck from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { ToneWithContext } from \"../context/ToneWithContext\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { noOp, readOnly } from \"../util/Interface\";\nimport { StateTimeline } from \"../util/StateTimeline\";\nimport { TickSource } from \"./TickSource\";\nimport { assertContextRunning } from \"../util/Debug\";\n/**\n * A sample accurate clock which provides a callback at the given rate.\n * While the callback is not sample-accurate (it is still susceptible to\n * loose JS timing), the time passed in as the argument to the callback\n * is precise. For most applications, it is better to use Tone.Transport\n * instead of the Clock by itself since you can synchronize multiple callbacks.\n * @example\n * // the callback will be invoked approximately once a second\n * // and will print the time exactly once a second apart.\n * const clock = new Tone.Clock(time => {\n * \tconsole.log(time);\n * }, 1);\n * clock.start();\n * @category Core\n */\n\nexport var Clock = /*#__PURE__*/function (_ToneWithContext) {\n  _inherits(Clock, _ToneWithContext);\n\n  var _super = _createSuper(Clock);\n\n  function Clock() {\n    var _this;\n\n    _classCallCheck(this, Clock);\n\n    _this = _super.call(this, optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]));\n    _this.name = \"Clock\";\n    /**\n     * The callback function to invoke at the scheduled tick.\n     */\n\n    _this.callback = noOp;\n    /**\n     * The last time the loop callback was invoked\n     */\n\n    _this._lastUpdate = 0;\n    /**\n     * Keep track of the playback state\n     */\n\n    _this._state = new StateTimeline(\"stopped\");\n    /**\n     * Context bound reference to the _loop method\n     * This is necessary to remove the event in the end.\n     */\n\n    _this._boundLoop = _this._loop.bind(_assertThisInitialized(_this));\n    var options = optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]);\n    _this.callback = options.callback;\n    _this._tickSource = new TickSource({\n      context: _this.context,\n      frequency: options.frequency,\n      units: options.units\n    });\n    _this._lastUpdate = 0;\n    _this.frequency = _this._tickSource.frequency;\n    readOnly(_assertThisInitialized(_this), \"frequency\"); // add an initial state\n\n    _this._state.setStateAtTime(\"stopped\", 0); // bind a callback to the worker thread\n\n\n    _this.context.on(\"tick\", _this._boundLoop);\n\n    return _this;\n  }\n\n  _createClass(Clock, [{\n    key: \"state\",\n    get:\n    /**\n     * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n     */\n    function get() {\n      return this._state.getValueAtTime(this.now());\n    }\n    /**\n     * Start the clock at the given time. Optionally pass in an offset\n     * of where to start the tick counter from.\n     * @param  time    The time the clock should start\n     * @param offset  Where the tick counter starts counting from.\n     */\n\n  }, {\n    key: \"start\",\n    value: function start(time, offset) {\n      // make sure the context is running\n      assertContextRunning(this.context); // start the loop\n\n      var computedTime = this.toSeconds(time);\n      this.log(\"start\", computedTime);\n\n      if (this._state.getValueAtTime(computedTime) !== \"started\") {\n        this._state.setStateAtTime(\"started\", computedTime);\n\n        this._tickSource.start(computedTime, offset);\n\n        if (computedTime < this._lastUpdate) {\n          this.emit(\"start\", computedTime, offset);\n        }\n      }\n\n      return this;\n    }\n    /**\n     * Stop the clock. Stopping the clock resets the tick counter to 0.\n     * @param time The time when the clock should stop.\n     * @example\n     * const clock = new Tone.Clock(time => {\n     * \tconsole.log(time);\n     * }, 1);\n     * clock.start();\n     * // stop the clock after 10 seconds\n     * clock.stop(\"+10\");\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop(time) {\n      var computedTime = this.toSeconds(time);\n      this.log(\"stop\", computedTime);\n\n      this._state.cancel(computedTime);\n\n      this._state.setStateAtTime(\"stopped\", computedTime);\n\n      this._tickSource.stop(computedTime);\n\n      if (computedTime < this._lastUpdate) {\n        this.emit(\"stop\", computedTime);\n      }\n\n      return this;\n    }\n    /**\n     * Pause the clock. Pausing does not reset the tick counter.\n     * @param time The time when the clock should stop.\n     */\n\n  }, {\n    key: \"pause\",\n    value: function pause(time) {\n      var computedTime = this.toSeconds(time);\n\n      if (this._state.getValueAtTime(computedTime) === \"started\") {\n        this._state.setStateAtTime(\"paused\", computedTime);\n\n        this._tickSource.pause(computedTime);\n\n        if (computedTime < this._lastUpdate) {\n          this.emit(\"pause\", computedTime);\n        }\n      }\n\n      return this;\n    }\n    /**\n     * The number of times the callback was invoked. Starts counting at 0\n     * and increments after the callback was invoked.\n     */\n\n  }, {\n    key: \"ticks\",\n    get: function get() {\n      return Math.ceil(this.getTicksAtTime(this.now()));\n    },\n    set: function set(t) {\n      this._tickSource.ticks = t;\n    }\n    /**\n     * The time since ticks=0 that the Clock has been running. Accounts for tempo curves\n     */\n\n  }, {\n    key: \"seconds\",\n    get: function get() {\n      return this._tickSource.seconds;\n    },\n    set: function set(s) {\n      this._tickSource.seconds = s;\n    }\n    /**\n     * Return the elapsed seconds at the given time.\n     * @param  time  When to get the elapsed seconds\n     * @return  The number of elapsed seconds\n     */\n\n  }, {\n    key: \"getSecondsAtTime\",\n    value: function getSecondsAtTime(time) {\n      return this._tickSource.getSecondsAtTime(time);\n    }\n    /**\n     * Set the clock's ticks at the given time.\n     * @param  ticks The tick value to set\n     * @param  time  When to set the tick value\n     */\n\n  }, {\n    key: \"setTicksAtTime\",\n    value: function setTicksAtTime(ticks, time) {\n      this._tickSource.setTicksAtTime(ticks, time);\n\n      return this;\n    }\n    /**\n     * Get the time of the given tick. The second argument\n     * is when to test before. Since ticks can be set (with setTicksAtTime)\n     * there may be multiple times for a given tick value.\n     * @param  tick The tick number.\n     * @param  before When to measure the tick value from.\n     * @return The time of the tick\n     */\n\n  }, {\n    key: \"getTimeOfTick\",\n    value: function getTimeOfTick(tick) {\n      var before = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.now();\n      return this._tickSource.getTimeOfTick(tick, before);\n    }\n    /**\n     * Get the clock's ticks at the given time.\n     * @param  time  When to get the tick value\n     * @return The tick value at the given time.\n     */\n\n  }, {\n    key: \"getTicksAtTime\",\n    value: function getTicksAtTime(time) {\n      return this._tickSource.getTicksAtTime(time);\n    }\n    /**\n     * Get the time of the next tick\n     * @param  offset The tick number.\n     */\n\n  }, {\n    key: \"nextTickTime\",\n    value: function nextTickTime(offset, when) {\n      var computedTime = this.toSeconds(when);\n      var currentTick = this.getTicksAtTime(computedTime);\n      return this._tickSource.getTimeOfTick(currentTick + offset, computedTime);\n    }\n    /**\n     * The scheduling loop.\n     */\n\n  }, {\n    key: \"_loop\",\n    value: function _loop() {\n      var _this2 = this;\n\n      var startTime = this._lastUpdate;\n      var endTime = this.now();\n      this._lastUpdate = endTime;\n      this.log(\"loop\", startTime, endTime);\n\n      if (startTime !== endTime) {\n        // the state change events\n        this._state.forEachBetween(startTime, endTime, function (e) {\n          switch (e.state) {\n            case \"started\":\n              var offset = _this2._tickSource.getTicksAtTime(e.time);\n\n              _this2.emit(\"start\", e.time, offset);\n\n              break;\n\n            case \"stopped\":\n              if (e.time !== 0) {\n                _this2.emit(\"stop\", e.time);\n              }\n\n              break;\n\n            case \"paused\":\n              _this2.emit(\"pause\", e.time);\n\n              break;\n          }\n        }); // the tick callbacks\n\n\n        this._tickSource.forEachTickBetween(startTime, endTime, function (time, ticks) {\n          _this2.callback(time, ticks);\n        });\n      }\n    }\n    /**\n     * Returns the scheduled state at the given time.\n     * @param  time  The time to query.\n     * @return  The name of the state input in setStateAtTime.\n     * @example\n     * const clock = new Tone.Clock();\n     * clock.start(\"+0.1\");\n     * clock.getStateAtTime(\"+0.1\"); // returns \"started\"\n     */\n\n  }, {\n    key: \"getStateAtTime\",\n    value: function getStateAtTime(time) {\n      var computedTime = this.toSeconds(time);\n      return this._state.getValueAtTime(computedTime);\n    }\n    /**\n     * Clean up\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(Clock.prototype), \"dispose\", this).call(this);\n\n      this.context.off(\"tick\", this._boundLoop);\n\n      this._tickSource.dispose();\n\n      this._state.dispose();\n\n      return this;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(ToneWithContext.getDefaults(), {\n        callback: noOp,\n        frequency: 1,\n        units: \"hertz\"\n      });\n    }\n  }]);\n\n  return Clock;\n}(ToneWithContext);\nEmitter.mixin(Clock);","map":{"version":3,"mappings":"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","names":["ToneWithContext","optionsFromArguments","Emitter","noOp","readOnly","StateTimeline","TickSource","assertContextRunning","Clock","getDefaults","arguments","_loop","bind","options","callback","_tickSource","context","frequency","units","_lastUpdate","_state","setStateAtTime","on","_boundLoop","getValueAtTime","now","time","offset","computedTime","toSeconds","log","start","emit","cancel","stop","pause","Math","ceil","getTicksAtTime","t","ticks","seconds","s","getSecondsAtTime","setTicksAtTime","tick","before","getTimeOfTick","when","currentTick","startTime","endTime","forEachBetween","e","state","forEachTickBetween","off","dispose","Object","assign","mixin"],"sourceRoot":"","sources":["../../../../Tone/core/clock/Clock.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}