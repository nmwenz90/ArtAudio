{"ast":null,"code":"import _classCallCheck from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { isArray, isFunction } from \"../core/util/TypeCheck\";\nimport { assert } from \"../core/util/Debug\";\nimport { Signal } from \"./Signal\";\nimport { SignalOperator } from \"./SignalOperator\";\n/**\n * Wraps the native Web Audio API\n * [WaveShaperNode](http://webaudio.github.io/web-audio-api/#the-waveshapernode-interface).\n *\n * @example\n * const osc = new Tone.Oscillator().toDestination().start();\n * // multiply the output of the signal by 2 using the waveshaper's function\n * const timesTwo = new Tone.WaveShaper((val) => val * 2, 2048).connect(osc.frequency);\n * const signal = new Tone.Signal(440).connect(timesTwo);\n * @category Signal\n */\n\nexport var WaveShaper = /*#__PURE__*/function (_SignalOperator) {\n  _inherits(WaveShaper, _SignalOperator);\n\n  var _super = _createSuper(WaveShaper);\n\n  function WaveShaper() {\n    var _this;\n\n    _classCallCheck(this, WaveShaper);\n\n    _this = _super.call(this, Object.assign(optionsFromArguments(WaveShaper.getDefaults(), arguments, [\"mapping\", \"length\"])));\n    _this.name = \"WaveShaper\";\n    /**\n     * the waveshaper node\n     */\n\n    _this._shaper = _this.context.createWaveShaper();\n    /**\n     * The input to the waveshaper node.\n     */\n\n    _this.input = _this._shaper;\n    /**\n     * The output from the waveshaper node\n     */\n\n    _this.output = _this._shaper;\n    var options = optionsFromArguments(WaveShaper.getDefaults(), arguments, [\"mapping\", \"length\"]);\n\n    if (isArray(options.mapping) || options.mapping instanceof Float32Array) {\n      _this.curve = Float32Array.from(options.mapping);\n    } else if (isFunction(options.mapping)) {\n      _this.setMap(options.mapping, options.length);\n    }\n\n    return _this;\n  }\n\n  _createClass(WaveShaper, [{\n    key: \"setMap\",\n    value:\n    /**\n     * Uses a mapping function to set the value of the curve.\n     * @param mapping The function used to define the values.\n     *                The mapping function take two arguments:\n     *                the first is the value at the current position\n     *                which goes from -1 to 1 over the number of elements\n     *                in the curve array. The second argument is the array position.\n     * @example\n     * const shaper = new Tone.WaveShaper();\n     * // map the input signal from [-1, 1] to [0, 10]\n     * shaper.setMap((val, index) => (val + 1) * 5);\n     */\n    function setMap(mapping) {\n      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1024;\n      var array = new Float32Array(length);\n\n      for (var i = 0, len = length; i < len; i++) {\n        var normalized = i / (len - 1) * 2 - 1;\n        array[i] = mapping(normalized, i);\n      }\n\n      this.curve = array;\n      return this;\n    }\n    /**\n     * The array to set as the waveshaper curve. For linear curves\n     * array length does not make much difference, but for complex curves\n     * longer arrays will provide smoother interpolation.\n     */\n\n  }, {\n    key: \"curve\",\n    get: function get() {\n      return this._shaper.curve;\n    },\n    set: function set(mapping) {\n      this._shaper.curve = mapping;\n    }\n    /**\n     * Specifies what type of oversampling (if any) should be used when\n     * applying the shaping curve. Can either be \"none\", \"2x\" or \"4x\".\n     */\n\n  }, {\n    key: \"oversample\",\n    get: function get() {\n      return this._shaper.oversample;\n    },\n    set: function set(oversampling) {\n      var isOverSampleType = [\"none\", \"2x\", \"4x\"].some(function (str) {\n        return str.includes(oversampling);\n      });\n      assert(isOverSampleType, \"oversampling must be either 'none', '2x', or '4x'\");\n      this._shaper.oversample = oversampling;\n    }\n    /**\n     * Clean up.\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(WaveShaper.prototype), \"dispose\", this).call(this);\n\n      this._shaper.disconnect();\n\n      return this;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(Signal.getDefaults(), {\n        length: 1024\n      });\n    }\n  }]);\n\n  return WaveShaper;\n}(SignalOperator);","map":{"version":3,"mappings":"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","names":["optionsFromArguments","isArray","isFunction","assert","Signal","SignalOperator","WaveShaper","Object","assign","getDefaults","arguments","context","createWaveShaper","_shaper","options","mapping","Float32Array","curve","from","setMap","length","array","i","len","normalized","oversample","oversampling","isOverSampleType","some","str","includes","disconnect"],"sourceRoot":"","sources":["../../../Tone/signal/WaveShaper.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}