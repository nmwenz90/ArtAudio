{"ast":null,"code":"/*!\n * @pixi/graphics - v6.3.0\n * Compiled Wed, 23 Mar 2022 18:58:56 UTC\n *\n * @pixi/graphics is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nimport { Texture, BaseTexture, BatchDrawCall, BatchTextureArray, BatchGeometry, UniformGroup, Shader, State } from '@pixi/core';\nimport { SHAPES, Point, PI_2, Matrix, Polygon, Rectangle, RoundedRectangle, Circle, Ellipse } from '@pixi/math';\nimport { earcut, premultiplyTint, hex2rgb } from '@pixi/utils';\nimport { WRAP_MODES, DRAW_MODES, BLEND_MODES } from '@pixi/constants';\nimport { Bounds, Container } from '@pixi/display';\n/**\n * Supported line joints in `PIXI.LineStyle` for graphics.\n *\n * @see PIXI.Graphics#lineStyle\n * @see https://graphicdesign.stackexchange.com/questions/59018/what-is-a-bevel-join-of-two-lines-exactly-illustrator\n *\n * @name LINE_JOIN\n * @memberof PIXI\n * @static\n * @enum {string}\n * @property {string} MITER - 'miter': make a sharp corner where outer part of lines meet\n * @property {string} BEVEL - 'bevel': add a square butt at each end of line segment and fill the triangle at turn\n * @property {string} ROUND - 'round': add an arc at the joint\n */\n\nvar LINE_JOIN;\n\n(function (LINE_JOIN) {\n  LINE_JOIN[\"MITER\"] = \"miter\";\n  LINE_JOIN[\"BEVEL\"] = \"bevel\";\n  LINE_JOIN[\"ROUND\"] = \"round\";\n})(LINE_JOIN || (LINE_JOIN = {}));\n/**\n * Support line caps in `PIXI.LineStyle` for graphics.\n *\n * @see PIXI.Graphics#lineStyle\n *\n * @name LINE_CAP\n * @memberof PIXI\n * @static\n * @enum {string}\n * @property {string} BUTT - 'butt': don't add any cap at line ends (leaves orthogonal edges)\n * @property {string} ROUND - 'round': add semicircle at ends\n * @property {string} SQUARE - 'square': add square at end (like `BUTT` except more length at end)\n */\n\n\nvar LINE_CAP;\n\n(function (LINE_CAP) {\n  LINE_CAP[\"BUTT\"] = \"butt\";\n  LINE_CAP[\"ROUND\"] = \"round\";\n  LINE_CAP[\"SQUARE\"] = \"square\";\n})(LINE_CAP || (LINE_CAP = {}));\n/**\n * Graphics curves resolution settings. If `adaptive` flag is set to `true`,\n * the resolution is calculated based on the curve's length to ensure better visual quality.\n * Adaptive draw works with `bezierCurveTo` and `quadraticCurveTo`.\n *\n * @static\n * @constant\n * @memberof PIXI\n * @name GRAPHICS_CURVES\n * @type {object}\n * @property {boolean} adaptive=true - flag indicating if the resolution should be adaptive\n * @property {number} maxLength=10 - maximal length of a single segment of the curve (if adaptive = false, ignored)\n * @property {number} minSegments=8 - minimal number of segments in the curve (if adaptive = false, ignored)\n * @property {number} maxSegments=2048 - maximal number of segments in the curve (if adaptive = false, ignored)\n */\n\n\nvar GRAPHICS_CURVES = {\n  adaptive: true,\n  maxLength: 10,\n  minSegments: 8,\n  maxSegments: 2048,\n  epsilon: 0.0001,\n  _segmentsCount: function _segmentsCount(length, defaultSegments) {\n    if (defaultSegments === void 0) {\n      defaultSegments = 20;\n    }\n\n    if (!this.adaptive || !length || isNaN(length)) {\n      return defaultSegments;\n    }\n\n    var result = Math.ceil(length / this.maxLength);\n\n    if (result < this.minSegments) {\n      result = this.minSegments;\n    } else if (result > this.maxSegments) {\n      result = this.maxSegments;\n    }\n\n    return result;\n  }\n};\n/**\n * Fill style object for Graphics.\n *\n * @memberof PIXI\n */\n\nvar FillStyle =\n/** @class */\nfunction () {\n  function FillStyle() {\n    /**\n     * The hex color value used when coloring the Graphics object.\n     *\n     * @default 0xFFFFFF\n     */\n    this.color = 0xFFFFFF;\n    /** The alpha value used when filling the Graphics object. */\n\n    this.alpha = 1.0;\n    /**\n     * The texture to be used for the fill.\n     *\n     * @default 0\n     */\n\n    this.texture = Texture.WHITE;\n    /**\n     * The transform applied to the texture.\n     *\n     * @default null\n     */\n\n    this.matrix = null;\n    /** If the current fill is visible. */\n\n    this.visible = false;\n    this.reset();\n  }\n  /** Clones the object */\n\n\n  FillStyle.prototype.clone = function () {\n    var obj = new FillStyle();\n    obj.color = this.color;\n    obj.alpha = this.alpha;\n    obj.texture = this.texture;\n    obj.matrix = this.matrix;\n    obj.visible = this.visible;\n    return obj;\n  };\n  /** Reset */\n\n\n  FillStyle.prototype.reset = function () {\n    this.color = 0xFFFFFF;\n    this.alpha = 1;\n    this.texture = Texture.WHITE;\n    this.matrix = null;\n    this.visible = false;\n  };\n  /** Destroy and don't use after this. */\n\n\n  FillStyle.prototype.destroy = function () {\n    this.texture = null;\n    this.matrix = null;\n  };\n\n  return FillStyle;\n}();\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\n\n\nvar _extendStatics = function extendStatics(d, b) {\n  _extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) {\n        d[p] = b[p];\n      }\n    }\n  };\n\n  return _extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  _extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nfunction fixOrientation(points, hole) {\n  var _a, _b;\n\n  if (hole === void 0) {\n    hole = false;\n  }\n\n  var m = points.length;\n\n  if (m < 6) {\n    return;\n  }\n\n  var area = 0;\n\n  for (var i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2) {\n    var x2 = points[i];\n    var y2 = points[i + 1];\n    area += (x2 - x1) * (y2 + y1);\n    x1 = x2;\n    y1 = y2;\n  }\n\n  if (!hole && area > 0 || hole && area <= 0) {\n    var n = m / 2;\n\n    for (var i = n + n % 2; i < m; i += 2) {\n      var i1 = m - i - 2;\n      var i2 = m - i - 1;\n      var i3 = i;\n      var i4 = i + 1;\n      _a = [points[i3], points[i1]], points[i1] = _a[0], points[i3] = _a[1];\n      _b = [points[i4], points[i2]], points[i2] = _b[0], points[i4] = _b[1];\n    }\n  }\n}\n/**\n * Builds a polygon to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\n\n\nvar buildPoly = {\n  build: function build(graphicsData) {\n    graphicsData.points = graphicsData.shape.points.slice();\n  },\n  triangulate: function triangulate(graphicsData, graphicsGeometry) {\n    var points = graphicsData.points;\n    var holes = graphicsData.holes;\n    var verts = graphicsGeometry.points;\n    var indices = graphicsGeometry.indices;\n\n    if (points.length >= 6) {\n      fixOrientation(points, false);\n      var holeArray = []; // Process holes..\n\n      for (var i = 0; i < holes.length; i++) {\n        var hole = holes[i];\n        fixOrientation(hole.points, true);\n        holeArray.push(points.length / 2);\n        points = points.concat(hole.points);\n      } // sort color\n\n\n      var triangles = earcut(points, holeArray, 2);\n\n      if (!triangles) {\n        return;\n      }\n\n      var vertPos = verts.length / 2;\n\n      for (var i = 0; i < triangles.length; i += 3) {\n        indices.push(triangles[i] + vertPos);\n        indices.push(triangles[i + 1] + vertPos);\n        indices.push(triangles[i + 2] + vertPos);\n      }\n\n      for (var i = 0; i < points.length; i++) {\n        verts.push(points[i]);\n      }\n    }\n  }\n}; // for type only\n\n/**\n * Builds a circle to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object to draw\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\n\nvar buildCircle = {\n  build: function build(graphicsData) {\n    // need to convert points to a nice regular data\n    var points = graphicsData.points;\n    var x;\n    var y;\n    var dx;\n    var dy;\n    var rx;\n    var ry;\n\n    if (graphicsData.type === SHAPES.CIRC) {\n      var circle = graphicsData.shape;\n      x = circle.x;\n      y = circle.y;\n      rx = ry = circle.radius;\n      dx = dy = 0;\n    } else if (graphicsData.type === SHAPES.ELIP) {\n      var ellipse = graphicsData.shape;\n      x = ellipse.x;\n      y = ellipse.y;\n      rx = ellipse.width;\n      ry = ellipse.height;\n      dx = dy = 0;\n    } else {\n      var roundedRect = graphicsData.shape;\n      var halfWidth = roundedRect.width / 2;\n      var halfHeight = roundedRect.height / 2;\n      x = roundedRect.x + halfWidth;\n      y = roundedRect.y + halfHeight;\n      rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n      dx = halfWidth - rx;\n      dy = halfHeight - ry;\n    } // Choose a number of segments such that the maximum absolute deviation from the circle is approximately 0.029\n\n\n    var n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n    var m = n * 8 + (dx ? 4 : 0) + (dy ? 4 : 0);\n    points.length = m;\n\n    if (m === 0) {\n      return;\n    }\n\n    if (n === 0) {\n      points.length = 8;\n      points[0] = points[6] = x + dx;\n      points[1] = points[3] = y + dy;\n      points[2] = points[4] = x - dx;\n      points[5] = points[7] = y - dy;\n      return;\n    }\n\n    var j1 = 0;\n    var j2 = n * 4 + (dx ? 2 : 0) + 2;\n    var j3 = j2;\n    var j4 = m;\n    {\n      var x0 = dx + rx;\n      var y0 = dy;\n      var x1 = x + x0;\n      var x2 = x - x0;\n      var y1 = y + y0;\n      points[j1++] = x1;\n      points[j1++] = y1;\n      points[--j2] = y1;\n      points[--j2] = x2;\n\n      if (dy) {\n        var y2 = y - y0;\n        points[j3++] = x2;\n        points[j3++] = y2;\n        points[--j4] = y2;\n        points[--j4] = x1;\n      }\n    }\n\n    for (var i = 1; i < n; i++) {\n      var a = Math.PI / 2 * (i / n);\n      var x0 = dx + Math.cos(a) * rx;\n      var y0 = dy + Math.sin(a) * ry;\n      var x1 = x + x0;\n      var x2 = x - x0;\n      var y1 = y + y0;\n      var y2 = y - y0;\n      points[j1++] = x1;\n      points[j1++] = y1;\n      points[--j2] = y1;\n      points[--j2] = x2;\n      points[j3++] = x2;\n      points[j3++] = y2;\n      points[--j4] = y2;\n      points[--j4] = x1;\n    }\n\n    {\n      var x0 = dx;\n      var y0 = dy + ry;\n      var x1 = x + x0;\n      var x2 = x - x0;\n      var y1 = y + y0;\n      var y2 = y - y0;\n      points[j1++] = x1;\n      points[j1++] = y1;\n      points[--j4] = y2;\n      points[--j4] = x1;\n\n      if (dx) {\n        points[j1++] = x2;\n        points[j1++] = y1;\n        points[--j4] = y2;\n        points[--j4] = x2;\n      }\n    }\n  },\n  triangulate: function triangulate(graphicsData, graphicsGeometry) {\n    var points = graphicsData.points;\n    var verts = graphicsGeometry.points;\n    var indices = graphicsGeometry.indices;\n    var vertPos = verts.length / 2;\n    var center = vertPos;\n    var x;\n    var y;\n\n    if (graphicsData.type !== SHAPES.RREC) {\n      var circle = graphicsData.shape;\n      x = circle.x;\n      y = circle.y;\n    } else {\n      var roundedRect = graphicsData.shape;\n      x = roundedRect.x + roundedRect.width / 2;\n      y = roundedRect.y + roundedRect.height / 2;\n    }\n\n    var matrix = graphicsData.matrix; // Push center (special point)\n\n    verts.push(graphicsData.matrix ? matrix.a * x + matrix.c * y + matrix.tx : x, graphicsData.matrix ? matrix.b * x + matrix.d * y + matrix.ty : y);\n    vertPos++;\n    verts.push(points[0], points[1]);\n\n    for (var i = 2; i < points.length; i += 2) {\n      verts.push(points[i], points[i + 1]); // add some uvs\n\n      indices.push(vertPos++, center, vertPos);\n    }\n\n    indices.push(center + 1, center, vertPos);\n  }\n};\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\n\nvar buildRectangle = {\n  build: function build(graphicsData) {\n    // --- //\n    // need to convert points to a nice regular data\n    //\n    var rectData = graphicsData.shape;\n    var x = rectData.x;\n    var y = rectData.y;\n    var width = rectData.width;\n    var height = rectData.height;\n    var points = graphicsData.points;\n    points.length = 0;\n    points.push(x, y, x + width, y, x + width, y + height, x, y + height);\n  },\n  triangulate: function triangulate(graphicsData, graphicsGeometry) {\n    var points = graphicsData.points;\n    var verts = graphicsGeometry.points;\n    var vertPos = verts.length / 2;\n    verts.push(points[0], points[1], points[2], points[3], points[6], points[7], points[4], points[5]);\n    graphicsGeometry.indices.push(vertPos, vertPos + 1, vertPos + 2, vertPos + 1, vertPos + 2, vertPos + 3);\n  }\n};\n/**\n * Calculate a single point for a quadratic bezier curve.\n * Utility function used by quadraticBezierCurve.\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {number} n1 - first number\n * @param {number} n2 - second number\n * @param {number} perc - percentage\n * @return {number} the result\n *\n */\n\nfunction getPt(n1, n2, perc) {\n  var diff = n2 - n1;\n  return n1 + diff * perc;\n}\n/**\n * Calculate the points for a quadratic bezier curve. (helper function..)\n * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {number} fromX - Origin point x\n * @param {number} fromY - Origin point x\n * @param {number} cpX - Control point x\n * @param {number} cpY - Control point y\n * @param {number} toX - Destination point x\n * @param {number} toY - Destination point y\n * @param {number[]} [out=[]] - The output array to add points into. If not passed, a new array is created.\n * @return {number[]} an array of points\n */\n\n\nfunction quadraticBezierCurve(fromX, fromY, cpX, cpY, toX, toY, out) {\n  if (out === void 0) {\n    out = [];\n  }\n\n  var n = 20;\n  var points = out;\n  var xa = 0;\n  var ya = 0;\n  var xb = 0;\n  var yb = 0;\n  var x = 0;\n  var y = 0;\n\n  for (var i = 0, j = 0; i <= n; ++i) {\n    j = i / n; // The Green Line\n\n    xa = getPt(fromX, cpX, j);\n    ya = getPt(fromY, cpY, j);\n    xb = getPt(cpX, toX, j);\n    yb = getPt(cpY, toY, j); // The Black Dot\n\n    x = getPt(xa, xb, j);\n    y = getPt(ya, yb, j); // Handle case when first curve points overlaps and earcut fails to triangulate\n\n    if (i === 0 && points[points.length - 2] === x && points[points.length - 1] === y) {\n      continue;\n    }\n\n    points.push(x, y);\n  }\n\n  return points;\n}\n/**\n * Builds a rounded rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\n\n\nvar buildRoundedRectangle = {\n  build: function build(graphicsData) {\n    if (Graphics.nextRoundedRectBehavior) {\n      buildCircle.build(graphicsData);\n      return;\n    }\n\n    var rrectData = graphicsData.shape;\n    var points = graphicsData.points;\n    var x = rrectData.x;\n    var y = rrectData.y;\n    var width = rrectData.width;\n    var height = rrectData.height; // Don't allow negative radius or greater than half the smallest width\n\n    var radius = Math.max(0, Math.min(rrectData.radius, Math.min(width, height) / 2));\n    points.length = 0; // No radius, do a simple rectangle\n\n    if (!radius) {\n      points.push(x, y, x + width, y, x + width, y + height, x, y + height);\n    } else {\n      quadraticBezierCurve(x, y + radius, x, y, x + radius, y, points);\n      quadraticBezierCurve(x + width - radius, y, x + width, y, x + width, y + radius, points);\n      quadraticBezierCurve(x + width, y + height - radius, x + width, y + height, x + width - radius, y + height, points);\n      quadraticBezierCurve(x + radius, y + height, x, y + height, x, y + height - radius, points);\n    }\n  },\n  triangulate: function triangulate(graphicsData, graphicsGeometry) {\n    if (Graphics.nextRoundedRectBehavior) {\n      buildCircle.triangulate(graphicsData, graphicsGeometry);\n      return;\n    }\n\n    var points = graphicsData.points;\n    var verts = graphicsGeometry.points;\n    var indices = graphicsGeometry.indices;\n    var vecPos = verts.length / 2;\n    var triangles = earcut(points, null, 2);\n\n    for (var i = 0, j = triangles.length; i < j; i += 3) {\n      indices.push(triangles[i] + vecPos); //     indices.push(triangles[i] + vecPos);\n\n      indices.push(triangles[i + 1] + vecPos); //   indices.push(triangles[i + 2] + vecPos);\n\n      indices.push(triangles[i + 2] + vecPos);\n    }\n\n    for (var i = 0, j = points.length; i < j; i++) {\n      verts.push(points[i], points[++i]);\n    }\n  }\n};\n/**\n * Buffers vertices to draw a square cap.\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {number} x - X-coord of end point\n * @param {number} y - Y-coord of end point\n * @param {number} nx - X-coord of line normal pointing inside\n * @param {number} ny - Y-coord of line normal pointing inside\n * @param {Array<number>} verts - vertex buffer\n * @returns {}\n */\n\nfunction square(x, y, nx, ny, innerWeight, outerWeight, clockwise,\n/* rotation for square (true at left end, false at right end) */\nverts) {\n  var ix = x - nx * innerWeight;\n  var iy = y - ny * innerWeight;\n  var ox = x + nx * outerWeight;\n  var oy = y + ny * outerWeight;\n  /* Rotate nx,ny for extension vector */\n\n  var exx;\n  var eyy;\n\n  if (clockwise) {\n    exx = ny;\n    eyy = -nx;\n  } else {\n    exx = -ny;\n    eyy = nx;\n  }\n  /* [i|0]x,y extended at cap */\n\n\n  var eix = ix + exx;\n  var eiy = iy + eyy;\n  var eox = ox + exx;\n  var eoy = oy + eyy;\n  /* Square itself must be inserted clockwise*/\n\n  verts.push(eix, eiy);\n  verts.push(eox, eoy);\n  return 2;\n}\n/**\n * Buffers vertices to draw an arc at the line joint or cap.\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {number} cx - X-coord of center\n * @param {number} cy - Y-coord of center\n * @param {number} sx - X-coord of arc start\n * @param {number} sy - Y-coord of arc start\n * @param {number} ex - X-coord of arc end\n * @param {number} ey - Y-coord of arc end\n * @param {Array<number>} verts - buffer of vertices\n * @param {boolean} clockwise - orientation of vertices\n * @returns {number} - no. of vertices pushed\n */\n\n\nfunction round(cx, cy, sx, sy, ex, ey, verts, clockwise) {\n  var cx2p0x = sx - cx;\n  var cy2p0y = sy - cy;\n  var angle0 = Math.atan2(cx2p0x, cy2p0y);\n  var angle1 = Math.atan2(ex - cx, ey - cy);\n\n  if (clockwise && angle0 < angle1) {\n    angle0 += Math.PI * 2;\n  } else if (!clockwise && angle0 > angle1) {\n    angle1 += Math.PI * 2;\n  }\n\n  var startAngle = angle0;\n  var angleDiff = angle1 - angle0;\n  var absAngleDiff = Math.abs(angleDiff);\n  /* if (absAngleDiff >= PI_LBOUND && absAngleDiff <= PI_UBOUND)\n  {\n      const r1x = cx - nxtPx;\n      const r1y = cy - nxtPy;\n       if (r1x === 0)\n      {\n          if (r1y > 0)\n          {\n              angleDiff = -angleDiff;\n          }\n      }\n      else if (r1x >= -GRAPHICS_CURVES.epsilon)\n      {\n          angleDiff = -angleDiff;\n      }\n  }*/\n\n  var radius = Math.sqrt(cx2p0x * cx2p0x + cy2p0y * cy2p0y);\n  var segCount = (15 * absAngleDiff * Math.sqrt(radius) / Math.PI >> 0) + 1;\n  var angleInc = angleDiff / segCount;\n  startAngle += angleInc;\n\n  if (clockwise) {\n    verts.push(cx, cy);\n    verts.push(sx, sy);\n\n    for (var i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {\n      verts.push(cx, cy);\n      verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);\n    }\n\n    verts.push(cx, cy);\n    verts.push(ex, ey);\n  } else {\n    verts.push(sx, sy);\n    verts.push(cx, cy);\n\n    for (var i = 1, angle = startAngle; i < segCount; i++, angle += angleInc) {\n      verts.push(cx + Math.sin(angle) * radius, cy + Math.cos(angle) * radius);\n      verts.push(cx, cy);\n    }\n\n    verts.push(ex, ey);\n    verts.push(cx, cy);\n  }\n\n  return segCount * 2;\n}\n/**\n * Builds a line to draw using the polygon method.\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\n\n\nfunction buildNonNativeLine(graphicsData, graphicsGeometry) {\n  var shape = graphicsData.shape;\n  var points = graphicsData.points || shape.points.slice();\n  var eps = graphicsGeometry.closePointEps;\n\n  if (points.length === 0) {\n    return;\n  } // if the line width is an odd number add 0.5 to align to a whole pixel\n  // commenting this out fixes #711 and #1620\n  // if (graphicsData.lineWidth%2)\n  // {\n  //     for (i = 0; i < points.length; i++)\n  //     {\n  //         points[i] += 0.5;\n  //     }\n  // }\n\n\n  var style = graphicsData.lineStyle; // get first and last point.. figure out the middle!\n\n  var firstPoint = new Point(points[0], points[1]);\n  var lastPoint = new Point(points[points.length - 2], points[points.length - 1]);\n  var closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;\n  var closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps && Math.abs(firstPoint.y - lastPoint.y) < eps; // if the first point is the last point - gonna have issues :)\n\n  if (closedShape) {\n    // need to clone as we are going to slightly modify the shape..\n    points = points.slice();\n\n    if (closedPath) {\n      points.pop();\n      points.pop();\n      lastPoint.set(points[points.length - 2], points[points.length - 1]);\n    }\n\n    var midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n    var midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n    points.unshift(midPointX, midPointY);\n    points.push(midPointX, midPointY);\n  }\n\n  var verts = graphicsGeometry.points;\n  var length = points.length / 2;\n  var indexCount = points.length;\n  var indexStart = verts.length / 2; // Max. inner and outer width\n\n  var width = style.width / 2;\n  var widthSquared = width * width;\n  var miterLimitSquared = style.miterLimit * style.miterLimit;\n  /* Line segments of interest where (x1,y1) forms the corner. */\n\n  var x0 = points[0];\n  var y0 = points[1];\n  var x1 = points[2];\n  var y1 = points[3];\n  var x2 = 0;\n  var y2 = 0;\n  /* perp[?](x|y) = the line normal with magnitude lineWidth. */\n\n  var perpx = -(y0 - y1);\n  var perpy = x0 - x1;\n  var perp1x = 0;\n  var perp1y = 0;\n  var dist = Math.sqrt(perpx * perpx + perpy * perpy);\n  perpx /= dist;\n  perpy /= dist;\n  perpx *= width;\n  perpy *= width;\n  var ratio = style.alignment; // 0.5;\n\n  var innerWeight = (1 - ratio) * 2;\n  var outerWeight = ratio * 2;\n\n  if (!closedShape) {\n    if (style.cap === LINE_CAP.ROUND) {\n      indexCount += round(x0 - perpx * (innerWeight - outerWeight) * 0.5, y0 - perpy * (innerWeight - outerWeight) * 0.5, x0 - perpx * innerWeight, y0 - perpy * innerWeight, x0 + perpx * outerWeight, y0 + perpy * outerWeight, verts, true) + 2;\n    } else if (style.cap === LINE_CAP.SQUARE) {\n      indexCount += square(x0, y0, perpx, perpy, innerWeight, outerWeight, true, verts);\n    }\n  } // Push first point (below & above vertices)\n\n\n  verts.push(x0 - perpx * innerWeight, y0 - perpy * innerWeight);\n  verts.push(x0 + perpx * outerWeight, y0 + perpy * outerWeight);\n\n  for (var i = 1; i < length - 1; ++i) {\n    x0 = points[(i - 1) * 2];\n    y0 = points[(i - 1) * 2 + 1];\n    x1 = points[i * 2];\n    y1 = points[i * 2 + 1];\n    x2 = points[(i + 1) * 2];\n    y2 = points[(i + 1) * 2 + 1];\n    perpx = -(y0 - y1);\n    perpy = x0 - x1;\n    dist = Math.sqrt(perpx * perpx + perpy * perpy);\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n    perp1x = -(y1 - y2);\n    perp1y = x1 - x2;\n    dist = Math.sqrt(perp1x * perp1x + perp1y * perp1y);\n    perp1x /= dist;\n    perp1y /= dist;\n    perp1x *= width;\n    perp1y *= width;\n    /* d[x|y](0|1) = the component displacement between points p(0,1|1,2) */\n\n    var dx0 = x1 - x0;\n    var dy0 = y0 - y1;\n    var dx1 = x1 - x2;\n    var dy1 = y2 - y1;\n    /* +ve if internal angle counterclockwise, -ve if internal angle clockwise. */\n\n    var cross = dy0 * dx1 - dy1 * dx0;\n    var clockwise = cross < 0;\n    /* Going nearly straight? */\n\n    if (Math.abs(cross) < 0.1) {\n      verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);\n      verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);\n      continue;\n    }\n    /* p[x|y] is the miter point. pdist is the distance between miter point and p1. */\n\n\n    var c1 = (-perpx + x0) * (-perpy + y1) - (-perpx + x1) * (-perpy + y0);\n    var c2 = (-perp1x + x2) * (-perp1y + y1) - (-perp1x + x1) * (-perp1y + y2);\n    var px = (dx0 * c2 - dx1 * c1) / cross;\n    var py = (dy1 * c1 - dy0 * c2) / cross;\n    var pdist = (px - x1) * (px - x1) + (py - y1) * (py - y1);\n    /* Inner miter point */\n\n    var imx = x1 + (px - x1) * innerWeight;\n    var imy = y1 + (py - y1) * innerWeight;\n    /* Outer miter point */\n\n    var omx = x1 - (px - x1) * outerWeight;\n    var omy = y1 - (py - y1) * outerWeight;\n    /* Is the inside miter point too far away, creating a spike? */\n\n    var smallerInsideSegmentSq = Math.min(dx0 * dx0 + dy0 * dy0, dx1 * dx1 + dy1 * dy1);\n    var insideWeight = clockwise ? innerWeight : outerWeight;\n    var smallerInsideDiagonalSq = smallerInsideSegmentSq + insideWeight * insideWeight * widthSquared;\n    var insideMiterOk = pdist <= smallerInsideDiagonalSq;\n\n    if (insideMiterOk) {\n      if (style.join === LINE_JOIN.BEVEL || pdist / widthSquared > miterLimitSquared) {\n        if (clockwise)\n          /* rotating at inner angle */\n          {\n            verts.push(imx, imy); // inner miter point\n\n            verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight); // first segment's outer vertex\n\n            verts.push(imx, imy); // inner miter point\n\n            verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight); // second segment's outer vertex\n          } else\n          /* rotating at outer angle */\n          {\n            verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight); // first segment's inner vertex\n\n            verts.push(omx, omy); // outer miter point\n\n            verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight); // second segment's outer vertex\n\n            verts.push(omx, omy); // outer miter point\n          }\n\n        indexCount += 2;\n      } else if (style.join === LINE_JOIN.ROUND) {\n        if (clockwise)\n          /* arc is outside */\n          {\n            verts.push(imx, imy);\n            verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);\n            indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 4;\n            verts.push(imx, imy);\n            verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight);\n          } else\n          /* arc is inside */\n          {\n            verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);\n            verts.push(omx, omy);\n            indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 4;\n            verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight);\n            verts.push(omx, omy);\n          }\n      } else {\n        verts.push(imx, imy);\n        verts.push(omx, omy);\n      }\n    } else // inside miter is NOT ok\n      {\n        verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight); // first segment's inner vertex\n\n        verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight); // first segment's outer vertex\n\n        if (style.join === LINE_JOIN.BEVEL || pdist / widthSquared > miterLimitSquared) ;else if (style.join === LINE_JOIN.ROUND) {\n          if (clockwise)\n            /* arc is outside */\n            {\n              indexCount += round(x1, y1, x1 + perpx * outerWeight, y1 + perpy * outerWeight, x1 + perp1x * outerWeight, y1 + perp1y * outerWeight, verts, true) + 2;\n            } else\n            /* arc is inside */\n            {\n              indexCount += round(x1, y1, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 - perp1x * innerWeight, y1 - perp1y * innerWeight, verts, false) + 2;\n            }\n        } else {\n          if (clockwise) {\n            verts.push(omx, omy); // inner miter point\n\n            verts.push(omx, omy); // inner miter point\n          } else {\n            verts.push(imx, imy); // outer miter point\n\n            verts.push(imx, imy); // outer miter point\n          }\n\n          indexCount += 2;\n        }\n        verts.push(x1 - perp1x * innerWeight, y1 - perp1y * innerWeight); // second segment's inner vertex\n\n        verts.push(x1 + perp1x * outerWeight, y1 + perp1y * outerWeight); // second segment's outer vertex\n\n        indexCount += 2;\n      }\n  }\n\n  x0 = points[(length - 2) * 2];\n  y0 = points[(length - 2) * 2 + 1];\n  x1 = points[(length - 1) * 2];\n  y1 = points[(length - 1) * 2 + 1];\n  perpx = -(y0 - y1);\n  perpy = x0 - x1;\n  dist = Math.sqrt(perpx * perpx + perpy * perpy);\n  perpx /= dist;\n  perpy /= dist;\n  perpx *= width;\n  perpy *= width;\n  verts.push(x1 - perpx * innerWeight, y1 - perpy * innerWeight);\n  verts.push(x1 + perpx * outerWeight, y1 + perpy * outerWeight);\n\n  if (!closedShape) {\n    if (style.cap === LINE_CAP.ROUND) {\n      indexCount += round(x1 - perpx * (innerWeight - outerWeight) * 0.5, y1 - perpy * (innerWeight - outerWeight) * 0.5, x1 - perpx * innerWeight, y1 - perpy * innerWeight, x1 + perpx * outerWeight, y1 + perpy * outerWeight, verts, false) + 2;\n    } else if (style.cap === LINE_CAP.SQUARE) {\n      indexCount += square(x1, y1, perpx, perpy, innerWeight, outerWeight, false, verts);\n    }\n  }\n\n  var indices = graphicsGeometry.indices;\n  var eps2 = GRAPHICS_CURVES.epsilon * GRAPHICS_CURVES.epsilon; // indices.push(indexStart);\n\n  for (var i = indexStart; i < indexCount + indexStart - 2; ++i) {\n    x0 = verts[i * 2];\n    y0 = verts[i * 2 + 1];\n    x1 = verts[(i + 1) * 2];\n    y1 = verts[(i + 1) * 2 + 1];\n    x2 = verts[(i + 2) * 2];\n    y2 = verts[(i + 2) * 2 + 1];\n    /* Skip zero area triangles */\n\n    if (Math.abs(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1)) < eps2) {\n      continue;\n    }\n\n    indices.push(i, i + 1, i + 2);\n  }\n}\n/**\n * Builds a line to draw using the gl.drawArrays(gl.LINES) method\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\n\n\nfunction buildNativeLine(graphicsData, graphicsGeometry) {\n  var i = 0;\n  var shape = graphicsData.shape;\n  var points = graphicsData.points || shape.points;\n  var closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;\n\n  if (points.length === 0) {\n    return;\n  }\n\n  var verts = graphicsGeometry.points;\n  var indices = graphicsGeometry.indices;\n  var length = points.length / 2;\n  var startIndex = verts.length / 2;\n  var currentIndex = startIndex;\n  verts.push(points[0], points[1]);\n\n  for (i = 1; i < length; i++) {\n    verts.push(points[i * 2], points[i * 2 + 1]);\n    indices.push(currentIndex, currentIndex + 1);\n    currentIndex++;\n  }\n\n  if (closedShape) {\n    indices.push(currentIndex, startIndex);\n  }\n}\n/**\n * Builds a line to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\n\n\nfunction buildLine(graphicsData, graphicsGeometry) {\n  if (graphicsData.lineStyle.native) {\n    buildNativeLine(graphicsData, graphicsGeometry);\n  } else {\n    buildNonNativeLine(graphicsData, graphicsGeometry);\n  }\n}\n/**\n * Utilities for arc curves.\n *\n * @private\n */\n\n\nvar ArcUtils =\n/** @class */\nfunction () {\n  function ArcUtils() {}\n  /**\n   * The arcTo() method creates an arc/curve between two tangents on the canvas.\n   *\n   * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n   *\n   * @private\n   * @param x1 - The x-coordinate of the beginning of the arc\n   * @param y1 - The y-coordinate of the beginning of the arc\n   * @param x2 - The x-coordinate of the end of the arc\n   * @param y2 - The y-coordinate of the end of the arc\n   * @param radius - The radius of the arc\n   * @return - If the arc length is valid, return center of circle, radius and other info otherwise `null`.\n   */\n\n\n  ArcUtils.curveTo = function (x1, y1, x2, y2, radius, points) {\n    var fromX = points[points.length - 2];\n    var fromY = points[points.length - 1];\n    var a1 = fromY - y1;\n    var b1 = fromX - x1;\n    var a2 = y2 - y1;\n    var b2 = x2 - x1;\n    var mm = Math.abs(a1 * b2 - b1 * a2);\n\n    if (mm < 1.0e-8 || radius === 0) {\n      if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {\n        points.push(x1, y1);\n      }\n\n      return null;\n    }\n\n    var dd = a1 * a1 + b1 * b1;\n    var cc = a2 * a2 + b2 * b2;\n    var tt = a1 * a2 + b1 * b2;\n    var k1 = radius * Math.sqrt(dd) / mm;\n    var k2 = radius * Math.sqrt(cc) / mm;\n    var j1 = k1 * tt / dd;\n    var j2 = k2 * tt / cc;\n    var cx = k1 * b2 + k2 * b1;\n    var cy = k1 * a2 + k2 * a1;\n    var px = b1 * (k2 + j1);\n    var py = a1 * (k2 + j1);\n    var qx = b2 * (k1 + j2);\n    var qy = a2 * (k1 + j2);\n    var startAngle = Math.atan2(py - cy, px - cx);\n    var endAngle = Math.atan2(qy - cy, qx - cx);\n    return {\n      cx: cx + x1,\n      cy: cy + y1,\n      radius: radius,\n      startAngle: startAngle,\n      endAngle: endAngle,\n      anticlockwise: b1 * a2 > b2 * a1\n    };\n  };\n  /* eslint-disable max-len */\n\n  /**\n   * The arc method creates an arc/curve (used to create circles, or parts of circles).\n   *\n   * @private\n   * @param startX - Start x location of arc\n   * @param startY - Start y location of arc\n   * @param cx - The x-coordinate of the center of the circle\n   * @param cy - The y-coordinate of the center of the circle\n   * @param radius - The radius of the circle\n   * @param startAngle - The starting angle, in radians (0 is at the 3 o'clock position\n   *  of the arc's circle)\n   * @param endAngle - The ending angle, in radians\n   * @param anticlockwise - Specifies whether the drawing should be\n   *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true\n   *  indicates counter-clockwise.\n   * @param points - Collection of points to add to\n   */\n\n\n  ArcUtils.arc = function (_startX, _startY, cx, cy, radius, startAngle, endAngle, _anticlockwise, points) {\n    var sweep = endAngle - startAngle;\n\n    var n = GRAPHICS_CURVES._segmentsCount(Math.abs(sweep) * radius, Math.ceil(Math.abs(sweep) / PI_2) * 40);\n\n    var theta = sweep / (n * 2);\n    var theta2 = theta * 2;\n    var cTheta = Math.cos(theta);\n    var sTheta = Math.sin(theta);\n    var segMinus = n - 1;\n    var remainder = segMinus % 1 / segMinus;\n\n    for (var i = 0; i <= segMinus; ++i) {\n      var real = i + remainder * i;\n      var angle = theta + startAngle + theta2 * real;\n      var c = Math.cos(angle);\n      var s = -Math.sin(angle);\n      points.push((cTheta * c + sTheta * s) * radius + cx, (cTheta * -s + sTheta * c) * radius + cy);\n    }\n  };\n\n  return ArcUtils;\n}();\n/**\n * Utilities for bezier curves\n *\n * @private\n */\n\n\nvar BezierUtils =\n/** @class */\nfunction () {\n  function BezierUtils() {}\n  /**\n   * Calculate length of bezier curve.\n   * Analytical solution is impossible, since it involves an integral that does not integrate in general.\n   * Therefore numerical solution is used.\n   *\n   * @private\n   * @param fromX - Starting point x\n   * @param fromY - Starting point y\n   * @param cpX - Control point x\n   * @param cpY - Control point y\n   * @param cpX2 - Second Control point x\n   * @param cpY2 - Second Control point y\n   * @param toX - Destination point x\n   * @param toY - Destination point y\n   * @return - Length of bezier curve\n   */\n\n\n  BezierUtils.curveLength = function (fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {\n    var n = 10;\n    var result = 0.0;\n    var t = 0.0;\n    var t2 = 0.0;\n    var t3 = 0.0;\n    var nt = 0.0;\n    var nt2 = 0.0;\n    var nt3 = 0.0;\n    var x = 0.0;\n    var y = 0.0;\n    var dx = 0.0;\n    var dy = 0.0;\n    var prevX = fromX;\n    var prevY = fromY;\n\n    for (var i = 1; i <= n; ++i) {\n      t = i / n;\n      t2 = t * t;\n      t3 = t2 * t;\n      nt = 1.0 - t;\n      nt2 = nt * nt;\n      nt3 = nt2 * nt;\n      x = nt3 * fromX + 3.0 * nt2 * t * cpX + 3.0 * nt * t2 * cpX2 + t3 * toX;\n      y = nt3 * fromY + 3.0 * nt2 * t * cpY + 3 * nt * t2 * cpY2 + t3 * toY;\n      dx = prevX - x;\n      dy = prevY - y;\n      prevX = x;\n      prevY = y;\n      result += Math.sqrt(dx * dx + dy * dy);\n    }\n\n    return result;\n  };\n  /**\n   * Calculate the points for a bezier curve and then draws it.\n   *\n   * Ignored from docs since it is not directly exposed.\n   *\n   * @ignore\n   * @param cpX - Control point x\n   * @param cpY - Control point y\n   * @param cpX2 - Second Control point x\n   * @param cpY2 - Second Control point y\n   * @param toX - Destination point x\n   * @param toY - Destination point y\n   * @param points - Path array to push points into\n   */\n\n\n  BezierUtils.curveTo = function (cpX, cpY, cpX2, cpY2, toX, toY, points) {\n    var fromX = points[points.length - 2];\n    var fromY = points[points.length - 1];\n    points.length -= 2;\n\n    var n = GRAPHICS_CURVES._segmentsCount(BezierUtils.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY));\n\n    var dt = 0;\n    var dt2 = 0;\n    var dt3 = 0;\n    var t2 = 0;\n    var t3 = 0;\n    points.push(fromX, fromY);\n\n    for (var i = 1, j = 0; i <= n; ++i) {\n      j = i / n;\n      dt = 1 - j;\n      dt2 = dt * dt;\n      dt3 = dt2 * dt;\n      t2 = j * j;\n      t3 = t2 * j;\n      points.push(dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);\n    }\n  };\n\n  return BezierUtils;\n}();\n/**\n * Utilities for quadratic curves.\n *\n * @private\n */\n\n\nvar QuadraticUtils =\n/** @class */\nfunction () {\n  function QuadraticUtils() {}\n  /**\n   * Calculate length of quadratic curve\n   * @see {@link http://www.malczak.linuxpl.com/blog/quadratic-bezier-curve-length/}\n   * for the detailed explanation of math behind this.\n   *\n   * @private\n   * @param fromX - x-coordinate of curve start point\n   * @param fromY - y-coordinate of curve start point\n   * @param cpX - x-coordinate of curve control point\n   * @param cpY - y-coordinate of curve control point\n   * @param toX - x-coordinate of curve end point\n   * @param toY - y-coordinate of curve end point\n   * @return - Length of quadratic curve\n   */\n\n\n  QuadraticUtils.curveLength = function (fromX, fromY, cpX, cpY, toX, toY) {\n    var ax = fromX - 2.0 * cpX + toX;\n    var ay = fromY - 2.0 * cpY + toY;\n    var bx = 2.0 * cpX - 2.0 * fromX;\n    var by = 2.0 * cpY - 2.0 * fromY;\n    var a = 4.0 * (ax * ax + ay * ay);\n    var b = 4.0 * (ax * bx + ay * by);\n    var c = bx * bx + by * by;\n    var s = 2.0 * Math.sqrt(a + b + c);\n    var a2 = Math.sqrt(a);\n    var a32 = 2.0 * a * a2;\n    var c2 = 2.0 * Math.sqrt(c);\n    var ba = b / a2;\n    return (a32 * s + a2 * b * (s - c2) + (4.0 * c * a - b * b) * Math.log((2.0 * a2 + ba + s) / (ba + c2))) / (4.0 * a32);\n  };\n  /**\n   * Calculate the points for a quadratic bezier curve and then draws it.\n   * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n   *\n   * @private\n   * @param cpX - Control point x\n   * @param cpY - Control point y\n   * @param toX - Destination point x\n   * @param toY - Destination point y\n   * @param points - Points to add segments to.\n   */\n\n\n  QuadraticUtils.curveTo = function (cpX, cpY, toX, toY, points) {\n    var fromX = points[points.length - 2];\n    var fromY = points[points.length - 1];\n\n    var n = GRAPHICS_CURVES._segmentsCount(QuadraticUtils.curveLength(fromX, fromY, cpX, cpY, toX, toY));\n\n    var xa = 0;\n    var ya = 0;\n\n    for (var i = 1; i <= n; ++i) {\n      var j = i / n;\n      xa = fromX + (cpX - fromX) * j;\n      ya = fromY + (cpY - fromY) * j;\n      points.push(xa + (cpX + (toX - cpX) * j - xa) * j, ya + (cpY + (toY - cpY) * j - ya) * j);\n    }\n  };\n\n  return QuadraticUtils;\n}();\n/**\n * A structure to hold interim batch objects for Graphics.\n *\n * @memberof PIXI.graphicsUtils\n */\n\n\nvar BatchPart =\n/** @class */\nfunction () {\n  function BatchPart() {\n    this.reset();\n  }\n  /** Begin batch part. */\n\n\n  BatchPart.prototype.begin = function (style, startIndex, attribStart) {\n    this.reset();\n    this.style = style;\n    this.start = startIndex;\n    this.attribStart = attribStart;\n  };\n  /** End batch part. */\n\n\n  BatchPart.prototype.end = function (endIndex, endAttrib) {\n    this.attribSize = endAttrib - this.attribStart;\n    this.size = endIndex - this.start;\n  };\n\n  BatchPart.prototype.reset = function () {\n    this.style = null;\n    this.size = 0;\n    this.start = 0;\n    this.attribStart = 0;\n    this.attribSize = 0;\n  };\n\n  return BatchPart;\n}();\n/**\n * Generalized convenience utilities for Graphics.\n *\n * @namespace graphicsUtils\n * @memberof PIXI\n */\n\n\nvar _a;\n/**\n * Map of fill commands for each shape type.\n *\n * @memberof PIXI.graphicsUtils\n * @member {Object} FILL_COMMANDS\n */\n\n\nvar FILL_COMMANDS = (_a = {}, _a[SHAPES.POLY] = buildPoly, _a[SHAPES.CIRC] = buildCircle, _a[SHAPES.ELIP] = buildCircle, _a[SHAPES.RECT] = buildRectangle, _a[SHAPES.RREC] = buildRoundedRectangle, _a);\n/**\n * Batch pool, stores unused batches for preventing allocations.\n *\n * @memberof PIXI.graphicsUtils\n * @member {Array<PIXI.graphicsUtils.BatchPart>} BATCH_POOL\n */\n\nvar BATCH_POOL = [];\n/**\n * Draw call pool, stores unused draw calls for preventing allocations.\n *\n * @memberof PIXI.graphicsUtils\n * @member {Array<PIXI.BatchDrawCall>} DRAW_CALL_POOL\n */\n\nvar DRAW_CALL_POOL = [];\n/**\n * A class to contain data useful for Graphics objects\n *\n * @memberof PIXI\n */\n\nvar GraphicsData =\n/** @class */\nfunction () {\n  /**\n   * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n   * @param fillStyle - the width of the line to draw\n   * @param lineStyle - the color of the line to draw\n   * @param matrix - Transform matrix\n   */\n  function GraphicsData(shape, fillStyle, lineStyle, matrix) {\n    if (fillStyle === void 0) {\n      fillStyle = null;\n    }\n\n    if (lineStyle === void 0) {\n      lineStyle = null;\n    }\n\n    if (matrix === void 0) {\n      matrix = null;\n    }\n    /** The collection of points. */\n\n\n    this.points = [];\n    /** The collection of holes. */\n\n    this.holes = [];\n    this.shape = shape;\n    this.lineStyle = lineStyle;\n    this.fillStyle = fillStyle;\n    this.matrix = matrix;\n    this.type = shape.type;\n  }\n  /**\n   * Creates a new GraphicsData object with the same values as this one.\n   *\n   * @return - Cloned GraphicsData object\n   */\n\n\n  GraphicsData.prototype.clone = function () {\n    return new GraphicsData(this.shape, this.fillStyle, this.lineStyle, this.matrix);\n  };\n  /** Destroys the Graphics data. */\n\n\n  GraphicsData.prototype.destroy = function () {\n    this.shape = null;\n    this.holes.length = 0;\n    this.holes = null;\n    this.points.length = 0;\n    this.points = null;\n    this.lineStyle = null;\n    this.fillStyle = null;\n  };\n\n  return GraphicsData;\n}();\n\nvar tmpPoint = new Point();\nvar tmpBounds = new Bounds();\n/**\n * The Graphics class contains methods used to draw primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.\n *\n * GraphicsGeometry is designed to not be continually updating the geometry since it's expensive\n * to re-tesselate using **earcut**. Consider using {@link PIXI.Mesh} for this use-case, it's much faster.\n *\n * @memberof PIXI\n */\n\nvar GraphicsGeometry =\n/** @class */\nfunction (_super) {\n  __extends(GraphicsGeometry, _super); // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n\n\n  function GraphicsGeometry() {\n    var _this = _super.call(this) || this;\n    /**\n     * Minimal distance between points that are considered different.\n     * Affects line tesselation.\n     */\n\n\n    _this.closePointEps = 1e-4;\n    /** Padding to add to the bounds. */\n\n    _this.boundsPadding = 0;\n    _this.uvsFloat32 = null;\n    _this.indicesUint16 = null;\n    _this.batchable = false;\n    /** An array of points to draw, 2 numbers per point */\n\n    _this.points = [];\n    /** The collection of colors */\n\n    _this.colors = [];\n    /** The UVs collection */\n\n    _this.uvs = [];\n    /** The indices of the vertices */\n\n    _this.indices = [];\n    /** Reference to the texture IDs. */\n\n    _this.textureIds = [];\n    /**\n     * The collection of drawn shapes.\n     *\n     * @member {PIXI.GraphicsData[]}\n     */\n\n    _this.graphicsData = [];\n    /**\n     * List of current draw calls drived from the batches.\n     *\n     * @member {PIXI.BatchDrawCall[]}\n     */\n\n    _this.drawCalls = [];\n    /** Batches need to regenerated if the geometry is updated. */\n\n    _this.batchDirty = -1;\n    /**\n     * Intermediate abstract format sent to batch system.\n     * Can be converted to drawCalls or to batchable objects.\n     *\n     * @member {PIXI.graphicsUtils.BatchPart[]}\n     */\n\n    _this.batches = [];\n    /** Used to detect if the graphics object has changed. */\n\n    _this.dirty = 0;\n    /** Used to check if the cache is dirty. */\n\n    _this.cacheDirty = -1;\n    /** Used to detect if we cleared the graphicsData. */\n\n    _this.clearDirty = 0;\n    /** Index of the last batched shape in the stack of calls. */\n\n    _this.shapeIndex = 0;\n    /** Cached bounds. */\n\n    _this._bounds = new Bounds();\n    /** The bounds dirty flag. */\n\n    _this.boundsDirty = -1;\n    return _this;\n  }\n\n  Object.defineProperty(GraphicsGeometry.prototype, \"bounds\", {\n    /**\n     * Get the current bounds of the graphic geometry.\n     *\n     * @readonly\n     */\n    get: function get() {\n      if (this.boundsDirty !== this.dirty) {\n        this.boundsDirty = this.dirty;\n        this.calculateBounds();\n      }\n\n      return this._bounds;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Call if you changed graphicsData manually.\n   * Empties all batch buffers.\n   */\n\n  GraphicsGeometry.prototype.invalidate = function () {\n    this.boundsDirty = -1;\n    this.dirty++;\n    this.batchDirty++;\n    this.shapeIndex = 0;\n    this.points.length = 0;\n    this.colors.length = 0;\n    this.uvs.length = 0;\n    this.indices.length = 0;\n    this.textureIds.length = 0;\n\n    for (var i = 0; i < this.drawCalls.length; i++) {\n      this.drawCalls[i].texArray.clear();\n      DRAW_CALL_POOL.push(this.drawCalls[i]);\n    }\n\n    this.drawCalls.length = 0;\n\n    for (var i = 0; i < this.batches.length; i++) {\n      var batchPart = this.batches[i];\n      batchPart.reset();\n      BATCH_POOL.push(batchPart);\n    }\n\n    this.batches.length = 0;\n  };\n  /**\n   * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n   *\n   * @return - This GraphicsGeometry object. Good for chaining method calls\n   */\n\n\n  GraphicsGeometry.prototype.clear = function () {\n    if (this.graphicsData.length > 0) {\n      this.invalidate();\n      this.clearDirty++;\n      this.graphicsData.length = 0;\n    }\n\n    return this;\n  };\n  /**\n   * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n   *\n   * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n   * @param fillStyle - Defines style of the fill.\n   * @param lineStyle - Defines style of the lines.\n   * @param matrix - Transform applied to the points of the shape.\n   * @return - Returns geometry for chaining.\n   */\n\n\n  GraphicsGeometry.prototype.drawShape = function (shape, fillStyle, lineStyle, matrix) {\n    if (fillStyle === void 0) {\n      fillStyle = null;\n    }\n\n    if (lineStyle === void 0) {\n      lineStyle = null;\n    }\n\n    if (matrix === void 0) {\n      matrix = null;\n    }\n\n    var data = new GraphicsData(shape, fillStyle, lineStyle, matrix);\n    this.graphicsData.push(data);\n    this.dirty++;\n    return this;\n  };\n  /**\n   * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n   *\n   * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n   * @param matrix - Transform applied to the points of the shape.\n   * @return - Returns geometry for chaining.\n   */\n\n\n  GraphicsGeometry.prototype.drawHole = function (shape, matrix) {\n    if (matrix === void 0) {\n      matrix = null;\n    }\n\n    if (!this.graphicsData.length) {\n      return null;\n    }\n\n    var data = new GraphicsData(shape, null, null, matrix);\n    var lastShape = this.graphicsData[this.graphicsData.length - 1];\n    data.lineStyle = lastShape.lineStyle;\n    lastShape.holes.push(data);\n    this.dirty++;\n    return this;\n  };\n  /** Destroys the GraphicsGeometry object. */\n\n\n  GraphicsGeometry.prototype.destroy = function () {\n    _super.prototype.destroy.call(this); // destroy each of the GraphicsData objects\n\n\n    for (var i = 0; i < this.graphicsData.length; ++i) {\n      this.graphicsData[i].destroy();\n    }\n\n    this.points.length = 0;\n    this.points = null;\n    this.colors.length = 0;\n    this.colors = null;\n    this.uvs.length = 0;\n    this.uvs = null;\n    this.indices.length = 0;\n    this.indices = null;\n    this.indexBuffer.destroy();\n    this.indexBuffer = null;\n    this.graphicsData.length = 0;\n    this.graphicsData = null;\n    this.drawCalls.length = 0;\n    this.drawCalls = null;\n    this.batches.length = 0;\n    this.batches = null;\n    this._bounds = null;\n  };\n  /**\n   * Check to see if a point is contained within this geometry.\n   *\n   * @param point - Point to check if it's contained.\n   * @return {Boolean} `true` if the point is contained within geometry.\n   */\n\n\n  GraphicsGeometry.prototype.containsPoint = function (point) {\n    var graphicsData = this.graphicsData;\n\n    for (var i = 0; i < graphicsData.length; ++i) {\n      var data = graphicsData[i];\n\n      if (!data.fillStyle.visible) {\n        continue;\n      } // only deal with fills..\n\n\n      if (data.shape) {\n        if (data.matrix) {\n          data.matrix.applyInverse(point, tmpPoint);\n        } else {\n          tmpPoint.copyFrom(point);\n        }\n\n        if (data.shape.contains(tmpPoint.x, tmpPoint.y)) {\n          var hitHole = false;\n\n          if (data.holes) {\n            for (var i_1 = 0; i_1 < data.holes.length; i_1++) {\n              var hole = data.holes[i_1];\n\n              if (hole.shape.contains(tmpPoint.x, tmpPoint.y)) {\n                hitHole = true;\n                break;\n              }\n            }\n          }\n\n          if (!hitHole) {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  };\n  /**\n   * Generates intermediate batch data. Either gets converted to drawCalls\n   * or used to convert to batch objects directly by the Graphics object.\n   *\n   * @param allow32Indices - Allow using 32-bit indices for preventing artifacts when more that 65535 vertices\n   */\n\n\n  GraphicsGeometry.prototype.updateBatches = function (allow32Indices) {\n    if (!this.graphicsData.length) {\n      this.batchable = true;\n      return;\n    }\n\n    if (!this.validateBatching()) {\n      return;\n    }\n\n    this.cacheDirty = this.dirty;\n    var uvs = this.uvs;\n    var graphicsData = this.graphicsData;\n    var batchPart = null;\n    var currentStyle = null;\n\n    if (this.batches.length > 0) {\n      batchPart = this.batches[this.batches.length - 1];\n      currentStyle = batchPart.style;\n    }\n\n    for (var i = this.shapeIndex; i < graphicsData.length; i++) {\n      this.shapeIndex++;\n      var data = graphicsData[i];\n      var fillStyle = data.fillStyle;\n      var lineStyle = data.lineStyle;\n      var command = FILL_COMMANDS[data.type]; // build out the shapes points..\n\n      command.build(data);\n\n      if (data.matrix) {\n        this.transformPoints(data.points, data.matrix);\n      }\n\n      if (fillStyle.visible || lineStyle.visible) {\n        this.processHoles(data.holes);\n      }\n\n      for (var j = 0; j < 2; j++) {\n        var style = j === 0 ? fillStyle : lineStyle;\n\n        if (!style.visible) {\n          continue;\n        }\n\n        var nextTexture = style.texture.baseTexture;\n        var index_1 = this.indices.length;\n        var attribIndex = this.points.length / 2;\n        nextTexture.wrapMode = WRAP_MODES.REPEAT;\n\n        if (j === 0) {\n          this.processFill(data);\n        } else {\n          this.processLine(data);\n        }\n\n        var size = this.points.length / 2 - attribIndex;\n\n        if (size === 0) {\n          continue;\n        } // close batch if style is different\n\n\n        if (batchPart && !this._compareStyles(currentStyle, style)) {\n          batchPart.end(index_1, attribIndex);\n          batchPart = null;\n        } // spawn new batch if its first batch or previous was closed\n\n\n        if (!batchPart) {\n          batchPart = BATCH_POOL.pop() || new BatchPart();\n          batchPart.begin(style, index_1, attribIndex);\n          this.batches.push(batchPart);\n          currentStyle = style;\n        }\n\n        this.addUvs(this.points, uvs, style.texture, attribIndex, size, style.matrix);\n      }\n    }\n\n    var index = this.indices.length;\n    var attrib = this.points.length / 2;\n\n    if (batchPart) {\n      batchPart.end(index, attrib);\n    }\n\n    if (this.batches.length === 0) {\n      // there are no visible styles in GraphicsData\n      // its possible that someone wants Graphics just for the bounds\n      this.batchable = true;\n      return;\n    } // prevent allocation when length is same as buffer\n\n\n    if (this.indicesUint16 && this.indices.length === this.indicesUint16.length) {\n      this.indicesUint16.set(this.indices);\n    } else {\n      var need32 = attrib > 0xffff && allow32Indices;\n      this.indicesUint16 = need32 ? new Uint32Array(this.indices) : new Uint16Array(this.indices);\n    } // TODO make this a const..\n\n\n    this.batchable = this.isBatchable();\n\n    if (this.batchable) {\n      this.packBatches();\n    } else {\n      this.buildDrawCalls();\n    }\n  };\n  /**\n   * Affinity check\n   *\n   * @param styleA\n   * @param styleB\n   */\n\n\n  GraphicsGeometry.prototype._compareStyles = function (styleA, styleB) {\n    if (!styleA || !styleB) {\n      return false;\n    }\n\n    if (styleA.texture.baseTexture !== styleB.texture.baseTexture) {\n      return false;\n    }\n\n    if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha) {\n      return false;\n    }\n\n    if (!!styleA.native !== !!styleB.native) {\n      return false;\n    }\n\n    return true;\n  };\n  /** Test geometry for batching process. */\n\n\n  GraphicsGeometry.prototype.validateBatching = function () {\n    if (this.dirty === this.cacheDirty || !this.graphicsData.length) {\n      return false;\n    }\n\n    for (var i = 0, l = this.graphicsData.length; i < l; i++) {\n      var data = this.graphicsData[i];\n      var fill = data.fillStyle;\n      var line = data.lineStyle;\n\n      if (fill && !fill.texture.baseTexture.valid) {\n        return false;\n      }\n\n      if (line && !line.texture.baseTexture.valid) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n  /** Offset the indices so that it works with the batcher. */\n\n\n  GraphicsGeometry.prototype.packBatches = function () {\n    this.batchDirty++;\n    this.uvsFloat32 = new Float32Array(this.uvs);\n    var batches = this.batches;\n\n    for (var i = 0, l = batches.length; i < l; i++) {\n      var batch = batches[i];\n\n      for (var j = 0; j < batch.size; j++) {\n        var index = batch.start + j;\n        this.indicesUint16[index] = this.indicesUint16[index] - batch.attribStart;\n      }\n    }\n  };\n  /**\n   * Checks to see if this graphics geometry can be batched.\n   * Currently it needs to be small enough and not contain any native lines.\n   */\n\n\n  GraphicsGeometry.prototype.isBatchable = function () {\n    // prevent heavy mesh batching\n    if (this.points.length > 0xffff * 2) {\n      return false;\n    }\n\n    var batches = this.batches;\n\n    for (var i = 0; i < batches.length; i++) {\n      if (batches[i].style.native) {\n        return false;\n      }\n    }\n\n    return this.points.length < GraphicsGeometry.BATCHABLE_SIZE * 2;\n  };\n  /** Converts intermediate batches data to drawCalls. */\n\n\n  GraphicsGeometry.prototype.buildDrawCalls = function () {\n    var TICK = ++BaseTexture._globalBatch;\n\n    for (var i = 0; i < this.drawCalls.length; i++) {\n      this.drawCalls[i].texArray.clear();\n      DRAW_CALL_POOL.push(this.drawCalls[i]);\n    }\n\n    this.drawCalls.length = 0;\n    var colors = this.colors;\n    var textureIds = this.textureIds;\n    var currentGroup = DRAW_CALL_POOL.pop();\n\n    if (!currentGroup) {\n      currentGroup = new BatchDrawCall();\n      currentGroup.texArray = new BatchTextureArray();\n    }\n\n    currentGroup.texArray.count = 0;\n    currentGroup.start = 0;\n    currentGroup.size = 0;\n    currentGroup.type = DRAW_MODES.TRIANGLES;\n    var textureCount = 0;\n    var currentTexture = null;\n    var textureId = 0;\n    var native = false;\n    var drawMode = DRAW_MODES.TRIANGLES;\n    var index = 0;\n    this.drawCalls.push(currentGroup); // TODO - this can be simplified\n\n    for (var i = 0; i < this.batches.length; i++) {\n      var data = this.batches[i]; // TODO add some full on MAX_TEXTURE CODE..\n\n      var MAX_TEXTURES = 8; // Forced cast for checking `native` without errors\n\n      var style = data.style;\n      var nextTexture = style.texture.baseTexture;\n\n      if (native !== !!style.native) {\n        native = !!style.native;\n        drawMode = native ? DRAW_MODES.LINES : DRAW_MODES.TRIANGLES; // force the batch to break!\n\n        currentTexture = null;\n        textureCount = MAX_TEXTURES;\n        TICK++;\n      }\n\n      if (currentTexture !== nextTexture) {\n        currentTexture = nextTexture;\n\n        if (nextTexture._batchEnabled !== TICK) {\n          if (textureCount === MAX_TEXTURES) {\n            TICK++;\n            textureCount = 0;\n\n            if (currentGroup.size > 0) {\n              currentGroup = DRAW_CALL_POOL.pop();\n\n              if (!currentGroup) {\n                currentGroup = new BatchDrawCall();\n                currentGroup.texArray = new BatchTextureArray();\n              }\n\n              this.drawCalls.push(currentGroup);\n            }\n\n            currentGroup.start = index;\n            currentGroup.size = 0;\n            currentGroup.texArray.count = 0;\n            currentGroup.type = drawMode;\n          } // TODO add this to the render part..\n          // Hack! Because texture has protected `touched`\n\n\n          nextTexture.touched = 1; // touch;\n\n          nextTexture._batchEnabled = TICK;\n          nextTexture._batchLocation = textureCount;\n          nextTexture.wrapMode = WRAP_MODES.REPEAT;\n          currentGroup.texArray.elements[currentGroup.texArray.count++] = nextTexture;\n          textureCount++;\n        }\n      }\n\n      currentGroup.size += data.size;\n      index += data.size;\n      textureId = nextTexture._batchLocation;\n      this.addColors(colors, style.color, style.alpha, data.attribSize, data.attribStart);\n      this.addTextureIds(textureIds, textureId, data.attribSize, data.attribStart);\n    }\n\n    BaseTexture._globalBatch = TICK; // upload..\n    // merge for now!\n\n    this.packAttributes();\n  };\n  /** Packs attributes to single buffer. */\n\n\n  GraphicsGeometry.prototype.packAttributes = function () {\n    var verts = this.points;\n    var uvs = this.uvs;\n    var colors = this.colors;\n    var textureIds = this.textureIds; // verts are 2 positions.. so we * by 3 as there are 6 properties.. then 4 cos its bytes\n\n    var glPoints = new ArrayBuffer(verts.length * 3 * 4);\n    var f32 = new Float32Array(glPoints);\n    var u32 = new Uint32Array(glPoints);\n    var p = 0;\n\n    for (var i = 0; i < verts.length / 2; i++) {\n      f32[p++] = verts[i * 2];\n      f32[p++] = verts[i * 2 + 1];\n      f32[p++] = uvs[i * 2];\n      f32[p++] = uvs[i * 2 + 1];\n      u32[p++] = colors[i];\n      f32[p++] = textureIds[i];\n    }\n\n    this._buffer.update(glPoints);\n\n    this._indexBuffer.update(this.indicesUint16);\n  };\n  /** Process fill part of Graphics. */\n\n\n  GraphicsGeometry.prototype.processFill = function (data) {\n    if (data.holes.length) {\n      buildPoly.triangulate(data, this);\n    } else {\n      var command = FILL_COMMANDS[data.type];\n      command.triangulate(data, this);\n    }\n  };\n  /** Process line part of Graphics. */\n\n\n  GraphicsGeometry.prototype.processLine = function (data) {\n    buildLine(data, this);\n\n    for (var i = 0; i < data.holes.length; i++) {\n      buildLine(data.holes[i], this);\n    }\n  };\n  /** Process the holes data. */\n\n\n  GraphicsGeometry.prototype.processHoles = function (holes) {\n    for (var i = 0; i < holes.length; i++) {\n      var hole = holes[i];\n      var command = FILL_COMMANDS[hole.type];\n      command.build(hole);\n\n      if (hole.matrix) {\n        this.transformPoints(hole.points, hole.matrix);\n      }\n    }\n  };\n  /** Update the local bounds of the object. Expensive to use performance-wise. */\n\n\n  GraphicsGeometry.prototype.calculateBounds = function () {\n    var bounds = this._bounds;\n    var sequenceBounds = tmpBounds;\n    var curMatrix = Matrix.IDENTITY;\n\n    this._bounds.clear();\n\n    sequenceBounds.clear();\n\n    for (var i = 0; i < this.graphicsData.length; i++) {\n      var data = this.graphicsData[i];\n      var shape = data.shape;\n      var type = data.type;\n      var lineStyle = data.lineStyle;\n      var nextMatrix = data.matrix || Matrix.IDENTITY;\n      var lineWidth = 0.0;\n\n      if (lineStyle && lineStyle.visible) {\n        lineWidth = lineStyle.width * Math.max(0, lineStyle.alignment);\n      }\n\n      if (curMatrix !== nextMatrix) {\n        if (!sequenceBounds.isEmpty()) {\n          bounds.addBoundsMatrix(sequenceBounds, curMatrix);\n          sequenceBounds.clear();\n        }\n\n        curMatrix = nextMatrix;\n      }\n\n      if (type === SHAPES.RECT || type === SHAPES.RREC) {\n        var rect = shape;\n        sequenceBounds.addFramePad(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, lineWidth, lineWidth);\n      } else if (type === SHAPES.CIRC) {\n        var circle = shape;\n        sequenceBounds.addFramePad(circle.x, circle.y, circle.x, circle.y, circle.radius + lineWidth, circle.radius + lineWidth);\n      } else if (type === SHAPES.ELIP) {\n        var ellipse = shape;\n        sequenceBounds.addFramePad(ellipse.x, ellipse.y, ellipse.x, ellipse.y, ellipse.width + lineWidth, ellipse.height + lineWidth);\n      } else {\n        var poly = shape; // adding directly to the bounds\n\n        bounds.addVerticesMatrix(curMatrix, poly.points, 0, poly.points.length, lineWidth, lineWidth);\n      }\n    }\n\n    if (!sequenceBounds.isEmpty()) {\n      bounds.addBoundsMatrix(sequenceBounds, curMatrix);\n    }\n\n    bounds.pad(this.boundsPadding, this.boundsPadding);\n  };\n  /**\n   * Transform points using matrix.\n   *\n   * @param points - Points to transform\n   * @param matrix - Transform matrix\n   */\n\n\n  GraphicsGeometry.prototype.transformPoints = function (points, matrix) {\n    for (var i = 0; i < points.length / 2; i++) {\n      var x = points[i * 2];\n      var y = points[i * 2 + 1];\n      points[i * 2] = matrix.a * x + matrix.c * y + matrix.tx;\n      points[i * 2 + 1] = matrix.b * x + matrix.d * y + matrix.ty;\n    }\n  };\n  /**\n   * Add colors.\n   *\n   * @param colors - List of colors to add to\n   * @param color - Color to add\n   * @param alpha - Alpha to use\n   * @param size - Number of colors to add\n   * @param offset\n   */\n\n\n  GraphicsGeometry.prototype.addColors = function (colors, color, alpha, size, offset) {\n    if (offset === void 0) {\n      offset = 0;\n    } // TODO use the premultiply bits Ivan added\n\n\n    var rgb = (color >> 16) + (color & 0xff00) + ((color & 0xff) << 16);\n    var rgba = premultiplyTint(rgb, alpha);\n    colors.length = Math.max(colors.length, offset + size);\n\n    for (var i = 0; i < size; i++) {\n      colors[offset + i] = rgba;\n    }\n  };\n  /** Add texture id that the shader/fragment wants to use. */\n\n\n  GraphicsGeometry.prototype.addTextureIds = function (textureIds, id, size, offset) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n\n    textureIds.length = Math.max(textureIds.length, offset + size);\n\n    for (var i = 0; i < size; i++) {\n      textureIds[offset + i] = id;\n    }\n  };\n  /**\n   * Generates the UVs for a shape.\n   *\n   * @param verts - Vertices\n   * @param uvs - UVs\n   * @param texture - Reference to Texture\n   * @param start - Index buffer start index.\n   * @param size - The size/length for index buffer.\n   * @param matrix - Optional transform for all points.\n   */\n\n\n  GraphicsGeometry.prototype.addUvs = function (verts, uvs, texture, start, size, matrix) {\n    if (matrix === void 0) {\n      matrix = null;\n    }\n\n    var index = 0;\n    var uvsStart = uvs.length;\n    var frame = texture.frame;\n\n    while (index < size) {\n      var x = verts[(start + index) * 2];\n      var y = verts[(start + index) * 2 + 1];\n\n      if (matrix) {\n        var nx = matrix.a * x + matrix.c * y + matrix.tx;\n        y = matrix.b * x + matrix.d * y + matrix.ty;\n        x = nx;\n      }\n\n      index++;\n      uvs.push(x / frame.width, y / frame.height);\n    }\n\n    var baseTexture = texture.baseTexture;\n\n    if (frame.width < baseTexture.width || frame.height < baseTexture.height) {\n      this.adjustUvs(uvs, texture, uvsStart, size);\n    }\n  };\n  /**\n   * Modify uvs array according to position of texture region\n   * Does not work with rotated or trimmed textures\n   *\n   * @param uvs - array\n   * @param texture - region\n   * @param start - starting index for uvs\n   * @param size - how many points to adjust\n   */\n\n\n  GraphicsGeometry.prototype.adjustUvs = function (uvs, texture, start, size) {\n    var baseTexture = texture.baseTexture;\n    var eps = 1e-6;\n    var finish = start + size * 2;\n    var frame = texture.frame;\n    var scaleX = frame.width / baseTexture.width;\n    var scaleY = frame.height / baseTexture.height;\n    var offsetX = frame.x / frame.width;\n    var offsetY = frame.y / frame.height;\n    var minX = Math.floor(uvs[start] + eps);\n    var minY = Math.floor(uvs[start + 1] + eps);\n\n    for (var i = start + 2; i < finish; i += 2) {\n      minX = Math.min(minX, Math.floor(uvs[i] + eps));\n      minY = Math.min(minY, Math.floor(uvs[i + 1] + eps));\n    }\n\n    offsetX -= minX;\n    offsetY -= minY;\n\n    for (var i = start; i < finish; i += 2) {\n      uvs[i] = (uvs[i] + offsetX) * scaleX;\n      uvs[i + 1] = (uvs[i + 1] + offsetY) * scaleY;\n    }\n  };\n  /**\n   * The maximum number of points to consider an object \"batchable\",\n   * able to be batched by the renderer's batch system.\n  \\    */\n\n\n  GraphicsGeometry.BATCHABLE_SIZE = 100;\n  return GraphicsGeometry;\n}(BatchGeometry);\n/**\n * Represents the line style for Graphics.\n *\n * @memberof PIXI\n */\n\n\nvar LineStyle =\n/** @class */\nfunction (_super) {\n  __extends(LineStyle, _super);\n\n  function LineStyle() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /** The width (thickness) of any lines drawn. */\n\n\n    _this.width = 0;\n    /** The alignment of any lines drawn (0.5 = middle, 1 = outer, 0 = inner). WebGL only. */\n\n    _this.alignment = 0.5;\n    /** If true the lines will be draw using LINES instead of TRIANGLE_STRIP. */\n\n    _this.native = false;\n    /**\n     * Line cap style.\n     *\n     * @member {PIXI.LINE_CAP}\n     * @default PIXI.LINE_CAP.BUTT\n     */\n\n    _this.cap = LINE_CAP.BUTT;\n    /**\n     * Line join style.\n     *\n     * @member {PIXI.LINE_JOIN}\n     * @default PIXI.LINE_JOIN.MITER\n     */\n\n    _this.join = LINE_JOIN.MITER;\n    /** Miter limit. */\n\n    _this.miterLimit = 10;\n    return _this;\n  }\n  /** Clones the object. */\n\n\n  LineStyle.prototype.clone = function () {\n    var obj = new LineStyle();\n    obj.color = this.color;\n    obj.alpha = this.alpha;\n    obj.texture = this.texture;\n    obj.matrix = this.matrix;\n    obj.visible = this.visible;\n    obj.width = this.width;\n    obj.alignment = this.alignment;\n    obj.native = this.native;\n    obj.cap = this.cap;\n    obj.join = this.join;\n    obj.miterLimit = this.miterLimit;\n    return obj;\n  };\n  /** Reset the line style to default. */\n\n\n  LineStyle.prototype.reset = function () {\n    _super.prototype.reset.call(this); // Override default line style color\n\n\n    this.color = 0x0;\n    this.alignment = 0.5;\n    this.width = 0;\n    this.native = false;\n  };\n\n  return LineStyle;\n}(FillStyle);\n\nvar temp = new Float32Array(3); // a default shaders map used by graphics..\n\nvar DEFAULT_SHADERS = {};\n/**\n * The Graphics class is primarily used to render primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.  However, you can also use a Graphics\n * object to build a list of primitives to use as a mask, or as a complex hitArea.\n *\n * Please note that due to legacy naming conventions, the behavior of some functions in this class\n * can be confusing.  Each call to `drawRect()`, `drawPolygon()`, etc. actually stores that primitive\n * in the Geometry class's GraphicsGeometry object for later use in rendering or hit testing - the\n * functions do not directly draw anything to the screen.  Similarly, the `clear()` function doesn't\n * change the screen, it simply resets the list of primitives, which can be useful if you want to\n * rebuild the contents of an existing Graphics object.\n *\n * Once a GraphicsGeometry list is built, you can re-use it in other Geometry objects as\n * an optimization, by passing it into a new Geometry object's constructor.  Because of this\n * ability, it's important to call `destroy()` on Geometry objects once you are done with them, to\n * properly dereference each GraphicsGeometry and prevent memory leaks.\n *\n * @memberof PIXI\n */\n\nvar Graphics =\n/** @class */\nfunction (_super) {\n  __extends(Graphics, _super);\n  /**\n   * @param geometry - Geometry to use, if omitted will create a new GraphicsGeometry instance.\n   */\n\n\n  function Graphics(geometry) {\n    if (geometry === void 0) {\n      geometry = null;\n    }\n\n    var _this = _super.call(this) || this;\n    /**\n     * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.\n     * Can be shared between multiple Graphics objects.\n     */\n\n\n    _this.shader = null;\n    /** Renderer plugin for batching */\n\n    _this.pluginName = 'batch';\n    /**\n     * Current path\n     *\n     * @readonly\n     */\n\n    _this.currentPath = null;\n    /** A collections of batches! These can be drawn by the renderer batch system. */\n\n    _this.batches = [];\n    /** Update dirty for limiting calculating tints for batches. */\n\n    _this.batchTint = -1;\n    /** Update dirty for limiting calculating batches.*/\n\n    _this.batchDirty = -1;\n    /** Copy of the object vertex data. */\n\n    _this.vertexData = null;\n    /** Current fill style. */\n\n    _this._fillStyle = new FillStyle();\n    /** Current line style. */\n\n    _this._lineStyle = new LineStyle();\n    /** Current shape transform matrix. */\n\n    _this._matrix = null;\n    /** Current hole mode is enabled. */\n\n    _this._holeMode = false;\n    /**\n     * Represents the WebGL state the Graphics required to render, excludes shader and geometry. E.g.,\n     * blend mode, culling, depth testing, direction of rendering triangles, backface, etc.\n     */\n\n    _this.state = State.for2d();\n    _this._geometry = geometry || new GraphicsGeometry();\n    _this._geometry.refCount++;\n    /**\n     * When cacheAsBitmap is set to true the graphics object will be rendered as if it was a sprite.\n     * This is useful if your graphics element does not change often, as it will speed up the rendering\n     * of the object in exchange for taking up texture memory. It is also useful if you need the graphics\n     * object to be anti-aliased, because it will be rendered using canvas. This is not recommended if\n     * you are constantly redrawing the graphics element.\n     *\n     * @name cacheAsBitmap\n     * @member {boolean}\n     * @memberof PIXI.Graphics#\n     * @default false\n     */\n\n    _this._transformID = -1; // Set default\n\n    _this.tint = 0xFFFFFF;\n    _this.blendMode = BLEND_MODES.NORMAL;\n    return _this;\n  }\n\n  Object.defineProperty(Graphics.prototype, \"geometry\", {\n    /**\n     * Includes vertex positions, face indices, normals, colors, UVs, and\n     * custom attributes within buffers, reducing the cost of passing all\n     * this data to the GPU. Can be shared between multiple Mesh or Graphics objects.\n     *\n     * @readonly\n     */\n    get: function get() {\n      return this._geometry;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Creates a new Graphics object with the same values as this one.\n   * Note that only the geometry of the object is cloned, not its transform (position,scale,etc)\n   *\n   * @return - A clone of the graphics object\n   */\n\n  Graphics.prototype.clone = function () {\n    this.finishPoly();\n    return new Graphics(this._geometry);\n  };\n\n  Object.defineProperty(Graphics.prototype, \"blendMode\", {\n    get: function get() {\n      return this.state.blendMode;\n    },\n\n    /**\n     * The blend mode to be applied to the graphic shape. Apply a value of\n     * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.  Note that, since each\n     * primitive in the GraphicsGeometry list is rendered sequentially, modes\n     * such as `PIXI.BLEND_MODES.ADD` and `PIXI.BLEND_MODES.MULTIPLY` will\n     * be applied per-primitive.\n     *\n     * @default PIXI.BLEND_MODES.NORMAL\n     */\n    set: function set(value) {\n      this.state.blendMode = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Graphics.prototype, \"tint\", {\n    /**\n     * The tint applied to each graphic shape. This is a hex value. A value of\n     * 0xFFFFFF will remove any tint effect.\n     *\n     * @default 0xFFFFFF\n     */\n    get: function get() {\n      return this._tint;\n    },\n    set: function set(value) {\n      this._tint = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Graphics.prototype, \"fill\", {\n    /**\n     * The current fill style.\n     *\n     * @readonly\n     */\n    get: function get() {\n      return this._fillStyle;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Graphics.prototype, \"line\", {\n    /**\n     * The current line style.\n     *\n     * @readonly\n     */\n    get: function get() {\n      return this._lineStyle;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  Graphics.prototype.lineStyle = function (options, color, alpha, alignment, native) {\n    if (options === void 0) {\n      options = null;\n    }\n\n    if (color === void 0) {\n      color = 0x0;\n    }\n\n    if (alpha === void 0) {\n      alpha = 1;\n    }\n\n    if (alignment === void 0) {\n      alignment = 0.5;\n    }\n\n    if (native === void 0) {\n      native = false;\n    } // Support non-object params: (width, color, alpha, alignment, native)\n\n\n    if (typeof options === 'number') {\n      options = {\n        width: options,\n        color: color,\n        alpha: alpha,\n        alignment: alignment,\n        native: native\n      };\n    }\n\n    return this.lineTextureStyle(options);\n  };\n  /**\n   * Like line style but support texture for line fill.\n   *\n   * @param options - Collection of options for setting line style.\n   * @param {number} [options.width=0] - width of the line to draw, will update the objects stored style\n   * @param {PIXI.Texture} [options.texture=PIXI.Texture.WHITE] - Texture to use\n   * @param {number} [options.color=0x0] - color of the line to draw, will update the objects stored style.\n   *  Default 0xFFFFFF if texture present.\n   * @param {number} [options.alpha=1] - alpha of the line to draw, will update the objects stored style\n   * @param {PIXI.Matrix} [options.matrix=null] - Texture matrix to transform texture\n   * @param {number} [options.alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outer).\n   *        WebGL only.\n   * @param {boolean} [options.native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n   * @param {PIXI.LINE_CAP}[options.cap=PIXI.LINE_CAP.BUTT] - line cap style\n   * @param {PIXI.LINE_JOIN}[options.join=PIXI.LINE_JOIN.MITER] - line join style\n   * @param {number}[options.miterLimit=10] - miter limit ratio\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.lineTextureStyle = function (options) {\n    // Apply defaults\n    options = Object.assign({\n      width: 0,\n      texture: Texture.WHITE,\n      color: options && options.texture ? 0xFFFFFF : 0x0,\n      alpha: 1,\n      matrix: null,\n      alignment: 0.5,\n      native: false,\n      cap: LINE_CAP.BUTT,\n      join: LINE_JOIN.MITER,\n      miterLimit: 10\n    }, options);\n\n    if (this.currentPath) {\n      this.startPoly();\n    }\n\n    var visible = options.width > 0 && options.alpha > 0;\n\n    if (!visible) {\n      this._lineStyle.reset();\n    } else {\n      if (options.matrix) {\n        options.matrix = options.matrix.clone();\n        options.matrix.invert();\n      }\n\n      Object.assign(this._lineStyle, {\n        visible: visible\n      }, options);\n    }\n\n    return this;\n  };\n  /**\n   * Start a polygon object internally.\n   *\n   * @protected\n   */\n\n\n  Graphics.prototype.startPoly = function () {\n    if (this.currentPath) {\n      var points = this.currentPath.points;\n      var len = this.currentPath.points.length;\n\n      if (len > 2) {\n        this.drawShape(this.currentPath);\n        this.currentPath = new Polygon();\n        this.currentPath.closeStroke = false;\n        this.currentPath.points.push(points[len - 2], points[len - 1]);\n      }\n    } else {\n      this.currentPath = new Polygon();\n      this.currentPath.closeStroke = false;\n    }\n  };\n  /**\n   * Finish the polygon object.\n   *\n   * @protected\n   */\n\n\n  Graphics.prototype.finishPoly = function () {\n    if (this.currentPath) {\n      if (this.currentPath.points.length > 2) {\n        this.drawShape(this.currentPath);\n        this.currentPath = null;\n      } else {\n        this.currentPath.points.length = 0;\n      }\n    }\n  };\n  /**\n   * Moves the current drawing position to x, y.\n   *\n   * @param x - the X coordinate to move to\n   * @param y - the Y coordinate to move to\n   * @return - This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.moveTo = function (x, y) {\n    this.startPoly();\n    this.currentPath.points[0] = x;\n    this.currentPath.points[1] = y;\n    return this;\n  };\n  /**\n   * Draws a line using the current line style from the current drawing position to (x, y);\n   * The current drawing position is then set to (x, y).\n   *\n   * @param x - the X coordinate to draw to\n   * @param y - the Y coordinate to draw to\n   * @return - This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.lineTo = function (x, y) {\n    if (!this.currentPath) {\n      this.moveTo(0, 0);\n    } // remove duplicates..\n\n\n    var points = this.currentPath.points;\n    var fromX = points[points.length - 2];\n    var fromY = points[points.length - 1];\n\n    if (fromX !== x || fromY !== y) {\n      points.push(x, y);\n    }\n\n    return this;\n  };\n  /** Initialize the curve */\n\n\n  Graphics.prototype._initCurve = function (x, y) {\n    if (x === void 0) {\n      x = 0;\n    }\n\n    if (y === void 0) {\n      y = 0;\n    }\n\n    if (this.currentPath) {\n      if (this.currentPath.points.length === 0) {\n        this.currentPath.points = [x, y];\n      }\n    } else {\n      this.moveTo(x, y);\n    }\n  };\n  /**\n   * Calculate the points for a quadratic bezier curve and then draws it.\n   * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n   *\n   * @param cpX - Control point x\n   * @param cpY - Control point y\n   * @param toX - Destination point x\n   * @param toY - Destination point y\n   * @return - This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.quadraticCurveTo = function (cpX, cpY, toX, toY) {\n    this._initCurve();\n\n    var points = this.currentPath.points;\n\n    if (points.length === 0) {\n      this.moveTo(0, 0);\n    }\n\n    QuadraticUtils.curveTo(cpX, cpY, toX, toY, points);\n    return this;\n  };\n  /**\n   * Calculate the points for a bezier curve and then draws it.\n   *\n   * @param cpX - Control point x\n   * @param cpY - Control point y\n   * @param cpX2 - Second Control point x\n   * @param cpY2 - Second Control point y\n   * @param toX - Destination point x\n   * @param toY - Destination point y\n   * @return This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.bezierCurveTo = function (cpX, cpY, cpX2, cpY2, toX, toY) {\n    this._initCurve();\n\n    BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);\n    return this;\n  };\n  /**\n   * The arcTo() method creates an arc/curve between two tangents on the canvas.\n   *\n   * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n   *\n   * @param x1 - The x-coordinate of the first tangent point of the arc\n   * @param y1 - The y-coordinate of the first tangent point of the arc\n   * @param x2 - The x-coordinate of the end of the arc\n   * @param y2 - The y-coordinate of the end of the arc\n   * @param radius - The radius of the arc\n   * @return - This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.arcTo = function (x1, y1, x2, y2, radius) {\n    this._initCurve(x1, y1);\n\n    var points = this.currentPath.points;\n    var result = ArcUtils.curveTo(x1, y1, x2, y2, radius, points);\n\n    if (result) {\n      var cx = result.cx,\n          cy = result.cy,\n          radius_1 = result.radius,\n          startAngle = result.startAngle,\n          endAngle = result.endAngle,\n          anticlockwise = result.anticlockwise;\n      this.arc(cx, cy, radius_1, startAngle, endAngle, anticlockwise);\n    }\n\n    return this;\n  };\n  /**\n   * The arc method creates an arc/curve (used to create circles, or parts of circles).\n   *\n   * @param cx - The x-coordinate of the center of the circle\n   * @param cy - The y-coordinate of the center of the circle\n   * @param radius - The radius of the circle\n   * @param startAngle - The starting angle, in radians (0 is at the 3 o'clock position\n   *  of the arc's circle)\n   * @param endAngle - The ending angle, in radians\n   * @param anticlockwise - Specifies whether the drawing should be\n   *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true\n   *  indicates counter-clockwise.\n   * @return - This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.arc = function (cx, cy, radius, startAngle, endAngle, anticlockwise) {\n    if (anticlockwise === void 0) {\n      anticlockwise = false;\n    }\n\n    if (startAngle === endAngle) {\n      return this;\n    }\n\n    if (!anticlockwise && endAngle <= startAngle) {\n      endAngle += PI_2;\n    } else if (anticlockwise && startAngle <= endAngle) {\n      startAngle += PI_2;\n    }\n\n    var sweep = endAngle - startAngle;\n\n    if (sweep === 0) {\n      return this;\n    }\n\n    var startX = cx + Math.cos(startAngle) * radius;\n    var startY = cy + Math.sin(startAngle) * radius;\n    var eps = this._geometry.closePointEps; // If the currentPath exists, take its points. Otherwise call `moveTo` to start a path.\n\n    var points = this.currentPath ? this.currentPath.points : null;\n\n    if (points) {\n      // TODO: make a better fix.\n      // We check how far our start is from the last existing point\n      var xDiff = Math.abs(points[points.length - 2] - startX);\n      var yDiff = Math.abs(points[points.length - 1] - startY);\n      if (xDiff < eps && yDiff < eps) ;else {\n        points.push(startX, startY);\n      }\n    } else {\n      this.moveTo(startX, startY);\n      points = this.currentPath.points;\n    }\n\n    ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points);\n    return this;\n  };\n  /**\n   * Specifies a simple one-color fill that subsequent calls to other Graphics methods\n   * (such as lineTo() or drawCircle()) use when drawing.\n   *\n   * @param color - the color of the fill\n   * @param alpha - the alpha of the fill\n   * @return - This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.beginFill = function (color, alpha) {\n    if (color === void 0) {\n      color = 0;\n    }\n\n    if (alpha === void 0) {\n      alpha = 1;\n    }\n\n    return this.beginTextureFill({\n      texture: Texture.WHITE,\n      color: color,\n      alpha: alpha\n    });\n  };\n  /**\n   * Begin the texture fill\n   *\n   * @param options - Object object.\n   * @param {PIXI.Texture} [options.texture=PIXI.Texture.WHITE] - Texture to fill\n   * @param {number} [options.color=0xffffff] - Background to fill behind texture\n   * @param {number} [options.alpha=1] - Alpha of fill\n   * @param {PIXI.Matrix} [options.matrix=null] - Transform matrix\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.beginTextureFill = function (options) {\n    // Apply defaults\n    options = Object.assign({\n      texture: Texture.WHITE,\n      color: 0xFFFFFF,\n      alpha: 1,\n      matrix: null\n    }, options);\n\n    if (this.currentPath) {\n      this.startPoly();\n    }\n\n    var visible = options.alpha > 0;\n\n    if (!visible) {\n      this._fillStyle.reset();\n    } else {\n      if (options.matrix) {\n        options.matrix = options.matrix.clone();\n        options.matrix.invert();\n      }\n\n      Object.assign(this._fillStyle, {\n        visible: visible\n      }, options);\n    }\n\n    return this;\n  };\n  /**\n   * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.\n   *\n   * @return - This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.endFill = function () {\n    this.finishPoly();\n\n    this._fillStyle.reset();\n\n    return this;\n  };\n  /**\n   * Draws a rectangle shape.\n   *\n   * @param x - The X coord of the top-left of the rectangle\n   * @param y - The Y coord of the top-left of the rectangle\n   * @param width - The width of the rectangle\n   * @param height - The height of the rectangle\n   * @return - This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.drawRect = function (x, y, width, height) {\n    return this.drawShape(new Rectangle(x, y, width, height));\n  };\n  /**\n   * Draw a rectangle shape with rounded/beveled corners.\n   *\n   * @param x - The X coord of the top-left of the rectangle\n   * @param y - The Y coord of the top-left of the rectangle\n   * @param width - The width of the rectangle\n   * @param height - The height of the rectangle\n   * @param radius - Radius of the rectangle corners\n   * @return - This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.drawRoundedRect = function (x, y, width, height, radius) {\n    return this.drawShape(new RoundedRectangle(x, y, width, height, radius));\n  };\n  /**\n   * Draws a circle.\n   *\n   * @param x - The X coordinate of the center of the circle\n   * @param y - The Y coordinate of the center of the circle\n   * @param radius - The radius of the circle\n   * @return - This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.drawCircle = function (x, y, radius) {\n    return this.drawShape(new Circle(x, y, radius));\n  };\n  /**\n   * Draws an ellipse.\n   *\n   * @param x - The X coordinate of the center of the ellipse\n   * @param y - The Y coordinate of the center of the ellipse\n   * @param width - The half width of the ellipse\n   * @param height - The half height of the ellipse\n   * @return - This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.drawEllipse = function (x, y, width, height) {\n    return this.drawShape(new Ellipse(x, y, width, height));\n  };\n  /**\n   * Draws a polygon using the given path.\n   *\n   * @param {number[]|PIXI.Point[]|PIXI.Polygon} path - The path data used to construct the polygon.\n   * @return - This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.drawPolygon = function () {\n    var arguments$1 = arguments;\n    var path = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      path[_i] = arguments$1[_i];\n    }\n\n    var points;\n    var closeStroke = true; // !!this._fillStyle;\n\n    var poly = path[0]; // check if data has points..\n\n    if (poly.points) {\n      closeStroke = poly.closeStroke;\n      points = poly.points;\n    } else if (Array.isArray(path[0])) {\n      points = path[0];\n    } else {\n      points = path;\n    }\n\n    var shape = new Polygon(points);\n    shape.closeStroke = closeStroke;\n    this.drawShape(shape);\n    return this;\n  };\n  /**\n   * Draw any shape.\n   *\n   * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - Shape to draw\n   * @return - This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.drawShape = function (shape) {\n    if (!this._holeMode) {\n      this._geometry.drawShape(shape, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix);\n    } else {\n      this._geometry.drawHole(shape, this._matrix);\n    }\n\n    return this;\n  };\n  /**\n   * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n   *\n   * @return - This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.clear = function () {\n    this._geometry.clear();\n\n    this._lineStyle.reset();\n\n    this._fillStyle.reset();\n\n    this._boundsID++;\n    this._matrix = null;\n    this._holeMode = false;\n    this.currentPath = null;\n    return this;\n  };\n  /**\n   * True if graphics consists of one rectangle, and thus, can be drawn like a Sprite and\n   * masked with gl.scissor.\n   *\n   * @returns - True if only 1 rect.\n   */\n\n\n  Graphics.prototype.isFastRect = function () {\n    var data = this._geometry.graphicsData;\n    return data.length === 1 && data[0].shape.type === SHAPES.RECT && !data[0].matrix && !data[0].holes.length && !(data[0].lineStyle.visible && data[0].lineStyle.width);\n  };\n  /**\n   * Renders the object using the WebGL renderer\n   *\n   * @param renderer - The renderer\n   */\n\n\n  Graphics.prototype._render = function (renderer) {\n    this.finishPoly();\n    var geometry = this._geometry;\n    var hasuint32 = renderer.context.supports.uint32Indices; // batch part..\n    // batch it!\n\n    geometry.updateBatches(hasuint32);\n\n    if (geometry.batchable) {\n      if (this.batchDirty !== geometry.batchDirty) {\n        this._populateBatches();\n      }\n\n      this._renderBatched(renderer);\n    } else {\n      // no batching...\n      renderer.batch.flush();\n\n      this._renderDirect(renderer);\n    }\n  };\n  /** Populating batches for rendering. */\n\n\n  Graphics.prototype._populateBatches = function () {\n    var geometry = this._geometry;\n    var blendMode = this.blendMode;\n    var len = geometry.batches.length;\n    this.batchTint = -1;\n    this._transformID = -1;\n    this.batchDirty = geometry.batchDirty;\n    this.batches.length = len;\n    this.vertexData = new Float32Array(geometry.points);\n\n    for (var i = 0; i < len; i++) {\n      var gI = geometry.batches[i];\n      var color = gI.style.color;\n      var vertexData = new Float32Array(this.vertexData.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);\n      var uvs = new Float32Array(geometry.uvsFloat32.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);\n      var indices = new Uint16Array(geometry.indicesUint16.buffer, gI.start * 2, gI.size);\n      var batch = {\n        vertexData: vertexData,\n        blendMode: blendMode,\n        indices: indices,\n        uvs: uvs,\n        _batchRGB: hex2rgb(color),\n        _tintRGB: color,\n        _texture: gI.style.texture,\n        alpha: gI.style.alpha,\n        worldAlpha: 1\n      };\n      this.batches[i] = batch;\n    }\n  };\n  /**\n   * Renders the batches using the BathedRenderer plugin\n   *\n   * @param renderer - The renderer\n   */\n\n\n  Graphics.prototype._renderBatched = function (renderer) {\n    if (!this.batches.length) {\n      return;\n    }\n\n    renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);\n    this.calculateVertices();\n    this.calculateTints();\n\n    for (var i = 0, l = this.batches.length; i < l; i++) {\n      var batch = this.batches[i];\n      batch.worldAlpha = this.worldAlpha * batch.alpha;\n      renderer.plugins[this.pluginName].render(batch);\n    }\n  };\n  /**\n   * Renders the graphics direct\n   *\n   * @param renderer - The renderer\n   */\n\n\n  Graphics.prototype._renderDirect = function (renderer) {\n    var shader = this._resolveDirectShader(renderer);\n\n    var geometry = this._geometry;\n    var tint = this.tint;\n    var worldAlpha = this.worldAlpha;\n    var uniforms = shader.uniforms;\n    var drawCalls = geometry.drawCalls; // lets set the transfomr\n\n    uniforms.translationMatrix = this.transform.worldTransform; // and then lets set the tint..\n\n    uniforms.tint[0] = (tint >> 16 & 0xFF) / 255 * worldAlpha;\n    uniforms.tint[1] = (tint >> 8 & 0xFF) / 255 * worldAlpha;\n    uniforms.tint[2] = (tint & 0xFF) / 255 * worldAlpha;\n    uniforms.tint[3] = worldAlpha; // the first draw call, we can set the uniforms of the shader directly here.\n    // this means that we can tack advantage of the sync function of pixi!\n    // bind and sync uniforms..\n    // there is a way to optimise this..\n\n    renderer.shader.bind(shader);\n    renderer.geometry.bind(geometry, shader); // set state..\n\n    renderer.state.set(this.state); // then render the rest of them...\n\n    for (var i = 0, l = drawCalls.length; i < l; i++) {\n      this._renderDrawCallDirect(renderer, geometry.drawCalls[i]);\n    }\n  };\n  /** Renders specific DrawCall */\n\n\n  Graphics.prototype._renderDrawCallDirect = function (renderer, drawCall) {\n    var texArray = drawCall.texArray,\n        type = drawCall.type,\n        size = drawCall.size,\n        start = drawCall.start;\n    var groupTextureCount = texArray.count;\n\n    for (var j = 0; j < groupTextureCount; j++) {\n      renderer.texture.bind(texArray.elements[j], j);\n    }\n\n    renderer.geometry.draw(type, size, start);\n  };\n  /**\n   * Resolves shader for direct rendering\n   *\n   * @param renderer - The renderer\n   */\n\n\n  Graphics.prototype._resolveDirectShader = function (renderer) {\n    var shader = this.shader;\n    var pluginName = this.pluginName;\n\n    if (!shader) {\n      // if there is no shader here, we can use the default shader.\n      // and that only gets created if we actually need it..\n      // but may be more than one plugins for graphics\n      if (!DEFAULT_SHADERS[pluginName]) {\n        var MAX_TEXTURES = renderer.plugins.batch.MAX_TEXTURES;\n        var sampleValues = new Int32Array(MAX_TEXTURES);\n\n        for (var i = 0; i < MAX_TEXTURES; i++) {\n          sampleValues[i] = i;\n        }\n\n        var uniforms = {\n          tint: new Float32Array([1, 1, 1, 1]),\n          translationMatrix: new Matrix(),\n          default: UniformGroup.from({\n            uSamplers: sampleValues\n          }, true)\n        };\n        var program = renderer.plugins[pluginName]._shader.program;\n        DEFAULT_SHADERS[pluginName] = new Shader(program, uniforms);\n      }\n\n      shader = DEFAULT_SHADERS[pluginName];\n    }\n\n    return shader;\n  };\n  /** Retrieves the bounds of the graphic shape as a rectangle object. */\n\n\n  Graphics.prototype._calculateBounds = function () {\n    this.finishPoly();\n    var geometry = this._geometry; // skipping when graphics is empty, like a container\n\n    if (!geometry.graphicsData.length) {\n      return;\n    }\n\n    var _a = geometry.bounds,\n        minX = _a.minX,\n        minY = _a.minY,\n        maxX = _a.maxX,\n        maxY = _a.maxY;\n\n    this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\n  };\n  /**\n   * Tests if a point is inside this graphics object\n   *\n   * @param point - the point to test\n   * @return - the result of the test\n   */\n\n\n  Graphics.prototype.containsPoint = function (point) {\n    this.worldTransform.applyInverse(point, Graphics._TEMP_POINT);\n    return this._geometry.containsPoint(Graphics._TEMP_POINT);\n  };\n  /** Recalculate the tint by applying tint to batches using Graphics tint. */\n\n\n  Graphics.prototype.calculateTints = function () {\n    if (this.batchTint !== this.tint) {\n      this.batchTint = this.tint;\n      var tintRGB = hex2rgb(this.tint, temp);\n\n      for (var i = 0; i < this.batches.length; i++) {\n        var batch = this.batches[i];\n        var batchTint = batch._batchRGB;\n        var r = tintRGB[0] * batchTint[0] * 255;\n        var g = tintRGB[1] * batchTint[1] * 255;\n        var b = tintRGB[2] * batchTint[2] * 255; // TODO Ivan, can this be done in one go?\n\n        var color = (r << 16) + (g << 8) + (b | 0);\n        batch._tintRGB = (color >> 16) + (color & 0xff00) + ((color & 0xff) << 16);\n      }\n    }\n  };\n  /**\n   * If there's a transform update or a change to the shape of the\n   * geometry, recalculate the vertices.\n   */\n\n\n  Graphics.prototype.calculateVertices = function () {\n    var wtID = this.transform._worldID;\n\n    if (this._transformID === wtID) {\n      return;\n    }\n\n    this._transformID = wtID;\n    var wt = this.transform.worldTransform;\n    var a = wt.a;\n    var b = wt.b;\n    var c = wt.c;\n    var d = wt.d;\n    var tx = wt.tx;\n    var ty = wt.ty;\n    var data = this._geometry.points; // batch.vertexDataOriginal;\n\n    var vertexData = this.vertexData;\n    var count = 0;\n\n    for (var i = 0; i < data.length; i += 2) {\n      var x = data[i];\n      var y = data[i + 1];\n      vertexData[count++] = a * x + c * y + tx;\n      vertexData[count++] = d * y + b * x + ty;\n    }\n  };\n  /**\n   * Closes the current path.\n   *\n   * @return - Returns itself.\n   */\n\n\n  Graphics.prototype.closePath = function () {\n    var currentPath = this.currentPath;\n\n    if (currentPath) {\n      // we don't need to add extra point in the end because buildLine will take care of that\n      currentPath.closeStroke = true; // ensure that the polygon is completed, and is available for hit detection\n      // (even if the graphics is not rendered yet)\n\n      this.finishPoly();\n    }\n\n    return this;\n  };\n  /**\n   * Apply a matrix to the positional data.\n   *\n   * @param matrix - Matrix to use for transform current shape.\n   * @return - Returns itself.\n   */\n\n\n  Graphics.prototype.setMatrix = function (matrix) {\n    this._matrix = matrix;\n    return this;\n  };\n  /**\n   * Begin adding holes to the last draw shape\n   * IMPORTANT: holes must be fully inside a shape to work\n   * Also weirdness ensues if holes overlap!\n   * Ellipses, Circles, Rectangles and Rounded Rectangles cannot be holes or host for holes in CanvasRenderer,\n   * please use `moveTo` `lineTo`, `quadraticCurveTo` if you rely on pixi-legacy bundle.\n   *\n   * @return - Returns itself.\n   */\n\n\n  Graphics.prototype.beginHole = function () {\n    this.finishPoly();\n    this._holeMode = true;\n    return this;\n  };\n  /**\n   * End adding holes to the last draw shape.\n   *\n   * @return - Returns itself.\n   */\n\n\n  Graphics.prototype.endHole = function () {\n    this.finishPoly();\n    this._holeMode = false;\n    return this;\n  };\n  /**\n   * Destroys the Graphics object.\n   *\n   * @param options - Options parameter. A boolean will act as if all\n   *  options have been set to that value\n   * @param {boolean} [options.children=false] - if set to true, all the children will have\n   *  their destroy method called as well. 'options' will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n   *  Should it destroy the texture of the child sprite\n   * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n   *  Should it destroy the base texture of the child sprite\n   */\n\n\n  Graphics.prototype.destroy = function (options) {\n    this._geometry.refCount--;\n\n    if (this._geometry.refCount === 0) {\n      this._geometry.dispose();\n    }\n\n    this._matrix = null;\n    this.currentPath = null;\n\n    this._lineStyle.destroy();\n\n    this._lineStyle = null;\n\n    this._fillStyle.destroy();\n\n    this._fillStyle = null;\n    this._geometry = null;\n    this.shader = null;\n    this.vertexData = null;\n    this.batches.length = 0;\n    this.batches = null;\n\n    _super.prototype.destroy.call(this, options);\n  };\n  /**\n   * New rendering behavior for rounded rectangles: circular arcs instead of quadratic bezier curves.\n   * In the next major release, we'll enable this by default.\n   */\n\n\n  Graphics.nextRoundedRectBehavior = false;\n  /**\n   * Temporary point to use for containsPoint.\n   *\n   * @private\n   */\n\n  Graphics._TEMP_POINT = new Point();\n  return Graphics;\n}(Container);\n\nvar graphicsUtils = {\n  buildPoly: buildPoly,\n  buildCircle: buildCircle,\n  buildRectangle: buildRectangle,\n  buildRoundedRectangle: buildRoundedRectangle,\n  buildLine: buildLine,\n  ArcUtils: ArcUtils,\n  BezierUtils: BezierUtils,\n  QuadraticUtils: QuadraticUtils,\n  BatchPart: BatchPart,\n  FILL_COMMANDS: FILL_COMMANDS,\n  BATCH_POOL: BATCH_POOL,\n  DRAW_CALL_POOL: DRAW_CALL_POOL\n};\nexport { FillStyle, GRAPHICS_CURVES, Graphics, GraphicsData, GraphicsGeometry, LINE_CAP, LINE_JOIN, LineStyle, graphicsUtils };","map":{"version":3,"mappings":"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","names":["LINE_JOIN","LINE_CAP","GRAPHICS_CURVES","adaptive","maxLength","minSegments","maxSegments","epsilon","_segmentsCount","length","defaultSegments","isNaN","result","Math","ceil","Texture","WHITE","reset","FillStyle","obj","color","alpha","texture","matrix","visible","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","constructor","prototype","create","fixOrientation","points","hole","m","area","i","x1","y1","x2","y2","n","i1","i2","i3","i4","_a","_b","buildPoly","build","graphicsData","shape","slice","triangulate","graphicsGeometry","holes","verts","indices","holeArray","push","concat","triangles","earcut","vertPos","buildCircle","x","y","dx","dy","rx","ry","type","SHAPES","CIRC","circle","radius","ELIP","ellipse","width","height","roundedRect","halfWidth","halfHeight","max","min","sqrt","j1","j2","j3","j4","x0","y0","a","PI","cos","sin","center","RREC","c","tx","ty","buildRectangle","rectData","getPt","n1","n2","perc","diff","quadraticBezierCurve","fromX","fromY","cpX","cpY","toX","toY","out","xa","ya","xb","yb","j","buildRoundedRectangle","Graphics","nextRoundedRectBehavior","rrectData","vecPos","square","nx","ny","innerWeight","outerWeight","clockwise","ix","iy","ox","oy","exx","eyy","eix","eiy","eox","eoy","round","cx","cy","sx","sy","ex","ey","cx2p0x","cy2p0y","angle0","atan2","angle1","startAngle","angleDiff","absAngleDiff","abs","segCount","angleInc","angle","buildNonNativeLine","eps","closePointEps","style","lineStyle","firstPoint","Point","lastPoint","closedShape","POLY","closeStroke","closedPath","pop","set","midPointX","midPointY","unshift","indexCount","indexStart","widthSquared","miterLimitSquared","miterLimit","perpx","perpy","perp1x","perp1y","dist","ratio","alignment","cap","ROUND","SQUARE","dx0","dy0","dx1","dy1","cross","c1","c2","px","py","pdist","imx","imy","omx","omy","smallerInsideSegmentSq","insideWeight","smallerInsideDiagonalSq","insideMiterOk","join","BEVEL","eps2","buildNativeLine","startIndex","currentIndex","buildLine","native","ArcUtils","a1","b1","a2","b2","mm","dd","cc","tt","k1","k2","qx","qy","endAngle","anticlockwise","_startX","_startY","_anticlockwise","sweep","PI_2","theta","theta2","cTheta","sTheta","segMinus","remainder","real","s","BezierUtils","cpX2","cpY2","t","t2","t3","nt","nt2","nt3","prevX","prevY","curveLength","dt","dt2","dt3","QuadraticUtils","ax","ay","bx","by","a32","ba","log","BatchPart","attribStart","start","endIndex","endAttrib","attribSize","size","FILL_COMMANDS","RECT","BATCH_POOL","DRAW_CALL_POOL","fillStyle","GraphicsData","tmpPoint","tmpBounds","Bounds","_super","_this","GraphicsGeometry","boundsDirty","dirty","calculateBounds","_bounds","batchDirty","shapeIndex","colors","uvs","textureIds","drawCalls","texArray","clear","batches","batchPart","invalidate","clearDirty","data","lastShape","destroy","call","indexBuffer","point","applyInverse","copyFrom","contains","hitHole","i_1","allow32Indices","batchable","validateBatching","cacheDirty","currentStyle","command","transformPoints","processHoles","nextTexture","baseTexture","index_1","attribIndex","wrapMode","WRAP_MODES","REPEAT","processFill","processLine","_compareStyles","end","begin","addUvs","index","attrib","indicesUint16","need32","Uint32Array","Uint16Array","isBatchable","packBatches","buildDrawCalls","styleA","styleB","l","fill","line","valid","uvsFloat32","Float32Array","batch","BATCHABLE_SIZE","TICK","BaseTexture","_globalBatch","currentGroup","BatchDrawCall","BatchTextureArray","count","DRAW_MODES","TRIANGLES","textureCount","currentTexture","textureId","drawMode","MAX_TEXTURES","LINES","_batchEnabled","touched","_batchLocation","elements","addColors","addTextureIds","packAttributes","glPoints","ArrayBuffer","f32","u32","_buffer","update","_indexBuffer","bounds","sequenceBounds","curMatrix","Matrix","IDENTITY","nextMatrix","lineWidth","isEmpty","addBoundsMatrix","rect","addFramePad","poly","addVerticesMatrix","pad","boundsPadding","offset","rgb","rgba","premultiplyTint","id","uvsStart","frame","adjustUvs","finish","scaleX","scaleY","offsetX","offsetY","minX","floor","minY","BatchGeometry","BUTT","MITER","LineStyle","temp","DEFAULT_SHADERS","geometry","State","for2d","_geometry","refCount","_transformID","tint","blendMode","BLEND_MODES","NORMAL","finishPoly","state","value","_tint","_fillStyle","_lineStyle","options","lineTextureStyle","assign","currentPath","startPoly","clone","invert","len","drawShape","Polygon","moveTo","_initCurve","curveTo","radius_1","arc","startX","startY","xDiff","yDiff","beginTextureFill","Rectangle","RoundedRectangle","Circle","Ellipse","path","isArray","_holeMode","_matrix","drawHole","_boundsID","renderer","hasuint32","context","supports","uint32Indices","updateBatches","_populateBatches","_renderBatched","flush","_renderDirect","batchTint","vertexData","gI","buffer","_batchRGB","hex2rgb","_tintRGB","_texture","worldAlpha","setObjectRenderer","plugins","pluginName","calculateVertices","calculateTints","render","shader","_resolveDirectShader","uniforms","translationMatrix","transform","worldTransform","bind","_renderDrawCallDirect","drawCall","groupTextureCount","draw","sampleValues","Int32Array","default","UniformGroup","from","uSamplers","program","_shader","Shader","maxX","maxY","addFrame","_TEMP_POINT","containsPoint","tintRGB","r","g","wtID","_worldID","wt","dispose","Container","graphicsUtils"],"sources":["../../src/const.ts","../../src/styles/FillStyle.ts","../../../../node_modules/tslib/tslib.es6.js","../../src/utils/buildPoly.ts","../../src/utils/buildCircle.ts","../../src/utils/buildRectangle.ts","../../src/utils/buildRoundedRectangle.ts","../../src/utils/buildLine.ts","../../src/utils/ArcUtils.ts","../../src/utils/BezierUtils.ts","../../src/utils/QuadraticUtils.ts","../../src/utils/BatchPart.ts","../../src/utils/index.ts","../../src/GraphicsData.ts","../../src/GraphicsGeometry.ts","../../src/styles/LineStyle.ts","../../src/Graphics.ts","../../src/index.ts"],"sourcesContent":["/**\n * Supported line joints in `PIXI.LineStyle` for graphics.\n *\n * @see PIXI.Graphics#lineStyle\n * @see https://graphicdesign.stackexchange.com/questions/59018/what-is-a-bevel-join-of-two-lines-exactly-illustrator\n *\n * @name LINE_JOIN\n * @memberof PIXI\n * @static\n * @enum {string}\n * @property {string} MITER - 'miter': make a sharp corner where outer part of lines meet\n * @property {string} BEVEL - 'bevel': add a square butt at each end of line segment and fill the triangle at turn\n * @property {string} ROUND - 'round': add an arc at the joint\n */\nexport enum LINE_JOIN {\n    MITER = 'miter',\n    BEVEL = 'bevel',\n    ROUND = 'round'\n}\n\n/**\n * Support line caps in `PIXI.LineStyle` for graphics.\n *\n * @see PIXI.Graphics#lineStyle\n *\n * @name LINE_CAP\n * @memberof PIXI\n * @static\n * @enum {string}\n * @property {string} BUTT - 'butt': don't add any cap at line ends (leaves orthogonal edges)\n * @property {string} ROUND - 'round': add semicircle at ends\n * @property {string} SQUARE - 'square': add square at end (like `BUTT` except more length at end)\n */\nexport enum LINE_CAP {\n    BUTT = 'butt',\n    ROUND = 'round',\n    SQUARE = 'square'\n}\n\nexport interface IGraphicsCurvesSettings {\n    adaptive: boolean;\n    maxLength: number;\n    minSegments: number;\n    maxSegments: number;\n\n    epsilon: number;\n\n    _segmentsCount(length: number, defaultSegments?: number): number;\n}\n\n/**\n * Graphics curves resolution settings. If `adaptive` flag is set to `true`,\n * the resolution is calculated based on the curve's length to ensure better visual quality.\n * Adaptive draw works with `bezierCurveTo` and `quadraticCurveTo`.\n *\n * @static\n * @constant\n * @memberof PIXI\n * @name GRAPHICS_CURVES\n * @type {object}\n * @property {boolean} adaptive=true - flag indicating if the resolution should be adaptive\n * @property {number} maxLength=10 - maximal length of a single segment of the curve (if adaptive = false, ignored)\n * @property {number} minSegments=8 - minimal number of segments in the curve (if adaptive = false, ignored)\n * @property {number} maxSegments=2048 - maximal number of segments in the curve (if adaptive = false, ignored)\n */\nexport const GRAPHICS_CURVES: IGraphicsCurvesSettings = {\n    adaptive: true,\n    maxLength: 10,\n    minSegments: 8,\n    maxSegments:  2048,\n\n    epsilon: 0.0001,\n\n    _segmentsCount(length: number, defaultSegments = 20)\n    {\n        if (!this.adaptive || !length || isNaN(length))\n        {\n            return defaultSegments;\n        }\n\n        let result = Math.ceil(length / this.maxLength);\n\n        if (result < this.minSegments)\n        {\n            result = this.minSegments;\n        }\n        else if (result > this.maxSegments)\n        {\n            result = this.maxSegments;\n        }\n\n        return result;\n    },\n};\n","import { Texture } from '@pixi/core';\nimport type { Matrix } from '@pixi/math';\n\n/**\n * Fill style object for Graphics.\n *\n * @memberof PIXI\n */\nexport class FillStyle\n{\n    /**\n     * The hex color value used when coloring the Graphics object.\n     *\n     * @default 0xFFFFFF\n     */\n    public color = 0xFFFFFF;\n\n    /** The alpha value used when filling the Graphics object. */\n    public alpha = 1.0;\n\n    /**\n     * The texture to be used for the fill.\n     *\n     * @default 0\n     */\n    public texture: Texture = Texture.WHITE;\n\n    /**\n     * The transform applied to the texture.\n     *\n     * @default null\n     */\n    public matrix: Matrix = null;\n\n    /** If the current fill is visible. */\n    public visible = false;\n\n    constructor()\n    {\n        this.reset();\n    }\n\n    /** Clones the object */\n    public clone(): FillStyle\n    {\n        const obj = new FillStyle();\n\n        obj.color = this.color;\n        obj.alpha = this.alpha;\n        obj.texture = this.texture;\n        obj.matrix = this.matrix;\n        obj.visible = this.visible;\n\n        return obj;\n    }\n\n    /** Reset */\n    public reset(): void\n    {\n        this.color = 0xFFFFFF;\n        this.alpha = 1;\n        this.texture = Texture.WHITE;\n        this.matrix = null;\n        this.visible = false;\n    }\n\n    /** Destroy and don't use after this. */\n    public destroy(): void\n    {\n        this.texture = null;\n        this.matrix = null;\n    }\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { earcut } from '@pixi/utils';\n\nimport type { IShapeBuildCommand } from './IShapeBuildCommand';\nimport type { Polygon } from '@pixi/math';\n\nfunction fixOrientation(points: number[], hole = false)\n{\n    const m = points.length;\n\n    if (m < 6)\n    {\n        return;\n    }\n\n    let area = 0;\n\n    for (let i = 0, x1 = points[m - 2], y1 = points[m - 1]; i < m; i += 2)\n    {\n        const x2 = points[i];\n        const y2 = points[i + 1];\n\n        area += (x2 - x1) * (y2 + y1);\n\n        x1 = x2;\n        y1 = y2;\n    }\n\n    if ((!hole && area > 0) || (hole && area <= 0))\n    {\n        const n = m / 2;\n\n        for (let i = n + (n % 2); i < m; i += 2)\n        {\n            const i1 = m - i - 2;\n            const i2 = m - i - 1;\n            const i3 = i;\n            const i4 = i + 1;\n\n            [points[i1], points[i3]] = [points[i3], points[i1]];\n            [points[i2], points[i4]] = [points[i4], points[i2]];\n        }\n    }\n}\n/**\n * Builds a polygon to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nexport const buildPoly: IShapeBuildCommand = {\n\n    build(graphicsData)\n    {\n        graphicsData.points = (graphicsData.shape as Polygon).points.slice();\n    },\n\n    triangulate(graphicsData, graphicsGeometry)\n    {\n        let points = graphicsData.points;\n        const holes = graphicsData.holes;\n        const verts = graphicsGeometry.points;\n        const indices = graphicsGeometry.indices;\n\n        if (points.length >= 6)\n        {\n            fixOrientation(points, false);\n\n            const holeArray = [];\n            // Process holes..\n\n            for (let i = 0; i < holes.length; i++)\n            {\n                const hole = holes[i];\n\n                fixOrientation(hole.points, true);\n\n                holeArray.push(points.length / 2);\n                points = points.concat(hole.points);\n            }\n\n            // sort color\n            const triangles = earcut(points, holeArray, 2);\n\n            if (!triangles)\n            {\n                return;\n            }\n\n            const vertPos = verts.length / 2;\n\n            for (let i = 0; i < triangles.length; i += 3)\n            {\n                indices.push(triangles[i] + vertPos);\n                indices.push(triangles[i + 1] + vertPos);\n                indices.push(triangles[i + 2] + vertPos);\n            }\n\n            for (let i = 0; i < points.length; i++)\n            {\n                verts.push(points[i]);\n            }\n        }\n    },\n};\n","// for type only\nimport { SHAPES } from '@pixi/math';\n\nimport type { Circle, Ellipse, RoundedRectangle } from '@pixi/math';\nimport type { IShapeBuildCommand } from './IShapeBuildCommand';\n\n/**\n * Builds a circle to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object to draw\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nexport const buildCircle: IShapeBuildCommand = {\n\n    build(graphicsData)\n    {\n        // need to convert points to a nice regular data\n        const points = graphicsData.points;\n\n        let x;\n        let y;\n        let dx;\n        let dy;\n        let rx;\n        let ry;\n\n        if (graphicsData.type === SHAPES.CIRC)\n        {\n            const circle = graphicsData.shape as Circle;\n\n            x = circle.x;\n            y = circle.y;\n            rx = ry = circle.radius;\n            dx = dy = 0;\n        }\n        else if (graphicsData.type === SHAPES.ELIP)\n        {\n            const ellipse = graphicsData.shape as Ellipse;\n\n            x = ellipse.x;\n            y = ellipse.y;\n            rx = ellipse.width;\n            ry = ellipse.height;\n            dx = dy = 0;\n        }\n        else\n        {\n            const roundedRect = graphicsData.shape as RoundedRectangle;\n            const halfWidth = roundedRect.width / 2;\n            const halfHeight = roundedRect.height / 2;\n\n            x = roundedRect.x + halfWidth;\n            y = roundedRect.y + halfHeight;\n            rx = ry = Math.max(0, Math.min(roundedRect.radius, Math.min(halfWidth, halfHeight)));\n            dx = halfWidth - rx;\n            dy = halfHeight - ry;\n        }\n\n        // Choose a number of segments such that the maximum absolute deviation from the circle is approximately 0.029\n        const n = Math.ceil(2.3 * Math.sqrt(rx + ry));\n        const m = (n * 8) + (dx ? 4 : 0) + (dy ? 4 : 0);\n\n        points.length = m;\n\n        if (m === 0)\n        {\n            return;\n        }\n\n        if (n === 0)\n        {\n            points.length = 8;\n            points[0] = points[6] = x + dx;\n            points[1] = points[3] = y + dy;\n            points[2] = points[4] = x - dx;\n            points[5] = points[7] = y - dy;\n\n            return;\n        }\n\n        let j1 = 0;\n        let j2 = (n * 4) + (dx ? 2 : 0) + 2;\n        let j3 = j2;\n        let j4 = m;\n\n        {\n            const x0 = dx + rx;\n            const y0 = dy;\n            const x1 = x + x0;\n            const x2 = x - x0;\n            const y1 = y + y0;\n\n            points[j1++] = x1;\n            points[j1++] = y1;\n            points[--j2] = y1;\n            points[--j2] = x2;\n\n            if (dy)\n            {\n                const y2 = y - y0;\n\n                points[j3++] = x2;\n                points[j3++] = y2;\n                points[--j4] = y2;\n                points[--j4] = x1;\n            }\n        }\n\n        for (let i = 1; i < n; i++)\n        {\n            const a = Math.PI / 2 * (i / n);\n            const x0 = dx + (Math.cos(a) * rx);\n            const y0 = dy + (Math.sin(a) * ry);\n            const x1 = x + x0;\n            const x2 = x - x0;\n            const y1 = y + y0;\n            const y2 = y - y0;\n\n            points[j1++] = x1;\n            points[j1++] = y1;\n            points[--j2] = y1;\n            points[--j2] = x2;\n            points[j3++] = x2;\n            points[j3++] = y2;\n            points[--j4] = y2;\n            points[--j4] = x1;\n        }\n\n        {\n            const x0 = dx;\n            const y0 = dy + ry;\n            const x1 = x + x0;\n            const x2 = x - x0;\n            const y1 = y + y0;\n            const y2 = y - y0;\n\n            points[j1++] = x1;\n            points[j1++] = y1;\n            points[--j4] = y2;\n            points[--j4] = x1;\n\n            if (dx)\n            {\n                points[j1++] = x2;\n                points[j1++] = y1;\n                points[--j4] = y2;\n                points[--j4] = x2;\n            }\n        }\n    },\n\n    triangulate(graphicsData, graphicsGeometry)\n    {\n        const points = graphicsData.points;\n        const verts = graphicsGeometry.points;\n        const indices = graphicsGeometry.indices;\n\n        let vertPos = verts.length / 2;\n        const center = vertPos;\n\n        let x;\n        let y;\n\n        if (graphicsData.type !== SHAPES.RREC)\n        {\n            const circle = graphicsData.shape as Circle;\n\n            x = circle.x;\n            y = circle.y;\n        }\n        else\n        {\n            const roundedRect = graphicsData.shape as RoundedRectangle;\n\n            x = roundedRect.x + (roundedRect.width / 2);\n            y = roundedRect.y + (roundedRect.height / 2);\n        }\n\n        const matrix = graphicsData.matrix;\n\n        // Push center (special point)\n        verts.push(\n            graphicsData.matrix ? (matrix.a * x) + (matrix.c * y) + matrix.tx : x,\n            graphicsData.matrix ? (matrix.b * x) + (matrix.d * y) + matrix.ty : y);\n\n        vertPos++;\n\n        verts.push(points[0], points[1]);\n\n        for (let i = 2; i < points.length; i += 2)\n        {\n            verts.push(points[i], points[i + 1]);\n\n            // add some uvs\n            indices.push(vertPos++, center, vertPos);\n        }\n\n        indices.push(center + 1, center, vertPos);\n    },\n};\n","import type { IShapeBuildCommand } from './IShapeBuildCommand';\nimport type { Rectangle } from '@pixi/math';\n\n/**\n * Builds a rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nexport const buildRectangle: IShapeBuildCommand = {\n\n    build(graphicsData)\n    {\n        // --- //\n        // need to convert points to a nice regular data\n        //\n        const rectData = graphicsData.shape as Rectangle;\n        const x = rectData.x;\n        const y = rectData.y;\n        const width = rectData.width;\n        const height = rectData.height;\n\n        const points = graphicsData.points;\n\n        points.length = 0;\n\n        points.push(x, y,\n            x + width, y,\n            x + width, y + height,\n            x, y + height);\n    },\n\n    triangulate(graphicsData, graphicsGeometry)\n    {\n        const points = graphicsData.points;\n        const verts = graphicsGeometry.points;\n\n        const vertPos = verts.length / 2;\n\n        verts.push(points[0], points[1],\n            points[2], points[3],\n            points[6], points[7],\n            points[4], points[5]);\n\n        graphicsGeometry.indices.push(vertPos, vertPos + 1, vertPos + 2,\n            vertPos + 1, vertPos + 2, vertPos + 3);\n    },\n};\n","import { earcut } from '@pixi/utils';\n\n// for type only\nimport type { IShapeBuildCommand } from './IShapeBuildCommand';\nimport type { RoundedRectangle } from '@pixi/math';\nimport { Graphics } from '../Graphics';\nimport { buildCircle } from './buildCircle';\n\n/**\n * Calculate a single point for a quadratic bezier curve.\n * Utility function used by quadraticBezierCurve.\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {number} n1 - first number\n * @param {number} n2 - second number\n * @param {number} perc - percentage\n * @return {number} the result\n *\n */\nfunction getPt(n1: number, n2: number, perc: number): number\n{\n    const diff = n2 - n1;\n\n    return n1 + (diff * perc);\n}\n\n/**\n * Calculate the points for a quadratic bezier curve. (helper function..)\n * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {number} fromX - Origin point x\n * @param {number} fromY - Origin point x\n * @param {number} cpX - Control point x\n * @param {number} cpY - Control point y\n * @param {number} toX - Destination point x\n * @param {number} toY - Destination point y\n * @param {number[]} [out=[]] - The output array to add points into. If not passed, a new array is created.\n * @return {number[]} an array of points\n */\nfunction quadraticBezierCurve(\n    fromX: number, fromY: number,\n    cpX: number, cpY: number,\n    toX: number, toY: number,\n    out: Array<number> = []): Array<number>\n{\n    const n = 20;\n    const points = out;\n\n    let xa = 0;\n    let ya = 0;\n    let xb = 0;\n    let yb = 0;\n    let x = 0;\n    let y = 0;\n\n    for (let i = 0, j = 0; i <= n; ++i)\n    {\n        j = i / n;\n\n        // The Green Line\n        xa = getPt(fromX, cpX, j);\n        ya = getPt(fromY, cpY, j);\n        xb = getPt(cpX, toX, j);\n        yb = getPt(cpY, toY, j);\n\n        // The Black Dot\n        x = getPt(xa, xb, j);\n        y = getPt(ya, yb, j);\n\n        // Handle case when first curve points overlaps and earcut fails to triangulate\n        if (i === 0 && points[points.length - 2] === x && points[points.length - 1] === y)\n        {\n            continue;\n        }\n\n        points.push(x, y);\n    }\n\n    return points;\n}\n\n/**\n * Builds a rounded rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the WebGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines\n */\nexport const buildRoundedRectangle: IShapeBuildCommand = {\n\n    build(graphicsData)\n    {\n        if (Graphics.nextRoundedRectBehavior)\n        {\n            buildCircle.build(graphicsData);\n\n            return;\n        }\n\n        const rrectData = graphicsData.shape as RoundedRectangle;\n        const points = graphicsData.points;\n        const x = rrectData.x;\n        const y = rrectData.y;\n        const width = rrectData.width;\n        const height = rrectData.height;\n\n        // Don't allow negative radius or greater than half the smallest width\n        const radius = Math.max(0, Math.min(rrectData.radius, Math.min(width, height) / 2));\n\n        points.length = 0;\n\n        // No radius, do a simple rectangle\n        if (!radius)\n        {\n            points.push(x, y,\n                x + width, y,\n                x + width, y + height,\n                x, y + height);\n        }\n        else\n        {\n            quadraticBezierCurve(x, y + radius,\n                x, y,\n                x + radius, y,\n                points);\n            quadraticBezierCurve(x + width - radius,\n                y, x + width, y,\n                x + width, y + radius,\n                points);\n            quadraticBezierCurve(x + width, y + height - radius,\n                x + width, y + height,\n                x + width - radius, y + height,\n                points);\n            quadraticBezierCurve(x + radius, y + height,\n                x, y + height,\n                x, y + height - radius,\n                points);\n        }\n    },\n\n    triangulate(graphicsData, graphicsGeometry)\n    {\n        if (Graphics.nextRoundedRectBehavior)\n        {\n            buildCircle.triangulate(graphicsData, graphicsGeometry);\n\n            return;\n        }\n\n        const points = graphicsData.points;\n\n        const verts = graphicsGeometry.points;\n        const indices = graphicsGeometry.indices;\n\n        const vecPos = verts.length / 2;\n\n        const triangles = earcut(points, null, 2);\n\n        for (let i = 0, j = triangles.length; i < j; i += 3)\n        {\n            indices.push(triangles[i] + vecPos);\n            //     indices.push(triangles[i] + vecPos);\n            indices.push(triangles[i + 1] + vecPos);\n            //   indices.push(triangles[i + 2] + vecPos);\n            indices.push(triangles[i + 2] + vecPos);\n        }\n\n        for (let i = 0, j = points.length; i < j; i++)\n        {\n            verts.push(points[i], points[++i]);\n        }\n    },\n};\n","import { Point, SHAPES } from '@pixi/math';\n\nimport type { Polygon } from '@pixi/math';\nimport type { GraphicsData } from '../GraphicsData';\nimport type { GraphicsGeometry } from '../GraphicsGeometry';\nimport { LINE_JOIN, LINE_CAP, GRAPHICS_CURVES } from '../const';\n\n/**\n * Buffers vertices to draw a square cap.\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {number} x - X-coord of end point\n * @param {number} y - Y-coord of end point\n * @param {number} nx - X-coord of line normal pointing inside\n * @param {number} ny - Y-coord of line normal pointing inside\n * @param {Array<number>} verts - vertex buffer\n * @returns {}\n */\nfunction square(\n    x: number,\n    y: number,\n    nx: number,\n    ny: number,\n    innerWeight: number,\n    outerWeight: number,\n    clockwise: boolean, /* rotation for square (true at left end, false at right end) */\n    verts: Array<number>\n): number\n{\n    const ix = x - (nx * innerWeight);\n    const iy = y - (ny * innerWeight);\n    const ox = x + (nx * outerWeight);\n    const oy = y + (ny * outerWeight);\n\n    /* Rotate nx,ny for extension vector */\n    let exx; let\n        eyy;\n\n    if (clockwise)\n    {\n        exx = ny;\n        eyy = -nx;\n    }\n    else\n    {\n        exx = -ny;\n        eyy = nx;\n    }\n\n    /* [i|0]x,y extended at cap */\n    const eix = ix + exx;\n    const eiy = iy + eyy;\n    const eox = ox + exx;\n    const eoy = oy + eyy;\n\n    /* Square itself must be inserted clockwise*/\n    verts.push(eix, eiy);\n    verts.push(eox, eoy);\n\n    return 2;\n}\n\n/**\n * Buffers vertices to draw an arc at the line joint or cap.\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {number} cx - X-coord of center\n * @param {number} cy - Y-coord of center\n * @param {number} sx - X-coord of arc start\n * @param {number} sy - Y-coord of arc start\n * @param {number} ex - X-coord of arc end\n * @param {number} ey - Y-coord of arc end\n * @param {Array<number>} verts - buffer of vertices\n * @param {boolean} clockwise - orientation of vertices\n * @returns {number} - no. of vertices pushed\n */\nfunction round(\n    cx: number,\n    cy: number,\n    sx: number,\n    sy: number,\n    ex: number,\n    ey: number,\n    verts: Array<number>,\n    clockwise: boolean, /* if not cap, then clockwise is turn of joint, otherwise rotation from angle0 to angle1 */\n): number\n{\n    const cx2p0x = sx - cx;\n    const cy2p0y = sy - cy;\n\n    let angle0 = Math.atan2(cx2p0x, cy2p0y);\n    let angle1 = Math.atan2(ex - cx, ey - cy);\n\n    if (clockwise && angle0 < angle1)\n    {\n        angle0 += Math.PI * 2;\n    }\n    else if (!clockwise && angle0 > angle1)\n    {\n        angle1 += Math.PI * 2;\n    }\n\n    let startAngle = angle0;\n    const angleDiff = angle1 - angle0;\n    const absAngleDiff = Math.abs(angleDiff);\n\n    /* if (absAngleDiff >= PI_LBOUND && absAngleDiff <= PI_UBOUND)\n    {\n        const r1x = cx - nxtPx;\n        const r1y = cy - nxtPy;\n\n        if (r1x === 0)\n        {\n            if (r1y > 0)\n            {\n                angleDiff = -angleDiff;\n            }\n        }\n        else if (r1x >= -GRAPHICS_CURVES.epsilon)\n        {\n            angleDiff = -angleDiff;\n        }\n    }*/\n\n    const radius = Math.sqrt((cx2p0x * cx2p0x) + (cy2p0y * cy2p0y));\n    const segCount = ((15 * absAngleDiff * Math.sqrt(radius) / Math.PI) >> 0) + 1;\n    const angleInc = angleDiff / segCount;\n\n    startAngle += angleInc;\n\n    if (clockwise)\n    {\n        verts.push(cx, cy);\n        verts.push(sx, sy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(cx, cy);\n            verts.push(cx + ((Math.sin(angle) * radius)),\n                cy + ((Math.cos(angle) * radius)));\n        }\n\n        verts.push(cx, cy);\n        verts.push(ex, ey);\n    }\n    else\n    {\n        verts.push(sx, sy);\n        verts.push(cx, cy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(cx + ((Math.sin(angle) * radius)),\n                cy + ((Math.cos(angle) * radius)));\n            verts.push(cx, cy);\n        }\n\n        verts.push(ex, ey);\n        verts.push(cx, cy);\n    }\n\n    return segCount * 2;\n}\n\n/**\n * Builds a line to draw using the polygon method.\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nfunction buildNonNativeLine(graphicsData: GraphicsData, graphicsGeometry: GraphicsGeometry): void\n{\n    const shape = graphicsData.shape as Polygon;\n    let points = graphicsData.points || shape.points.slice();\n    const eps = graphicsGeometry.closePointEps;\n\n    if (points.length === 0)\n    {\n        return;\n    }\n    // if the line width is an odd number add 0.5 to align to a whole pixel\n    // commenting this out fixes #711 and #1620\n    // if (graphicsData.lineWidth%2)\n    // {\n    //     for (i = 0; i < points.length; i++)\n    //     {\n    //         points[i] += 0.5;\n    //     }\n    // }\n\n    const style = graphicsData.lineStyle;\n\n    // get first and last point.. figure out the middle!\n    const firstPoint = new Point(points[0], points[1]);\n    const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);\n    const closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;\n    const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps\n        && Math.abs(firstPoint.y - lastPoint.y) < eps;\n\n    // if the first point is the last point - gonna have issues :)\n    if (closedShape)\n    {\n        // need to clone as we are going to slightly modify the shape..\n        points = points.slice();\n\n        if (closedPath)\n        {\n            points.pop();\n            points.pop();\n            lastPoint.set(points[points.length - 2], points[points.length - 1]);\n        }\n\n        const midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n        const midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n\n        points.unshift(midPointX, midPointY);\n        points.push(midPointX, midPointY);\n    }\n\n    const verts = graphicsGeometry.points;\n    const length = points.length / 2;\n    let indexCount = points.length;\n    const indexStart = verts.length / 2;\n\n    // Max. inner and outer width\n    const width = style.width / 2;\n    const widthSquared = width * width;\n    const miterLimitSquared = style.miterLimit * style.miterLimit;\n\n    /* Line segments of interest where (x1,y1) forms the corner. */\n    let x0 = points[0];\n    let y0 = points[1];\n    let x1 = points[2];\n    let y1 = points[3];\n    let x2 = 0;\n    let y2 = 0;\n\n    /* perp[?](x|y) = the line normal with magnitude lineWidth. */\n    let perpx = -(y0 - y1);\n    let perpy = x0 - x1;\n    let perp1x = 0;\n    let perp1y = 0;\n\n    let dist = Math.sqrt((perpx * perpx) + (perpy * perpy));\n\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n\n    const ratio = style.alignment;// 0.5;\n    const innerWeight = (1 - ratio) * 2;\n    const outerWeight = ratio * 2;\n\n    if (!closedShape)\n    {\n        if (style.cap === LINE_CAP.ROUND)\n        {\n            indexCount += round(\n                x0 - (perpx * (innerWeight - outerWeight) * 0.5),\n                y0 - (perpy * (innerWeight - outerWeight) * 0.5),\n                x0 - (perpx * innerWeight),\n                y0 - (perpy * innerWeight),\n                x0 + (perpx * outerWeight),\n                y0 + (perpy * outerWeight),\n                verts,\n                true,\n            ) + 2;\n        }\n        else if (style.cap === LINE_CAP.SQUARE)\n        {\n            indexCount += square(x0, y0, perpx, perpy, innerWeight, outerWeight, true, verts);\n        }\n    }\n\n    // Push first point (below & above vertices)\n    verts.push(\n        x0 - (perpx * innerWeight),\n        y0 - (perpy * innerWeight));\n    verts.push(\n        x0 + (perpx * outerWeight),\n        y0 + (perpy * outerWeight));\n\n    for (let i = 1; i < length - 1; ++i)\n    {\n        x0 = points[(i - 1) * 2];\n        y0 = points[((i - 1) * 2) + 1];\n\n        x1 = points[i * 2];\n        y1 = points[(i * 2) + 1];\n\n        x2 = points[(i + 1) * 2];\n        y2 = points[((i + 1) * 2) + 1];\n\n        perpx = -(y0 - y1);\n        perpy = x0 - x1;\n\n        dist = Math.sqrt((perpx * perpx) + (perpy * perpy));\n        perpx /= dist;\n        perpy /= dist;\n        perpx *= width;\n        perpy *= width;\n\n        perp1x = -(y1 - y2);\n        perp1y = x1 - x2;\n\n        dist = Math.sqrt((perp1x * perp1x) + (perp1y * perp1y));\n        perp1x /= dist;\n        perp1y /= dist;\n        perp1x *= width;\n        perp1y *= width;\n\n        /* d[x|y](0|1) = the component displacement between points p(0,1|1,2) */\n        const dx0 = x1 - x0;\n        const dy0 = y0 - y1;\n        const dx1 = x1 - x2;\n        const dy1 = y2 - y1;\n\n        /* +ve if internal angle counterclockwise, -ve if internal angle clockwise. */\n        const cross = (dy0 * dx1) - (dy1 * dx0);\n        const clockwise = (cross < 0);\n\n        /* Going nearly straight? */\n        if (Math.abs(cross) < 0.1)\n        {\n            verts.push(\n                x1 - (perpx * innerWeight),\n                y1 - (perpy * innerWeight));\n            verts.push(\n                x1 + (perpx * outerWeight),\n                y1 + (perpy * outerWeight));\n\n            continue;\n        }\n\n        /* p[x|y] is the miter point. pdist is the distance between miter point and p1. */\n        const c1 = ((-perpx + x0) * (-perpy + y1)) - ((-perpx + x1) * (-perpy + y0));\n        const c2 = ((-perp1x + x2) * (-perp1y + y1)) - ((-perp1x + x1) * (-perp1y + y2));\n        const px = ((dx0 * c2) - (dx1 * c1)) / cross;\n        const py = ((dy1 * c1) - (dy0 * c2)) / cross;\n        const pdist = ((px - x1) * (px - x1)) + ((py - y1) * (py - y1));\n\n        /* Inner miter point */\n        const imx = x1 + ((px - x1) * innerWeight);\n        const imy = y1 + ((py - y1) * innerWeight);\n        /* Outer miter point */\n        const omx = x1 - ((px - x1) * outerWeight);\n        const omy = y1 - ((py - y1) * outerWeight);\n\n        /* Is the inside miter point too far away, creating a spike? */\n        const smallerInsideSegmentSq = Math.min((dx0 * dx0) + (dy0 * dy0), (dx1 * dx1) + (dy1 * dy1));\n        const insideWeight = clockwise ? innerWeight : outerWeight;\n        const smallerInsideDiagonalSq = smallerInsideSegmentSq + (insideWeight * insideWeight * widthSquared);\n        const insideMiterOk = pdist <= smallerInsideDiagonalSq;\n\n        if (insideMiterOk)\n        {\n            if (style.join === LINE_JOIN.BEVEL || pdist / widthSquared > miterLimitSquared)\n            {\n                if (clockwise) /* rotating at inner angle */\n                {\n                    verts.push(imx, imy);// inner miter point\n                    verts.push(x1 + (perpx * outerWeight), y1 + (perpy * outerWeight));// first segment's outer vertex\n                    verts.push(imx, imy);// inner miter point\n                    verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight));// second segment's outer vertex\n                }\n                else /* rotating at outer angle */\n                {\n                    verts.push(x1 - (perpx * innerWeight), y1 - (perpy * innerWeight));// first segment's inner vertex\n                    verts.push(omx, omy);// outer miter point\n                    verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight));// second segment's outer vertex\n                    verts.push(omx, omy);// outer miter point\n                }\n\n                indexCount += 2;\n            }\n            else if (style.join === LINE_JOIN.ROUND)\n            {\n                if (clockwise) /* arc is outside */\n                {\n                    verts.push(imx, imy);\n                    verts.push(x1 + (perpx * outerWeight), y1 + (perpy * outerWeight));\n\n                    indexCount += round(\n                        x1, y1,\n                        x1 + (perpx * outerWeight), y1 + (perpy * outerWeight),\n                        x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight),\n                        verts, true\n                    ) + 4;\n\n                    verts.push(imx, imy);\n                    verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight));\n                }\n                else /* arc is inside */\n                {\n                    verts.push(x1 - (perpx * innerWeight), y1 - (perpy * innerWeight));\n                    verts.push(omx, omy);\n\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpx * innerWeight), y1 - (perpy * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false\n                    ) + 4;\n\n                    verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight));\n                    verts.push(omx, omy);\n                }\n            }\n            else\n            {\n                verts.push(imx, imy);\n                verts.push(omx, omy);\n            }\n        }\n        else // inside miter is NOT ok\n        {\n            verts.push(x1 - (perpx * innerWeight), y1 - (perpy * innerWeight)); // first segment's inner vertex\n            verts.push(x1 + (perpx * outerWeight), y1 + (perpy * outerWeight)); // first segment's outer vertex\n            if (style.join === LINE_JOIN.BEVEL || pdist / widthSquared > miterLimitSquared)\n            {\n                // Nothing needed\n            }\n            else if (style.join === LINE_JOIN.ROUND)\n            {\n                if (clockwise) /* arc is outside */\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 + (perpx * outerWeight), y1 + (perpy * outerWeight),\n                        x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight),\n                        verts, true\n                    ) + 2;\n                }\n                else /* arc is inside */\n                {\n                    indexCount += round(\n                        x1, y1,\n                        x1 - (perpx * innerWeight), y1 - (perpy * innerWeight),\n                        x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                        verts, false\n                    ) + 2;\n                }\n            }\n            else\n            {\n                if (clockwise)\n                {\n                    verts.push(omx, omy); // inner miter point\n                    verts.push(omx, omy); // inner miter point\n                }\n                else\n                {\n                    verts.push(imx, imy); // outer miter point\n                    verts.push(imx, imy); // outer miter point\n                }\n                indexCount += 2;\n            }\n            verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight)); // second segment's inner vertex\n            verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight)); // second segment's outer vertex\n            indexCount += 2;\n        }\n    }\n\n    x0 = points[(length - 2) * 2];\n    y0 = points[((length - 2) * 2) + 1];\n\n    x1 = points[(length - 1) * 2];\n    y1 = points[((length - 1) * 2) + 1];\n\n    perpx = -(y0 - y1);\n    perpy = x0 - x1;\n\n    dist = Math.sqrt((perpx * perpx) + (perpy * perpy));\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n\n    verts.push(x1 - (perpx * innerWeight), y1 - (perpy * innerWeight));\n    verts.push(x1 + (perpx * outerWeight), y1 + (perpy * outerWeight));\n\n    if (!closedShape)\n    {\n        if (style.cap === LINE_CAP.ROUND)\n        {\n            indexCount += round(\n                x1 - (perpx * (innerWeight - outerWeight) * 0.5),\n                y1 - (perpy * (innerWeight - outerWeight) * 0.5),\n                x1 - (perpx * innerWeight),\n                y1 - (perpy * innerWeight),\n                x1 + (perpx * outerWeight),\n                y1 + (perpy * outerWeight),\n                verts,\n                false\n            ) + 2;\n        }\n        else if (style.cap === LINE_CAP.SQUARE)\n        {\n            indexCount += square(x1, y1, perpx, perpy, innerWeight, outerWeight, false, verts);\n        }\n    }\n\n    const indices = graphicsGeometry.indices;\n    const eps2 = GRAPHICS_CURVES.epsilon * GRAPHICS_CURVES.epsilon;\n\n    // indices.push(indexStart);\n    for (let i = indexStart; i < indexCount + indexStart - 2; ++i)\n    {\n        x0 = verts[(i * 2)];\n        y0 = verts[(i * 2) + 1];\n\n        x1 = verts[(i + 1) * 2];\n        y1 = verts[((i + 1) * 2) + 1];\n\n        x2 = verts[(i + 2) * 2];\n        y2 = verts[((i + 2) * 2) + 1];\n\n        /* Skip zero area triangles */\n        if (Math.abs((x0 * (y1 - y2)) + (x1 * (y2 - y0)) + (x2 * (y0 - y1))) < eps2)\n        {\n            continue;\n        }\n\n        indices.push(i, i + 1, i + 2);\n    }\n}\n\n/**\n * Builds a line to draw using the gl.drawArrays(gl.LINES) method\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nfunction buildNativeLine(graphicsData: GraphicsData, graphicsGeometry: GraphicsGeometry): void\n{\n    let i = 0;\n\n    const shape = graphicsData.shape as Polygon;\n    const points = graphicsData.points || shape.points;\n    const closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;\n\n    if (points.length === 0) return;\n\n    const verts = graphicsGeometry.points;\n    const indices = graphicsGeometry.indices;\n    const length = points.length / 2;\n\n    const startIndex = verts.length / 2;\n    let currentIndex = startIndex;\n\n    verts.push(points[0], points[1]);\n\n    for (i = 1; i < length; i++)\n    {\n        verts.push(points[i * 2], points[(i * 2) + 1]);\n        indices.push(currentIndex, currentIndex + 1);\n\n        currentIndex++;\n    }\n\n    if (closedShape)\n    {\n        indices.push(currentIndex, startIndex);\n    }\n}\n\n/**\n * Builds a line to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output\n */\nexport function buildLine(graphicsData: GraphicsData, graphicsGeometry: GraphicsGeometry): void\n{\n    if (graphicsData.lineStyle.native)\n    {\n        buildNativeLine(graphicsData, graphicsGeometry);\n    }\n    else\n    {\n        buildNonNativeLine(graphicsData, graphicsGeometry);\n    }\n}\n","import { GRAPHICS_CURVES } from '../const';\nimport { PI_2 } from '@pixi/math';\n\ninterface IArcLikeShape {\n    cx: number;\n    cy: number;\n    radius: number;\n    startAngle: number;\n    endAngle: number;\n    anticlockwise: boolean;\n}\n\n/**\n * Utilities for arc curves.\n *\n * @private\n */\nexport class ArcUtils\n{\n    /**\n     * The arcTo() method creates an arc/curve between two tangents on the canvas.\n     *\n     * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n     *\n     * @private\n     * @param x1 - The x-coordinate of the beginning of the arc\n     * @param y1 - The y-coordinate of the beginning of the arc\n     * @param x2 - The x-coordinate of the end of the arc\n     * @param y2 - The y-coordinate of the end of the arc\n     * @param radius - The radius of the arc\n     * @return - If the arc length is valid, return center of circle, radius and other info otherwise `null`.\n     */\n    static curveTo(x1: number, y1: number, x2: number, y2: number, radius: number, points: Array<number>): IArcLikeShape\n    {\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        const a1 = fromY - y1;\n        const b1 = fromX - x1;\n        const a2 = y2 - y1;\n        const b2 = x2 - x1;\n        const mm = Math.abs((a1 * b2) - (b1 * a2));\n\n        if (mm < 1.0e-8 || radius === 0)\n        {\n            if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1)\n            {\n                points.push(x1, y1);\n            }\n\n            return null;\n        }\n\n        const dd = (a1 * a1) + (b1 * b1);\n        const cc = (a2 * a2) + (b2 * b2);\n        const tt = (a1 * a2) + (b1 * b2);\n        const k1 = radius * Math.sqrt(dd) / mm;\n        const k2 = radius * Math.sqrt(cc) / mm;\n        const j1 = k1 * tt / dd;\n        const j2 = k2 * tt / cc;\n        const cx = (k1 * b2) + (k2 * b1);\n        const cy = (k1 * a2) + (k2 * a1);\n        const px = b1 * (k2 + j1);\n        const py = a1 * (k2 + j1);\n        const qx = b2 * (k1 + j2);\n        const qy = a2 * (k1 + j2);\n        const startAngle = Math.atan2(py - cy, px - cx);\n        const endAngle = Math.atan2(qy - cy, qx - cx);\n\n        return {\n            cx: (cx + x1),\n            cy: (cy + y1),\n            radius,\n            startAngle,\n            endAngle,\n            anticlockwise: (b1 * a2 > b2 * a1),\n        };\n    }\n\n    /* eslint-disable max-len */\n    /**\n     * The arc method creates an arc/curve (used to create circles, or parts of circles).\n     *\n     * @private\n     * @param startX - Start x location of arc\n     * @param startY - Start y location of arc\n     * @param cx - The x-coordinate of the center of the circle\n     * @param cy - The y-coordinate of the center of the circle\n     * @param radius - The radius of the circle\n     * @param startAngle - The starting angle, in radians (0 is at the 3 o'clock position\n     *  of the arc's circle)\n     * @param endAngle - The ending angle, in radians\n     * @param anticlockwise - Specifies whether the drawing should be\n     *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true\n     *  indicates counter-clockwise.\n     * @param points - Collection of points to add to\n     */\n    static arc(_startX: number, _startY: number, cx: number, cy: number, radius: number,\n        startAngle: number, endAngle: number, _anticlockwise: boolean, points: Array<number>): void\n    {\n        const sweep = endAngle - startAngle;\n        const n = GRAPHICS_CURVES._segmentsCount(\n            Math.abs(sweep) * radius,\n            Math.ceil(Math.abs(sweep) / PI_2) * 40\n        );\n\n        const theta = (sweep) / (n * 2);\n        const theta2 = theta * 2;\n        const cTheta = Math.cos(theta);\n        const sTheta = Math.sin(theta);\n        const segMinus = n - 1;\n        const remainder = (segMinus % 1) / segMinus;\n\n        for (let i = 0; i <= segMinus; ++i)\n        {\n            const real = i + (remainder * i);\n            const angle = ((theta) + startAngle + (theta2 * real));\n            const c = Math.cos(angle);\n            const s = -Math.sin(angle);\n\n            points.push(\n                (((cTheta * c) + (sTheta * s)) * radius) + cx,\n                (((cTheta * -s) + (sTheta * c)) * radius) + cy\n            );\n        }\n    }\n    /* eslint-enable max-len */\n}\n","import { GRAPHICS_CURVES } from '../const';\n\n/**\n * Utilities for bezier curves\n *\n * @private\n */\nexport class BezierUtils\n{\n    /**\n     * Calculate length of bezier curve.\n     * Analytical solution is impossible, since it involves an integral that does not integrate in general.\n     * Therefore numerical solution is used.\n     *\n     * @private\n     * @param fromX - Starting point x\n     * @param fromY - Starting point y\n     * @param cpX - Control point x\n     * @param cpY - Control point y\n     * @param cpX2 - Second Control point x\n     * @param cpY2 - Second Control point y\n     * @param toX - Destination point x\n     * @param toY - Destination point y\n     * @return - Length of bezier curve\n     */\n    static curveLength(\n        fromX: number, fromY: number,\n        cpX: number, cpY: number,\n        cpX2: number, cpY2: number,\n        toX: number, toY: number): number\n    {\n        const n = 10;\n        let result = 0.0;\n        let t = 0.0;\n        let t2 = 0.0;\n        let t3 = 0.0;\n        let nt = 0.0;\n        let nt2 = 0.0;\n        let nt3 = 0.0;\n        let x = 0.0;\n        let y = 0.0;\n        let dx = 0.0;\n        let dy = 0.0;\n        let prevX = fromX;\n        let prevY = fromY;\n\n        for (let i = 1; i <= n; ++i)\n        {\n            t = i / n;\n            t2 = t * t;\n            t3 = t2 * t;\n            nt = (1.0 - t);\n            nt2 = nt * nt;\n            nt3 = nt2 * nt;\n\n            x = (nt3 * fromX) + (3.0 * nt2 * t * cpX) + (3.0 * nt * t2 * cpX2) + (t3 * toX);\n            y = (nt3 * fromY) + (3.0 * nt2 * t * cpY) + (3 * nt * t2 * cpY2) + (t3 * toY);\n            dx = prevX - x;\n            dy = prevY - y;\n            prevX = x;\n            prevY = y;\n\n            result += Math.sqrt((dx * dx) + (dy * dy));\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculate the points for a bezier curve and then draws it.\n     *\n     * Ignored from docs since it is not directly exposed.\n     *\n     * @ignore\n     * @param cpX - Control point x\n     * @param cpY - Control point y\n     * @param cpX2 - Second Control point x\n     * @param cpY2 - Second Control point y\n     * @param toX - Destination point x\n     * @param toY - Destination point y\n     * @param points - Path array to push points into\n     */\n    static curveTo(\n        cpX: number, cpY: number,\n        cpX2: number, cpY2: number,\n        toX: number, toY: number,\n        points: Array<number>): void\n    {\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        points.length -= 2;\n\n        const n = GRAPHICS_CURVES._segmentsCount(\n            BezierUtils.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY)\n        );\n\n        let dt = 0;\n        let dt2 = 0;\n        let dt3 = 0;\n        let t2 = 0;\n        let t3 = 0;\n\n        points.push(fromX, fromY);\n\n        for (let i = 1, j = 0; i <= n; ++i)\n        {\n            j = i / n;\n\n            dt = (1 - j);\n            dt2 = dt * dt;\n            dt3 = dt2 * dt;\n\n            t2 = j * j;\n            t3 = t2 * j;\n\n            points.push(\n                (dt3 * fromX) + (3 * dt2 * j * cpX) + (3 * dt * t2 * cpX2) + (t3 * toX),\n                (dt3 * fromY) + (3 * dt2 * j * cpY) + (3 * dt * t2 * cpY2) + (t3 * toY)\n            );\n        }\n    }\n}\n","import { GRAPHICS_CURVES } from '../const';\n\n/**\n * Utilities for quadratic curves.\n *\n * @private\n */\nexport class QuadraticUtils\n{\n    /**\n     * Calculate length of quadratic curve\n     * @see {@link http://www.malczak.linuxpl.com/blog/quadratic-bezier-curve-length/}\n     * for the detailed explanation of math behind this.\n     *\n     * @private\n     * @param fromX - x-coordinate of curve start point\n     * @param fromY - y-coordinate of curve start point\n     * @param cpX - x-coordinate of curve control point\n     * @param cpY - y-coordinate of curve control point\n     * @param toX - x-coordinate of curve end point\n     * @param toY - y-coordinate of curve end point\n     * @return - Length of quadratic curve\n     */\n    static curveLength(\n        fromX: number, fromY: number,\n        cpX: number, cpY: number,\n        toX: number, toY: number): number\n    {\n        const ax = fromX - (2.0 * cpX) + toX;\n        const ay = fromY - (2.0 * cpY) + toY;\n        const bx = (2.0 * cpX) - (2.0 * fromX);\n        const by = (2.0 * cpY) - (2.0 * fromY);\n        const a = 4.0 * ((ax * ax) + (ay * ay));\n        const b = 4.0 * ((ax * bx) + (ay * by));\n        const c = (bx * bx) + (by * by);\n\n        const s = 2.0 * Math.sqrt(a + b + c);\n        const a2 = Math.sqrt(a);\n        const a32 = 2.0 * a * a2;\n        const c2 = 2.0 * Math.sqrt(c);\n        const ba = b / a2;\n\n        return (\n            (a32 * s)\n                + (a2 * b * (s - c2))\n                + (\n                    ((4.0 * c * a) - (b * b))\n                   * Math.log(((2.0 * a2) + ba + s) / (ba + c2))\n                )\n        ) / (4.0 * a32);\n    }\n\n    /**\n     * Calculate the points for a quadratic bezier curve and then draws it.\n     * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n     *\n     * @private\n     * @param cpX - Control point x\n     * @param cpY - Control point y\n     * @param toX - Destination point x\n     * @param toY - Destination point y\n     * @param points - Points to add segments to.\n     */\n    static curveTo(cpX: number, cpY: number, toX: number, toY: number, points: Array<number>): void\n    {\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        const n = GRAPHICS_CURVES._segmentsCount(\n            QuadraticUtils.curveLength(fromX, fromY, cpX, cpY, toX, toY)\n        );\n\n        let xa = 0;\n        let ya = 0;\n\n        for (let i = 1; i <= n; ++i)\n        {\n            const j = i / n;\n\n            xa = fromX + ((cpX - fromX) * j);\n            ya = fromY + ((cpY - fromY) * j);\n\n            points.push(xa + (((cpX + ((toX - cpX) * j)) - xa) * j),\n                ya + (((cpY + ((toY - cpY) * j)) - ya) * j));\n        }\n    }\n}\n","import type { LineStyle } from '../styles/LineStyle';\nimport type { FillStyle } from '../styles/FillStyle';\n\n/**\n * A structure to hold interim batch objects for Graphics.\n *\n * @memberof PIXI.graphicsUtils\n */\nexport class BatchPart\n{\n    public style: LineStyle | FillStyle;\n    public start: number;\n    public size: number;\n    public attribStart: number;\n    public attribSize: number;\n\n    constructor()\n    {\n        this.reset();\n    }\n\n    /** Begin batch part. */\n    public begin(style: LineStyle | FillStyle, startIndex: number, attribStart: number): void\n    {\n        this.reset();\n        this.style = style;\n        this.start = startIndex;\n        this.attribStart = attribStart;\n    }\n\n    /** End batch part. */\n    public end(endIndex: number, endAttrib: number): void\n    {\n        this.attribSize = endAttrib - this.attribStart;\n        this.size = endIndex - this.start;\n    }\n\n    public reset(): void\n    {\n        this.style = null;\n        this.size = 0;\n        this.start = 0;\n        this.attribStart = 0;\n        this.attribSize = 0;\n    }\n}\n","/**\n * Generalized convenience utilities for Graphics.\n *\n * @namespace graphicsUtils\n * @memberof PIXI\n */\n\nimport { buildPoly } from './buildPoly';\nexport { buildPoly };\n\nimport { buildCircle } from './buildCircle';\nexport { buildCircle };\n\nimport { buildRectangle } from './buildRectangle';\nexport { buildRectangle };\n\nimport { buildRoundedRectangle } from './buildRoundedRectangle';\nexport { buildRoundedRectangle };\n\nexport * from './buildLine';\nexport * from './ArcUtils';\nexport * from './BezierUtils';\nexport * from './QuadraticUtils';\nexport * from './BatchPart';\n\n// for type only\nimport { BatchPart } from './BatchPart';\nimport { SHAPES } from '@pixi/math';\nimport { BatchDrawCall } from '@pixi/core';\nimport { IShapeBuildCommand } from './IShapeBuildCommand';\n\n/**\n * Map of fill commands for each shape type.\n *\n * @memberof PIXI.graphicsUtils\n * @member {Object} FILL_COMMANDS\n */\nexport const FILL_COMMANDS: Record<SHAPES, IShapeBuildCommand> = {\n    [SHAPES.POLY]: buildPoly,\n    [SHAPES.CIRC]: buildCircle,\n    [SHAPES.ELIP]: buildCircle,\n    [SHAPES.RECT]: buildRectangle,\n    [SHAPES.RREC]: buildRoundedRectangle,\n};\n\n/**\n * Batch pool, stores unused batches for preventing allocations.\n *\n * @memberof PIXI.graphicsUtils\n * @member {Array<PIXI.graphicsUtils.BatchPart>} BATCH_POOL\n */\nexport const BATCH_POOL: Array<BatchPart> = [];\n\n/**\n * Draw call pool, stores unused draw calls for preventing allocations.\n *\n * @memberof PIXI.graphicsUtils\n * @member {Array<PIXI.BatchDrawCall>} DRAW_CALL_POOL\n */\nexport const DRAW_CALL_POOL: Array<BatchDrawCall> = [];\n","import type { Matrix, SHAPES, IShape } from '@pixi/math';\nimport type { FillStyle } from './styles/FillStyle';\nimport type { LineStyle } from './styles/LineStyle';\n\n/**\n * A class to contain data useful for Graphics objects\n *\n * @memberof PIXI\n */\nexport class GraphicsData\n{\n    /**\n     * The shape object to draw.\n     *\n     * @member {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle}\n     */\n    shape: IShape;\n\n    /** The style of the line. */\n    lineStyle: LineStyle;\n\n    /** The style of the fill. */\n    fillStyle: FillStyle;\n\n    /** The transform matrix. */\n    matrix: Matrix;\n\n    /** The type of the shape, see the Const.Shapes file for all the existing types, */\n    type: SHAPES;\n\n    /** The collection of points. */\n    points: number[] = [];\n\n    /** The collection of holes. */\n\n    holes: Array<GraphicsData> = [];\n\n    /**\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n     * @param fillStyle - the width of the line to draw\n     * @param lineStyle - the color of the line to draw\n     * @param matrix - Transform matrix\n     */\n    constructor(shape: IShape, fillStyle: FillStyle = null, lineStyle: LineStyle = null, matrix: Matrix = null)\n    {\n        this.shape = shape;\n        this.lineStyle = lineStyle;\n        this.fillStyle = fillStyle;\n        this.matrix = matrix;\n        this.type = shape.type;\n    }\n\n    /**\n     * Creates a new GraphicsData object with the same values as this one.\n     *\n     * @return - Cloned GraphicsData object\n     */\n    public clone(): GraphicsData\n    {\n        return new GraphicsData(\n            this.shape,\n            this.fillStyle,\n            this.lineStyle,\n            this.matrix\n        );\n    }\n\n    /** Destroys the Graphics data. */\n    public destroy(): void\n    {\n        this.shape = null;\n        this.holes.length = 0;\n        this.holes = null;\n        this.points.length = 0;\n        this.points = null;\n        this.lineStyle = null;\n        this.fillStyle = null;\n    }\n}\n","import {\n    buildLine,\n    buildPoly,\n    BatchPart,\n    FILL_COMMANDS,\n    BATCH_POOL,\n    DRAW_CALL_POOL,\n} from './utils';\n\nimport {\n    BatchGeometry,\n    BatchDrawCall,\n    BatchTextureArray,\n    BaseTexture,\n    Texture,\n} from '@pixi/core';\n\nimport { DRAW_MODES, WRAP_MODES } from '@pixi/constants';\nimport { SHAPES, Point, Matrix } from '@pixi/math';\nimport { GraphicsData } from './GraphicsData';\nimport { premultiplyTint } from '@pixi/utils';\nimport { Bounds } from '@pixi/display';\n\nimport type { Circle, Ellipse, Polygon, Rectangle, RoundedRectangle, IPointData } from '@pixi/math';\nimport type { FillStyle } from './styles/FillStyle';\nimport type { LineStyle } from './styles/LineStyle';\n\n/*\n * Complex shape type\n * @todo Move to Math shapes\n */\ntype IShape = Circle | Ellipse | Polygon | Rectangle | RoundedRectangle;\n\nconst tmpPoint = new Point();\nconst tmpBounds = new Bounds();\n\n/**\n * The Graphics class contains methods used to draw primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.\n *\n * GraphicsGeometry is designed to not be continually updating the geometry since it's expensive\n * to re-tesselate using **earcut**. Consider using {@link PIXI.Mesh} for this use-case, it's much faster.\n *\n * @memberof PIXI\n */\nexport class GraphicsGeometry extends BatchGeometry\n{\n    /**\n     * The maximum number of points to consider an object \"batchable\",\n     * able to be batched by the renderer's batch system.\n\\    */\n    public static BATCHABLE_SIZE = 100;\n\n    /**\n     * Minimal distance between points that are considered different.\n     * Affects line tesselation.\n     */\n    public closePointEps = 1e-4;\n\n    /** Padding to add to the bounds. */\n    public boundsPadding = 0;\n\n    uvsFloat32: Float32Array = null;\n    indicesUint16: Uint16Array | Uint32Array = null;\n    batchable = false;\n\n    /** An array of points to draw, 2 numbers per point */\n    points: number[] = [];\n\n    /** The collection of colors */\n    colors: number[] = [];\n\n    /** The UVs collection */\n    uvs: number[] = [];\n\n    /** The indices of the vertices */\n    indices: number[] = [];\n\n    /** Reference to the texture IDs. */\n    textureIds: number[] = [];\n\n    /**\n     * The collection of drawn shapes.\n     *\n     * @member {PIXI.GraphicsData[]}\n     */\n    graphicsData: Array<GraphicsData> = [];\n\n    /**\n     * List of current draw calls drived from the batches.\n     *\n     * @member {PIXI.BatchDrawCall[]}\n     */\n    drawCalls: Array<BatchDrawCall> = [];\n\n    /** Batches need to regenerated if the geometry is updated. */\n    batchDirty = -1;\n\n    /**\n     * Intermediate abstract format sent to batch system.\n     * Can be converted to drawCalls or to batchable objects.\n     *\n     * @member {PIXI.graphicsUtils.BatchPart[]}\n     */\n    batches: Array<BatchPart> = [];\n\n    /** Used to detect if the graphics object has changed. */\n    protected dirty = 0;\n\n    /** Used to check if the cache is dirty. */\n    protected cacheDirty = -1;\n\n    /** Used to detect if we cleared the graphicsData. */\n    protected clearDirty = 0;\n\n    /** Index of the last batched shape in the stack of calls. */\n    protected shapeIndex = 0;\n\n    /** Cached bounds. */\n    protected _bounds: Bounds = new Bounds();\n\n    /** The bounds dirty flag. */\n    protected boundsDirty = -1;\n\n    // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n    constructor()\n    {\n        super();\n    }\n\n    /**\n     * Get the current bounds of the graphic geometry.\n     *\n     * @readonly\n     */\n    public get bounds(): Bounds\n    {\n        if (this.boundsDirty !== this.dirty)\n        {\n            this.boundsDirty = this.dirty;\n            this.calculateBounds();\n        }\n\n        return this._bounds;\n    }\n\n    /**\n     * Call if you changed graphicsData manually.\n     * Empties all batch buffers.\n     */\n    protected invalidate(): void\n    {\n        this.boundsDirty = -1;\n        this.dirty++;\n        this.batchDirty++;\n        this.shapeIndex = 0;\n\n        this.points.length = 0;\n        this.colors.length = 0;\n        this.uvs.length = 0;\n        this.indices.length = 0;\n        this.textureIds.length = 0;\n\n        for (let i = 0; i < this.drawCalls.length; i++)\n        {\n            this.drawCalls[i].texArray.clear();\n            DRAW_CALL_POOL.push(this.drawCalls[i]);\n        }\n\n        this.drawCalls.length = 0;\n\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            const batchPart = this.batches[i];\n\n            batchPart.reset();\n            BATCH_POOL.push(batchPart);\n        }\n\n        this.batches.length = 0;\n    }\n\n    /**\n     * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n     *\n     * @return - This GraphicsGeometry object. Good for chaining method calls\n     */\n    public clear(): GraphicsGeometry\n    {\n        if (this.graphicsData.length > 0)\n        {\n            this.invalidate();\n            this.clearDirty++;\n            this.graphicsData.length = 0;\n        }\n\n        return this;\n    }\n\n    /**\n     * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n     *\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n     * @param fillStyle - Defines style of the fill.\n     * @param lineStyle - Defines style of the lines.\n     * @param matrix - Transform applied to the points of the shape.\n     * @return - Returns geometry for chaining.\n     */\n    public drawShape(\n        shape: IShape,\n        fillStyle: FillStyle = null,\n        lineStyle: LineStyle = null,\n        matrix: Matrix = null): GraphicsGeometry\n    {\n        const data = new GraphicsData(shape, fillStyle, lineStyle, matrix);\n\n        this.graphicsData.push(data);\n        this.dirty++;\n\n        return this;\n    }\n\n    /**\n     * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n     *\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n     * @param matrix - Transform applied to the points of the shape.\n     * @return - Returns geometry for chaining.\n     */\n    public drawHole(shape: IShape, matrix: Matrix = null): GraphicsGeometry\n    {\n        if (!this.graphicsData.length)\n        {\n            return null;\n        }\n\n        const data = new GraphicsData(shape, null, null, matrix);\n\n        const lastShape = this.graphicsData[this.graphicsData.length - 1];\n\n        data.lineStyle = lastShape.lineStyle;\n\n        lastShape.holes.push(data);\n\n        this.dirty++;\n\n        return this;\n    }\n\n    /** Destroys the GraphicsGeometry object. */\n    public destroy(): void\n    {\n        super.destroy();\n\n        // destroy each of the GraphicsData objects\n        for (let i = 0; i < this.graphicsData.length; ++i)\n        {\n            this.graphicsData[i].destroy();\n        }\n\n        this.points.length = 0;\n        this.points = null;\n        this.colors.length = 0;\n        this.colors = null;\n        this.uvs.length = 0;\n        this.uvs = null;\n        this.indices.length = 0;\n        this.indices = null;\n        this.indexBuffer.destroy();\n        this.indexBuffer = null;\n        this.graphicsData.length = 0;\n        this.graphicsData = null;\n        this.drawCalls.length = 0;\n        this.drawCalls = null;\n        this.batches.length = 0;\n        this.batches = null;\n        this._bounds = null;\n    }\n\n    /**\n     * Check to see if a point is contained within this geometry.\n     *\n     * @param point - Point to check if it's contained.\n     * @return {Boolean} `true` if the point is contained within geometry.\n     */\n    public containsPoint(point: IPointData): boolean\n    {\n        const graphicsData = this.graphicsData;\n\n        for (let i = 0; i < graphicsData.length; ++i)\n        {\n            const data = graphicsData[i];\n\n            if (!data.fillStyle.visible)\n            {\n                continue;\n            }\n\n            // only deal with fills..\n            if (data.shape)\n            {\n                if (data.matrix)\n                {\n                    data.matrix.applyInverse(point, tmpPoint);\n                }\n                else\n                {\n                    tmpPoint.copyFrom(point);\n                }\n\n                if (data.shape.contains(tmpPoint.x, tmpPoint.y))\n                {\n                    let hitHole = false;\n\n                    if (data.holes)\n                    {\n                        for (let i = 0; i < data.holes.length; i++)\n                        {\n                            const hole = data.holes[i];\n\n                            if (hole.shape.contains(tmpPoint.x, tmpPoint.y))\n                            {\n                                hitHole = true;\n                                break;\n                            }\n                        }\n                    }\n\n                    if (!hitHole)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Generates intermediate batch data. Either gets converted to drawCalls\n     * or used to convert to batch objects directly by the Graphics object.\n     *\n     * @param allow32Indices - Allow using 32-bit indices for preventing artifacts when more that 65535 vertices\n     */\n    updateBatches(allow32Indices?: boolean): void\n    {\n        if (!this.graphicsData.length)\n        {\n            this.batchable = true;\n\n            return;\n        }\n\n        if (!this.validateBatching())\n        {\n            return;\n        }\n\n        this.cacheDirty = this.dirty;\n\n        const uvs = this.uvs;\n        const graphicsData = this.graphicsData;\n\n        let batchPart: BatchPart = null;\n\n        let currentStyle = null;\n\n        if (this.batches.length > 0)\n        {\n            batchPart = this.batches[this.batches.length - 1];\n            currentStyle = batchPart.style;\n        }\n\n        for (let i = this.shapeIndex; i < graphicsData.length; i++)\n        {\n            this.shapeIndex++;\n\n            const data = graphicsData[i];\n            const fillStyle = data.fillStyle;\n            const lineStyle = data.lineStyle;\n            const command = FILL_COMMANDS[data.type];\n\n            // build out the shapes points..\n            command.build(data);\n\n            if (data.matrix)\n            {\n                this.transformPoints(data.points, data.matrix);\n            }\n\n            if (fillStyle.visible || lineStyle.visible)\n            {\n                this.processHoles(data.holes);\n            }\n\n            for (let j = 0; j < 2; j++)\n            {\n                const style = (j === 0) ? fillStyle : lineStyle;\n\n                if (!style.visible) continue;\n\n                const nextTexture = style.texture.baseTexture;\n                const index = this.indices.length;\n                const attribIndex = this.points.length / 2;\n\n                nextTexture.wrapMode = WRAP_MODES.REPEAT;\n\n                if (j === 0)\n                {\n                    this.processFill(data);\n                }\n                else\n                {\n                    this.processLine(data);\n                }\n\n                const size = (this.points.length / 2) - attribIndex;\n\n                if (size === 0) continue;\n                // close batch if style is different\n                if (batchPart && !this._compareStyles(currentStyle, style))\n                {\n                    batchPart.end(index, attribIndex);\n                    batchPart = null;\n                }\n                // spawn new batch if its first batch or previous was closed\n                if (!batchPart)\n                {\n                    batchPart = BATCH_POOL.pop() || new BatchPart();\n                    batchPart.begin(style, index, attribIndex);\n                    this.batches.push(batchPart);\n                    currentStyle = style;\n                }\n\n                this.addUvs(this.points, uvs, style.texture, attribIndex, size, style.matrix);\n            }\n        }\n\n        const index = this.indices.length;\n        const attrib = this.points.length / 2;\n\n        if (batchPart)\n        {\n            batchPart.end(index, attrib);\n        }\n\n        if (this.batches.length === 0)\n        {\n            // there are no visible styles in GraphicsData\n            // its possible that someone wants Graphics just for the bounds\n            this.batchable = true;\n\n            return;\n        }\n\n        // prevent allocation when length is same as buffer\n        if (this.indicesUint16 && this.indices.length === this.indicesUint16.length)\n        {\n            this.indicesUint16.set(this.indices);\n        }\n        else\n        {\n            const need32\n                = attrib > 0xffff && allow32Indices;\n\n            this.indicesUint16 = need32 ? new Uint32Array(this.indices) : new Uint16Array(this.indices);\n        }\n\n        // TODO make this a const..\n        this.batchable = this.isBatchable();\n\n        if (this.batchable)\n        {\n            this.packBatches();\n        }\n        else\n        {\n            this.buildDrawCalls();\n        }\n    }\n\n    /**\n     * Affinity check\n     *\n     * @param styleA\n     * @param styleB\n     */\n    protected _compareStyles(styleA: FillStyle | LineStyle, styleB: FillStyle | LineStyle): boolean\n    {\n        if (!styleA || !styleB)\n        {\n            return false;\n        }\n\n        if (styleA.texture.baseTexture !== styleB.texture.baseTexture)\n        {\n            return false;\n        }\n\n        if (styleA.color + styleA.alpha !== styleB.color + styleB.alpha)\n        {\n            return false;\n        }\n\n        if (!!(styleA as LineStyle).native !== !!(styleB as LineStyle).native)\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    /** Test geometry for batching process. */\n    protected validateBatching(): boolean\n    {\n        if (this.dirty === this.cacheDirty || !this.graphicsData.length)\n        {\n            return false;\n        }\n\n        for (let i = 0, l = this.graphicsData.length; i < l; i++)\n        {\n            const data = this.graphicsData[i];\n            const fill = data.fillStyle;\n            const line = data.lineStyle;\n\n            if (fill && !fill.texture.baseTexture.valid) return false;\n            if (line && !line.texture.baseTexture.valid) return false;\n        }\n\n        return true;\n    }\n\n    /** Offset the indices so that it works with the batcher. */\n    protected packBatches(): void\n    {\n        this.batchDirty++;\n        this.uvsFloat32 = new Float32Array(this.uvs);\n\n        const batches = this.batches;\n\n        for (let i = 0, l = batches.length; i < l; i++)\n        {\n            const batch = batches[i];\n\n            for (let j = 0; j < batch.size; j++)\n            {\n                const index = batch.start + j;\n\n                this.indicesUint16[index] = this.indicesUint16[index] - batch.attribStart;\n            }\n        }\n    }\n\n    /**\n     * Checks to see if this graphics geometry can be batched.\n     * Currently it needs to be small enough and not contain any native lines.\n     */\n    protected isBatchable(): boolean\n    {\n        // prevent heavy mesh batching\n        if (this.points.length > 0xffff * 2)\n        {\n            return false;\n        }\n\n        const batches = this.batches;\n\n        for (let i = 0; i < batches.length; i++)\n        {\n            if ((batches[i].style as LineStyle).native)\n            {\n                return false;\n            }\n        }\n\n        return (this.points.length < GraphicsGeometry.BATCHABLE_SIZE * 2);\n    }\n\n    /** Converts intermediate batches data to drawCalls. */\n    protected buildDrawCalls(): void\n    {\n        let TICK = ++BaseTexture._globalBatch;\n\n        for (let i = 0; i < this.drawCalls.length; i++)\n        {\n            this.drawCalls[i].texArray.clear();\n            DRAW_CALL_POOL.push(this.drawCalls[i]);\n        }\n\n        this.drawCalls.length = 0;\n\n        const colors = this.colors;\n        const textureIds = this.textureIds;\n\n        let currentGroup: BatchDrawCall =  DRAW_CALL_POOL.pop();\n\n        if (!currentGroup)\n        {\n            currentGroup = new BatchDrawCall();\n            currentGroup.texArray = new BatchTextureArray();\n        }\n        currentGroup.texArray.count = 0;\n        currentGroup.start = 0;\n        currentGroup.size = 0;\n        currentGroup.type = DRAW_MODES.TRIANGLES;\n\n        let textureCount = 0;\n        let currentTexture = null;\n        let textureId = 0;\n        let native = false;\n        let drawMode = DRAW_MODES.TRIANGLES;\n\n        let index = 0;\n\n        this.drawCalls.push(currentGroup);\n\n        // TODO - this can be simplified\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            const data = this.batches[i];\n\n            // TODO add some full on MAX_TEXTURE CODE..\n            const MAX_TEXTURES = 8;\n\n            // Forced cast for checking `native` without errors\n            const style = data.style as LineStyle;\n\n            const nextTexture = style.texture.baseTexture;\n\n            if (native !== !!style.native)\n            {\n                native = !!style.native;\n                drawMode = native ? DRAW_MODES.LINES : DRAW_MODES.TRIANGLES;\n\n                // force the batch to break!\n                currentTexture = null;\n                textureCount = MAX_TEXTURES;\n                TICK++;\n            }\n\n            if (currentTexture !== nextTexture)\n            {\n                currentTexture = nextTexture;\n\n                if (nextTexture._batchEnabled !== TICK)\n                {\n                    if (textureCount === MAX_TEXTURES)\n                    {\n                        TICK++;\n\n                        textureCount = 0;\n\n                        if (currentGroup.size > 0)\n                        {\n                            currentGroup = DRAW_CALL_POOL.pop();\n                            if (!currentGroup)\n                            {\n                                currentGroup = new BatchDrawCall();\n                                currentGroup.texArray = new BatchTextureArray();\n                            }\n                            this.drawCalls.push(currentGroup);\n                        }\n\n                        currentGroup.start = index;\n                        currentGroup.size = 0;\n                        currentGroup.texArray.count = 0;\n                        currentGroup.type = drawMode;\n                    }\n\n                    // TODO add this to the render part..\n                    // Hack! Because texture has protected `touched`\n                    nextTexture.touched = 1;// touch;\n\n                    nextTexture._batchEnabled = TICK;\n                    nextTexture._batchLocation = textureCount;\n                    nextTexture.wrapMode = WRAP_MODES.REPEAT;\n\n                    currentGroup.texArray.elements[currentGroup.texArray.count++] = nextTexture;\n                    textureCount++;\n                }\n            }\n\n            currentGroup.size += data.size;\n            index += data.size;\n\n            textureId = nextTexture._batchLocation;\n\n            this.addColors(colors, style.color, style.alpha, data.attribSize, data.attribStart);\n            this.addTextureIds(textureIds, textureId, data.attribSize, data.attribStart);\n        }\n\n        BaseTexture._globalBatch = TICK;\n\n        // upload..\n        // merge for now!\n        this.packAttributes();\n    }\n\n    /** Packs attributes to single buffer. */\n    protected packAttributes(): void\n    {\n        const verts = this.points;\n        const uvs = this.uvs;\n        const colors = this.colors;\n        const textureIds = this.textureIds;\n\n        // verts are 2 positions.. so we * by 3 as there are 6 properties.. then 4 cos its bytes\n        const glPoints = new ArrayBuffer(verts.length * 3 * 4);\n        const f32 = new Float32Array(glPoints);\n        const u32 = new Uint32Array(glPoints);\n\n        let p = 0;\n\n        for (let i = 0; i < verts.length / 2; i++)\n        {\n            f32[p++] = verts[i * 2];\n            f32[p++] = verts[(i * 2) + 1];\n\n            f32[p++] = uvs[i * 2];\n            f32[p++] = uvs[(i * 2) + 1];\n\n            u32[p++] = colors[i];\n\n            f32[p++] = textureIds[i];\n        }\n\n        this._buffer.update(glPoints);\n        this._indexBuffer.update(this.indicesUint16);\n    }\n\n    /** Process fill part of Graphics. */\n    protected processFill(data: GraphicsData): void\n    {\n        if (data.holes.length)\n        {\n            buildPoly.triangulate(data, this);\n        }\n        else\n        {\n            const command = FILL_COMMANDS[data.type];\n\n            command.triangulate(data, this);\n        }\n    }\n\n    /** Process line part of Graphics. */\n    protected processLine(data: GraphicsData): void\n    {\n        buildLine(data, this);\n\n        for (let i = 0; i < data.holes.length; i++)\n        {\n            buildLine(data.holes[i], this);\n        }\n    }\n\n    /** Process the holes data. */\n    protected processHoles(holes: Array<GraphicsData>): void\n    {\n        for (let i = 0; i < holes.length; i++)\n        {\n            const hole = holes[i];\n            const command = FILL_COMMANDS[hole.type];\n\n            command.build(hole);\n\n            if (hole.matrix)\n            {\n                this.transformPoints(hole.points, hole.matrix);\n            }\n        }\n    }\n\n    /** Update the local bounds of the object. Expensive to use performance-wise. */\n    protected calculateBounds(): void\n    {\n        const bounds = this._bounds;\n        const sequenceBounds = tmpBounds;\n        let curMatrix = Matrix.IDENTITY;\n\n        this._bounds.clear();\n        sequenceBounds.clear();\n\n        for (let i = 0; i < this.graphicsData.length; i++)\n        {\n            const data = this.graphicsData[i];\n            const shape = data.shape;\n            const type = data.type;\n            const lineStyle = data.lineStyle;\n            const nextMatrix = data.matrix || Matrix.IDENTITY;\n            let lineWidth = 0.0;\n\n            if (lineStyle && lineStyle.visible)\n            {\n                lineWidth = lineStyle.width * Math.max(0, lineStyle.alignment);\n            }\n\n            if (curMatrix !== nextMatrix)\n            {\n                if (!sequenceBounds.isEmpty())\n                {\n                    bounds.addBoundsMatrix(sequenceBounds, curMatrix);\n                    sequenceBounds.clear();\n                }\n                curMatrix = nextMatrix;\n            }\n\n            if (type === SHAPES.RECT || type === SHAPES.RREC)\n            {\n                const rect = shape as Rectangle | RoundedRectangle;\n\n                sequenceBounds.addFramePad(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height,\n                    lineWidth, lineWidth);\n            }\n            else if (type === SHAPES.CIRC)\n            {\n                const circle = shape as Circle;\n\n                sequenceBounds.addFramePad(circle.x, circle.y, circle.x, circle.y,\n                    circle.radius + lineWidth, circle.radius + lineWidth);\n            }\n            else if (type === SHAPES.ELIP)\n            {\n                const ellipse = shape as Ellipse;\n\n                sequenceBounds.addFramePad(ellipse.x, ellipse.y, ellipse.x, ellipse.y,\n                    ellipse.width + lineWidth, ellipse.height + lineWidth);\n            }\n            else\n            {\n                const poly = shape as Polygon;\n                // adding directly to the bounds\n\n                bounds.addVerticesMatrix(curMatrix, (poly.points as any), 0, poly.points.length, lineWidth, lineWidth);\n            }\n        }\n\n        if (!sequenceBounds.isEmpty())\n        {\n            bounds.addBoundsMatrix(sequenceBounds, curMatrix);\n        }\n\n        bounds.pad(this.boundsPadding, this.boundsPadding);\n    }\n\n    /**\n     * Transform points using matrix.\n     *\n     * @param points - Points to transform\n     * @param matrix - Transform matrix\n     */\n    protected transformPoints(points: Array<number>, matrix: Matrix): void\n    {\n        for (let i = 0; i < points.length / 2; i++)\n        {\n            const x = points[(i * 2)];\n            const y = points[(i * 2) + 1];\n\n            points[(i * 2)] = (matrix.a * x) + (matrix.c * y) + matrix.tx;\n            points[(i * 2) + 1] = (matrix.b * x) + (matrix.d * y) + matrix.ty;\n        }\n    }\n\n    /**\n     * Add colors.\n     *\n     * @param colors - List of colors to add to\n     * @param color - Color to add\n     * @param alpha - Alpha to use\n     * @param size - Number of colors to add\n     * @param offset\n     */\n    protected addColors(\n        colors: Array<number>,\n        color: number,\n        alpha: number,\n        size: number,\n        offset = 0): void\n    {\n        // TODO use the premultiply bits Ivan added\n        const rgb = (color >> 16) + (color & 0xff00) + ((color & 0xff) << 16);\n\n        const rgba =  premultiplyTint(rgb, alpha);\n\n        colors.length = Math.max(colors.length, offset + size);\n\n        for (let i = 0; i < size; i++)\n        {\n            colors[offset + i] = rgba;\n        }\n    }\n\n    /** Add texture id that the shader/fragment wants to use. */\n    protected addTextureIds(\n        textureIds: Array<number>,\n        id: number,\n        size: number,\n        offset = 0): void\n    {\n        textureIds.length = Math.max(textureIds.length, offset + size);\n\n        for (let i = 0; i < size; i++)\n        {\n            textureIds[offset + i] = id;\n        }\n    }\n\n    /**\n     * Generates the UVs for a shape.\n     *\n     * @param verts - Vertices\n     * @param uvs - UVs\n     * @param texture - Reference to Texture\n     * @param start - Index buffer start index.\n     * @param size - The size/length for index buffer.\n     * @param matrix - Optional transform for all points.\n     */\n    protected addUvs(\n        verts: Array<number>,\n        uvs: Array<number>,\n        texture: Texture,\n        start: number,\n        size: number,\n        matrix: Matrix = null): void\n    {\n        let index = 0;\n        const uvsStart = uvs.length;\n        const frame = texture.frame;\n\n        while (index < size)\n        {\n            let x = verts[(start + index) * 2];\n            let y = verts[((start + index) * 2) + 1];\n\n            if (matrix)\n            {\n                const nx = (matrix.a * x) + (matrix.c * y) + matrix.tx;\n\n                y = (matrix.b * x) + (matrix.d * y) + matrix.ty;\n                x = nx;\n            }\n\n            index++;\n\n            uvs.push(x / frame.width, y / frame.height);\n        }\n\n        const baseTexture = texture.baseTexture;\n\n        if (frame.width < baseTexture.width\n            || frame.height < baseTexture.height)\n        {\n            this.adjustUvs(uvs, texture, uvsStart, size);\n        }\n    }\n\n    /**\n     * Modify uvs array according to position of texture region\n     * Does not work with rotated or trimmed textures\n     *\n     * @param uvs - array\n     * @param texture - region\n     * @param start - starting index for uvs\n     * @param size - how many points to adjust\n     */\n    protected adjustUvs(uvs: Array<number>, texture: Texture, start: number, size: number): void\n    {\n        const baseTexture = texture.baseTexture;\n        const eps = 1e-6;\n        const finish = start + (size * 2);\n        const frame = texture.frame;\n        const scaleX = frame.width / baseTexture.width;\n        const scaleY = frame.height / baseTexture.height;\n        let offsetX = frame.x / frame.width;\n        let offsetY = frame.y / frame.height;\n        let minX = Math.floor(uvs[start] + eps);\n        let minY = Math.floor(uvs[start + 1] + eps);\n\n        for (let i = start + 2; i < finish; i += 2)\n        {\n            minX = Math.min(minX, Math.floor(uvs[i] + eps));\n            minY = Math.min(minY, Math.floor(uvs[i + 1] + eps));\n        }\n        offsetX -= minX;\n        offsetY -= minY;\n        for (let i = start; i < finish; i += 2)\n        {\n            uvs[i] = (uvs[i] + offsetX) * scaleX;\n            uvs[i + 1] = (uvs[i + 1] + offsetY) * scaleY;\n        }\n    }\n}\n","import { FillStyle } from './FillStyle';\nimport { LINE_JOIN, LINE_CAP } from '../const';\n\n/**\n * Represents the line style for Graphics.\n *\n * @memberof PIXI\n */\nexport class LineStyle extends FillStyle\n{\n    /** The width (thickness) of any lines drawn. */\n    public width = 0;\n\n    /** The alignment of any lines drawn (0.5 = middle, 1 = outer, 0 = inner). WebGL only. */\n    public alignment = 0.5;\n\n    /** If true the lines will be draw using LINES instead of TRIANGLE_STRIP. */\n    public native = false;\n\n    /**\n     * Line cap style.\n     *\n     * @member {PIXI.LINE_CAP}\n     * @default PIXI.LINE_CAP.BUTT\n     */\n    public cap = LINE_CAP.BUTT;\n\n    /**\n     * Line join style.\n     *\n     * @member {PIXI.LINE_JOIN}\n     * @default PIXI.LINE_JOIN.MITER\n     */\n    public join = LINE_JOIN.MITER;\n\n    /** Miter limit. */\n    public miterLimit = 10;\n\n    /** Clones the object. */\n    public clone(): LineStyle\n    {\n        const obj = new LineStyle();\n\n        obj.color = this.color;\n        obj.alpha = this.alpha;\n        obj.texture = this.texture;\n        obj.matrix = this.matrix;\n        obj.visible = this.visible;\n        obj.width = this.width;\n        obj.alignment = this.alignment;\n        obj.native = this.native;\n        obj.cap = this.cap;\n        obj.join = this.join;\n        obj.miterLimit = this.miterLimit;\n\n        return obj;\n    }\n\n    /** Reset the line style to default. */\n    public reset(): void\n    {\n        super.reset();\n\n        // Override default line style color\n        this.color = 0x0;\n\n        this.alignment = 0.5;\n        this.width = 0;\n        this.native = false;\n    }\n}\n","import {\n    Circle,\n    Ellipse,\n    PI_2,\n    Point,\n    Polygon,\n    Rectangle,\n    RoundedRectangle,\n    Matrix,\n    SHAPES,\n} from '@pixi/math';\n\nimport { Texture, UniformGroup, State, Renderer, BatchDrawCall, Shader } from '@pixi/core';\nimport { BezierUtils, QuadraticUtils, ArcUtils } from './utils';\nimport { hex2rgb } from '@pixi/utils';\nimport { GraphicsGeometry } from './GraphicsGeometry';\nimport { FillStyle } from './styles/FillStyle';\nimport { LineStyle } from './styles/LineStyle';\nimport { BLEND_MODES } from '@pixi/constants';\nimport { Container } from '@pixi/display';\n\nimport type { IShape, IPointData } from '@pixi/math';\nimport type { IDestroyOptions } from '@pixi/display';\nimport { LINE_JOIN, LINE_CAP } from './const';\n\n/**\n * Batch element computed from Graphics geometry\n */\nexport interface IGraphicsBatchElement {\n    vertexData: Float32Array;\n    blendMode: BLEND_MODES;\n    indices: Uint16Array | Uint32Array;\n    uvs: Float32Array;\n    alpha: number;\n    worldAlpha: number;\n    _batchRGB: number[];\n    _tintRGB: number;\n    _texture: Texture;\n}\n\nexport interface IFillStyleOptions {\n    color?: number;\n    alpha?: number;\n    texture?: Texture;\n    matrix?: Matrix;\n}\n\nexport interface ILineStyleOptions extends IFillStyleOptions {\n    width?: number;\n    alignment?: number;\n    native?: boolean;\n    cap?: LINE_CAP;\n    join?: LINE_JOIN;\n    miterLimit?: number;\n}\n\nconst temp = new Float32Array(3);\n\n// a default shaders map used by graphics..\nconst DEFAULT_SHADERS: {[key: string]: Shader} = {};\n\nexport interface Graphics extends GlobalMixins.Graphics, Container {}\n\n/**\n * The Graphics class is primarily used to render primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.  However, you can also use a Graphics\n * object to build a list of primitives to use as a mask, or as a complex hitArea.\n *\n * Please note that due to legacy naming conventions, the behavior of some functions in this class\n * can be confusing.  Each call to `drawRect()`, `drawPolygon()`, etc. actually stores that primitive\n * in the Geometry class's GraphicsGeometry object for later use in rendering or hit testing - the\n * functions do not directly draw anything to the screen.  Similarly, the `clear()` function doesn't\n * change the screen, it simply resets the list of primitives, which can be useful if you want to\n * rebuild the contents of an existing Graphics object.\n *\n * Once a GraphicsGeometry list is built, you can re-use it in other Geometry objects as\n * an optimization, by passing it into a new Geometry object's constructor.  Because of this\n * ability, it's important to call `destroy()` on Geometry objects once you are done with them, to\n * properly dereference each GraphicsGeometry and prevent memory leaks.\n *\n * @memberof PIXI\n */\nexport class Graphics extends Container\n{\n    /**\n     * New rendering behavior for rounded rectangles: circular arcs instead of quadratic bezier curves.\n     * In the next major release, we'll enable this by default.\n     */\n    public static nextRoundedRectBehavior = false;\n\n    /**\n     * Temporary point to use for containsPoint.\n     *\n     * @private\n     */\n    static _TEMP_POINT = new Point();\n\n    /**\n     * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.\n     * Can be shared between multiple Graphics objects.\n     */\n    public shader: Shader = null;\n\n    /** Renderer plugin for batching */\n    public pluginName = 'batch';\n\n    /**\n     * Current path\n     *\n     * @readonly\n     */\n    public currentPath: Polygon = null;\n\n    /** A collections of batches! These can be drawn by the renderer batch system. */\n    protected batches: Array<IGraphicsBatchElement> = [];\n\n    /** Update dirty for limiting calculating tints for batches. */\n    protected batchTint = -1;\n\n    /** Update dirty for limiting calculating batches.*/\n    protected batchDirty = -1;\n\n    /** Copy of the object vertex data. */\n    protected vertexData: Float32Array = null;\n\n    /** Current fill style. */\n    protected _fillStyle: FillStyle = new FillStyle();\n\n    /** Current line style. */\n    protected _lineStyle: LineStyle = new LineStyle();\n\n    /** Current shape transform matrix. */\n    protected _matrix: Matrix = null;\n\n    /** Current hole mode is enabled. */\n    protected _holeMode = false;\n    protected _transformID: number;\n    protected _tint: number;\n\n    /**\n     * Represents the WebGL state the Graphics required to render, excludes shader and geometry. E.g.,\n     * blend mode, culling, depth testing, direction of rendering triangles, backface, etc.\n     */\n    private state: State = State.for2d();\n    private _geometry: GraphicsGeometry;\n\n    /**\n     * Includes vertex positions, face indices, normals, colors, UVs, and\n     * custom attributes within buffers, reducing the cost of passing all\n     * this data to the GPU. Can be shared between multiple Mesh or Graphics objects.\n     *\n     * @readonly\n     */\n    public get geometry(): GraphicsGeometry\n    {\n        return this._geometry;\n    }\n\n    /**\n     * @param geometry - Geometry to use, if omitted will create a new GraphicsGeometry instance.\n     */\n    constructor(geometry: GraphicsGeometry = null)\n    {\n        super();\n\n        this._geometry = geometry || new GraphicsGeometry();\n        this._geometry.refCount++;\n\n        /**\n         * When cacheAsBitmap is set to true the graphics object will be rendered as if it was a sprite.\n         * This is useful if your graphics element does not change often, as it will speed up the rendering\n         * of the object in exchange for taking up texture memory. It is also useful if you need the graphics\n         * object to be anti-aliased, because it will be rendered using canvas. This is not recommended if\n         * you are constantly redrawing the graphics element.\n         *\n         * @name cacheAsBitmap\n         * @member {boolean}\n         * @memberof PIXI.Graphics#\n         * @default false\n         */\n\n        this._transformID = -1;\n\n        // Set default\n        this.tint = 0xFFFFFF;\n        this.blendMode = BLEND_MODES.NORMAL;\n    }\n\n    /**\n     * Creates a new Graphics object with the same values as this one.\n     * Note that only the geometry of the object is cloned, not its transform (position,scale,etc)\n     *\n     * @return - A clone of the graphics object\n     */\n    public clone(): Graphics\n    {\n        this.finishPoly();\n\n        return new Graphics(this._geometry);\n    }\n\n    /**\n     * The blend mode to be applied to the graphic shape. Apply a value of\n     * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.  Note that, since each\n     * primitive in the GraphicsGeometry list is rendered sequentially, modes\n     * such as `PIXI.BLEND_MODES.ADD` and `PIXI.BLEND_MODES.MULTIPLY` will\n     * be applied per-primitive.\n     *\n     * @default PIXI.BLEND_MODES.NORMAL\n     */\n    public set blendMode(value: BLEND_MODES)\n    {\n        this.state.blendMode = value;\n    }\n\n    public get blendMode(): BLEND_MODES\n    {\n        return this.state.blendMode;\n    }\n\n    /**\n     * The tint applied to each graphic shape. This is a hex value. A value of\n     * 0xFFFFFF will remove any tint effect.\n     *\n     * @default 0xFFFFFF\n     */\n    public get tint(): number\n    {\n        return this._tint;\n    }\n\n    public set tint(value: number)\n    {\n        this._tint = value;\n    }\n\n    /**\n     * The current fill style.\n     *\n     * @readonly\n     */\n    public get fill(): FillStyle\n    {\n        return this._fillStyle;\n    }\n\n    /**\n     * The current line style.\n     *\n     * @readonly\n     */\n    public get line(): LineStyle\n    {\n        return this._lineStyle;\n    }\n\n    /**\n     * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo()\n     * method or the drawCircle() method.\n     *\n     * @param [width=0] - width of the line to draw, will update the objects stored style\n     * @param [color=0x0] - color of the line to draw, will update the objects stored style\n     * @param [alpha=1] - alpha of the line to draw, will update the objects stored style\n     * @param [alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outer).\n     *        WebGL only.\n     * @param [native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n     * @return - This Graphics object. Good for chaining method calls\n     */\n    public lineStyle(width: number, color?: number, alpha?: number, alignment?: number, native?: boolean): this;\n\n    /**\n     * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo()\n     * method or the drawCircle() method.\n     *\n     * @param options - Line style options\n     * @param {number} [options.width=0] - width of the line to draw, will update the objects stored style\n     * @param {number} [options.color=0x0] - color of the line to draw, will update the objects stored style\n     * @param {number} [options.alpha=1] - alpha of the line to draw, will update the objects stored style\n     * @param {number} [options.alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outer).\n     *        WebGL only.\n     * @param {boolean} [options.native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n     * @param {PIXI.LINE_CAP}[options.cap=PIXI.LINE_CAP.BUTT] - line cap style\n     * @param {PIXI.LINE_JOIN}[options.join=PIXI.LINE_JOIN.MITER] - line join style\n     * @param {number}[options.miterLimit=10] - miter limit ratio\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    public lineStyle(options?: ILineStyleOptions): this;\n\n    public lineStyle(options: ILineStyleOptions | number = null,\n        color = 0x0, alpha = 1, alignment = 0.5, native = false): this\n    {\n        // Support non-object params: (width, color, alpha, alignment, native)\n        if (typeof options === 'number')\n        {\n            options = { width: options, color, alpha, alignment, native } as ILineStyleOptions;\n        }\n\n        return this.lineTextureStyle(options);\n    }\n\n    /**\n     * Like line style but support texture for line fill.\n     *\n     * @param options - Collection of options for setting line style.\n     * @param {number} [options.width=0] - width of the line to draw, will update the objects stored style\n     * @param {PIXI.Texture} [options.texture=PIXI.Texture.WHITE] - Texture to use\n     * @param {number} [options.color=0x0] - color of the line to draw, will update the objects stored style.\n     *  Default 0xFFFFFF if texture present.\n     * @param {number} [options.alpha=1] - alpha of the line to draw, will update the objects stored style\n     * @param {PIXI.Matrix} [options.matrix=null] - Texture matrix to transform texture\n     * @param {number} [options.alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outer).\n     *        WebGL only.\n     * @param {boolean} [options.native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n     * @param {PIXI.LINE_CAP}[options.cap=PIXI.LINE_CAP.BUTT] - line cap style\n     * @param {PIXI.LINE_JOIN}[options.join=PIXI.LINE_JOIN.MITER] - line join style\n     * @param {number}[options.miterLimit=10] - miter limit ratio\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    public lineTextureStyle(options: ILineStyleOptions): this\n    {\n        // Apply defaults\n        options = Object.assign({\n            width: 0,\n            texture: Texture.WHITE,\n            color: (options && options.texture) ? 0xFFFFFF : 0x0,\n            alpha: 1,\n            matrix: null,\n            alignment: 0.5,\n            native: false,\n            cap: LINE_CAP.BUTT,\n            join: LINE_JOIN.MITER,\n            miterLimit: 10,\n        }, options);\n\n        if (this.currentPath)\n        {\n            this.startPoly();\n        }\n\n        const visible = options.width > 0 && options.alpha > 0;\n\n        if (!visible)\n        {\n            this._lineStyle.reset();\n        }\n        else\n        {\n            if (options.matrix)\n            {\n                options.matrix = options.matrix.clone();\n                options.matrix.invert();\n            }\n\n            Object.assign(this._lineStyle, { visible }, options);\n        }\n\n        return this;\n    }\n\n    /**\n     * Start a polygon object internally.\n     *\n     * @protected\n     */\n    protected startPoly(): void\n    {\n        if (this.currentPath)\n        {\n            const points = this.currentPath.points;\n            const len = this.currentPath.points.length;\n\n            if (len > 2)\n            {\n                this.drawShape(this.currentPath);\n                this.currentPath = new Polygon();\n                this.currentPath.closeStroke = false;\n                this.currentPath.points.push(points[len - 2], points[len - 1]);\n            }\n        }\n        else\n        {\n            this.currentPath = new Polygon();\n            this.currentPath.closeStroke = false;\n        }\n    }\n\n    /**\n     * Finish the polygon object.\n     *\n     * @protected\n     */\n    finishPoly(): void\n    {\n        if (this.currentPath)\n        {\n            if (this.currentPath.points.length > 2)\n            {\n                this.drawShape(this.currentPath);\n                this.currentPath = null;\n            }\n            else\n            {\n                this.currentPath.points.length = 0;\n            }\n        }\n    }\n\n    /**\n     * Moves the current drawing position to x, y.\n     *\n     * @param x - the X coordinate to move to\n     * @param y - the Y coordinate to move to\n     * @return - This Graphics object. Good for chaining method calls\n     */\n    public moveTo(x: number, y: number): this\n    {\n        this.startPoly();\n        this.currentPath.points[0] = x;\n        this.currentPath.points[1] = y;\n\n        return this;\n    }\n\n    /**\n     * Draws a line using the current line style from the current drawing position to (x, y);\n     * The current drawing position is then set to (x, y).\n     *\n     * @param x - the X coordinate to draw to\n     * @param y - the Y coordinate to draw to\n     * @return - This Graphics object. Good for chaining method calls\n     */\n    public lineTo(x: number, y: number): this\n    {\n        if (!this.currentPath)\n        {\n            this.moveTo(0, 0);\n        }\n\n        // remove duplicates..\n        const points = this.currentPath.points;\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        if (fromX !== x || fromY !== y)\n        {\n            points.push(x, y);\n        }\n\n        return this;\n    }\n\n    /** Initialize the curve */\n    protected _initCurve(x = 0, y = 0): void\n    {\n        if (this.currentPath)\n        {\n            if (this.currentPath.points.length === 0)\n            {\n                this.currentPath.points = [x, y];\n            }\n        }\n        else\n        {\n            this.moveTo(x, y);\n        }\n    }\n\n    /**\n     * Calculate the points for a quadratic bezier curve and then draws it.\n     * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n     *\n     * @param cpX - Control point x\n     * @param cpY - Control point y\n     * @param toX - Destination point x\n     * @param toY - Destination point y\n     * @return - This Graphics object. Good for chaining method calls\n     */\n    public quadraticCurveTo(cpX: number, cpY: number, toX: number, toY: number): this\n    {\n        this._initCurve();\n\n        const points = this.currentPath.points;\n\n        if (points.length === 0)\n        {\n            this.moveTo(0, 0);\n        }\n\n        QuadraticUtils.curveTo(cpX, cpY, toX, toY, points);\n\n        return this;\n    }\n\n    /**\n     * Calculate the points for a bezier curve and then draws it.\n     *\n     * @param cpX - Control point x\n     * @param cpY - Control point y\n     * @param cpX2 - Second Control point x\n     * @param cpY2 - Second Control point y\n     * @param toX - Destination point x\n     * @param toY - Destination point y\n     * @return This Graphics object. Good for chaining method calls\n     */\n    public bezierCurveTo(cpX: number, cpY: number, cpX2: number, cpY2: number, toX: number, toY: number): this\n    {\n        this._initCurve();\n\n        BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);\n\n        return this;\n    }\n\n    /**\n     * The arcTo() method creates an arc/curve between two tangents on the canvas.\n     *\n     * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n     *\n     * @param x1 - The x-coordinate of the first tangent point of the arc\n     * @param y1 - The y-coordinate of the first tangent point of the arc\n     * @param x2 - The x-coordinate of the end of the arc\n     * @param y2 - The y-coordinate of the end of the arc\n     * @param radius - The radius of the arc\n     * @return - This Graphics object. Good for chaining method calls\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this\n    {\n        this._initCurve(x1, y1);\n\n        const points = this.currentPath.points;\n\n        const result = ArcUtils.curveTo(x1, y1, x2, y2, radius, points);\n\n        if (result)\n        {\n            const { cx, cy, radius, startAngle, endAngle, anticlockwise } = result;\n\n            this.arc(cx, cy, radius, startAngle, endAngle, anticlockwise);\n        }\n\n        return this;\n    }\n\n    /**\n     * The arc method creates an arc/curve (used to create circles, or parts of circles).\n     *\n     * @param cx - The x-coordinate of the center of the circle\n     * @param cy - The y-coordinate of the center of the circle\n     * @param radius - The radius of the circle\n     * @param startAngle - The starting angle, in radians (0 is at the 3 o'clock position\n     *  of the arc's circle)\n     * @param endAngle - The ending angle, in radians\n     * @param anticlockwise - Specifies whether the drawing should be\n     *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true\n     *  indicates counter-clockwise.\n     * @return - This Graphics object. Good for chaining method calls\n     */\n    public arc(cx: number, cy: number, radius: number, startAngle: number, endAngle: number, anticlockwise = false): this\n    {\n        if (startAngle === endAngle)\n        {\n            return this;\n        }\n\n        if (!anticlockwise && endAngle <= startAngle)\n        {\n            endAngle += PI_2;\n        }\n        else if (anticlockwise && startAngle <= endAngle)\n        {\n            startAngle += PI_2;\n        }\n\n        const sweep = endAngle - startAngle;\n\n        if (sweep === 0)\n        {\n            return this;\n        }\n\n        const startX = cx + (Math.cos(startAngle) * radius);\n        const startY = cy + (Math.sin(startAngle) * radius);\n        const eps = this._geometry.closePointEps;\n\n        // If the currentPath exists, take its points. Otherwise call `moveTo` to start a path.\n        let points = this.currentPath ? this.currentPath.points : null;\n\n        if (points)\n        {\n            // TODO: make a better fix.\n\n            // We check how far our start is from the last existing point\n            const xDiff = Math.abs(points[points.length - 2] - startX);\n            const yDiff = Math.abs(points[points.length - 1] - startY);\n\n            if (xDiff < eps && yDiff < eps)\n            {\n                // If the point is very close, we don't add it, since this would lead to artifacts\n                // during tessellation due to floating point imprecision.\n            }\n            else\n            {\n                points.push(startX, startY);\n            }\n        }\n        else\n        {\n            this.moveTo(startX, startY);\n            points = this.currentPath.points;\n        }\n\n        ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points);\n\n        return this;\n    }\n\n    /**\n     * Specifies a simple one-color fill that subsequent calls to other Graphics methods\n     * (such as lineTo() or drawCircle()) use when drawing.\n     *\n     * @param color - the color of the fill\n     * @param alpha - the alpha of the fill\n     * @return - This Graphics object. Good for chaining method calls\n     */\n    public beginFill(color = 0, alpha = 1): this\n    {\n        return this.beginTextureFill({ texture: Texture.WHITE, color, alpha });\n    }\n\n    /**\n     * Begin the texture fill\n     *\n     * @param options - Object object.\n     * @param {PIXI.Texture} [options.texture=PIXI.Texture.WHITE] - Texture to fill\n     * @param {number} [options.color=0xffffff] - Background to fill behind texture\n     * @param {number} [options.alpha=1] - Alpha of fill\n     * @param {PIXI.Matrix} [options.matrix=null] - Transform matrix\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    beginTextureFill(options?: IFillStyleOptions): this\n    {\n        // Apply defaults\n        options = Object.assign({\n            texture: Texture.WHITE,\n            color: 0xFFFFFF,\n            alpha: 1,\n            matrix: null,\n        }, options) as IFillStyleOptions;\n\n        if (this.currentPath)\n        {\n            this.startPoly();\n        }\n\n        const visible = options.alpha > 0;\n\n        if (!visible)\n        {\n            this._fillStyle.reset();\n        }\n        else\n        {\n            if (options.matrix)\n            {\n                options.matrix = options.matrix.clone();\n                options.matrix.invert();\n            }\n\n            Object.assign(this._fillStyle, { visible }, options);\n        }\n\n        return this;\n    }\n\n    /**\n     * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.\n     *\n     * @return - This Graphics object. Good for chaining method calls\n     */\n    public endFill(): this\n    {\n        this.finishPoly();\n\n        this._fillStyle.reset();\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle shape.\n     *\n     * @param x - The X coord of the top-left of the rectangle\n     * @param y - The Y coord of the top-left of the rectangle\n     * @param width - The width of the rectangle\n     * @param height - The height of the rectangle\n     * @return - This Graphics object. Good for chaining method calls\n     */\n    public drawRect(x: number, y: number, width: number, height: number): this\n    {\n        return this.drawShape(new Rectangle(x, y, width, height));\n    }\n\n    /**\n     * Draw a rectangle shape with rounded/beveled corners.\n     *\n     * @param x - The X coord of the top-left of the rectangle\n     * @param y - The Y coord of the top-left of the rectangle\n     * @param width - The width of the rectangle\n     * @param height - The height of the rectangle\n     * @param radius - Radius of the rectangle corners\n     * @return - This Graphics object. Good for chaining method calls\n     */\n    public drawRoundedRect(x: number, y: number, width: number, height: number, radius: number): this\n    {\n        return this.drawShape(new RoundedRectangle(x, y, width, height, radius));\n    }\n\n    /**\n     * Draws a circle.\n     *\n     * @param x - The X coordinate of the center of the circle\n     * @param y - The Y coordinate of the center of the circle\n     * @param radius - The radius of the circle\n     * @return - This Graphics object. Good for chaining method calls\n     */\n    public drawCircle(x: number, y: number, radius: number): this\n    {\n        return this.drawShape(new Circle(x, y, radius));\n    }\n\n    /**\n     * Draws an ellipse.\n     *\n     * @param x - The X coordinate of the center of the ellipse\n     * @param y - The Y coordinate of the center of the ellipse\n     * @param width - The half width of the ellipse\n     * @param height - The half height of the ellipse\n     * @return - This Graphics object. Good for chaining method calls\n     */\n    public drawEllipse(x: number, y: number, width: number, height: number): this\n    {\n        return this.drawShape(new Ellipse(x, y, width, height));\n    }\n\n    public drawPolygon(...path: Array<number> | Array<Point>): this\n    public drawPolygon(path: Array<number> | Array<Point> | Polygon): this\n\n    /**\n     * Draws a polygon using the given path.\n     *\n     * @param {number[]|PIXI.Point[]|PIXI.Polygon} path - The path data used to construct the polygon.\n     * @return - This Graphics object. Good for chaining method calls\n     */\n    public drawPolygon(...path: any[]): this\n    {\n        let points: Array<number> | Array<Point>;\n        let closeStroke = true;// !!this._fillStyle;\n\n        const poly = path[0] as Polygon;\n\n        // check if data has points..\n        if (poly.points)\n        {\n            closeStroke = poly.closeStroke;\n            points = poly.points;\n        }\n        else\n        if (Array.isArray(path[0]))\n        {\n            points = path[0];\n        }\n        else\n        {\n            points = path;\n        }\n\n        const shape = new Polygon(points);\n\n        shape.closeStroke = closeStroke;\n\n        this.drawShape(shape);\n\n        return this;\n    }\n\n    /**\n     * Draw any shape.\n     *\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - Shape to draw\n     * @return - This Graphics object. Good for chaining method calls\n     */\n    public drawShape(shape: IShape): this\n    {\n        if (!this._holeMode)\n        {\n            this._geometry.drawShape(\n                shape,\n                this._fillStyle.clone(),\n                this._lineStyle.clone(),\n                this._matrix\n            );\n        }\n        else\n        {\n            this._geometry.drawHole(shape, this._matrix);\n        }\n\n        return this;\n    }\n\n    /**\n     * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n     *\n     * @return - This Graphics object. Good for chaining method calls\n     */\n    public clear(): this\n    {\n        this._geometry.clear();\n        this._lineStyle.reset();\n        this._fillStyle.reset();\n\n        this._boundsID++;\n        this._matrix = null;\n        this._holeMode = false;\n        this.currentPath = null;\n\n        return this;\n    }\n\n    /**\n     * True if graphics consists of one rectangle, and thus, can be drawn like a Sprite and\n     * masked with gl.scissor.\n     *\n     * @returns - True if only 1 rect.\n     */\n    public isFastRect(): boolean\n    {\n        const data = this._geometry.graphicsData;\n\n        return data.length === 1\n            && data[0].shape.type === SHAPES.RECT\n            && !data[0].matrix\n            && !data[0].holes.length\n            && !(data[0].lineStyle.visible && data[0].lineStyle.width);\n    }\n\n    /**\n     * Renders the object using the WebGL renderer\n     *\n     * @param renderer - The renderer\n     */\n    protected _render(renderer: Renderer): void\n    {\n        this.finishPoly();\n\n        const geometry = this._geometry;\n        const hasuint32 = renderer.context.supports.uint32Indices;\n        // batch part..\n        // batch it!\n\n        geometry.updateBatches(hasuint32);\n\n        if (geometry.batchable)\n        {\n            if (this.batchDirty !== geometry.batchDirty)\n            {\n                this._populateBatches();\n            }\n\n            this._renderBatched(renderer);\n        }\n        else\n        {\n            // no batching...\n            renderer.batch.flush();\n\n            this._renderDirect(renderer);\n        }\n    }\n\n    /** Populating batches for rendering. */\n    protected _populateBatches(): void\n    {\n        const geometry = this._geometry;\n        const blendMode = this.blendMode;\n        const len = geometry.batches.length;\n\n        this.batchTint = -1;\n        this._transformID = -1;\n        this.batchDirty = geometry.batchDirty;\n        this.batches.length = len;\n\n        this.vertexData = new Float32Array(geometry.points);\n\n        for (let i = 0; i < len; i++)\n        {\n            const gI = geometry.batches[i];\n            const color = gI.style.color;\n            const vertexData = new Float32Array(this.vertexData.buffer,\n                gI.attribStart * 4 * 2,\n                gI.attribSize * 2);\n\n            const uvs = new Float32Array(geometry.uvsFloat32.buffer,\n                gI.attribStart * 4 * 2,\n                gI.attribSize * 2);\n\n            const indices = new Uint16Array(geometry.indicesUint16.buffer,\n                gI.start * 2,\n                gI.size);\n\n            const batch = {\n                vertexData,\n                blendMode,\n                indices,\n                uvs,\n                _batchRGB: hex2rgb(color) as Array<number>,\n                _tintRGB: color,\n                _texture: gI.style.texture,\n                alpha: gI.style.alpha,\n                worldAlpha: 1 };\n\n            this.batches[i] = batch;\n        }\n    }\n\n    /**\n     * Renders the batches using the BathedRenderer plugin\n     *\n     * @param renderer - The renderer\n     */\n    protected _renderBatched(renderer: Renderer): void\n    {\n        if (!this.batches.length)\n        {\n            return;\n        }\n\n        renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);\n\n        this.calculateVertices();\n        this.calculateTints();\n\n        for (let i = 0, l = this.batches.length; i < l; i++)\n        {\n            const batch = this.batches[i];\n\n            batch.worldAlpha = this.worldAlpha * batch.alpha;\n\n            renderer.plugins[this.pluginName].render(batch);\n        }\n    }\n\n    /**\n     * Renders the graphics direct\n     *\n     * @param renderer - The renderer\n     */\n    protected _renderDirect(renderer: Renderer): void\n    {\n        const shader = this._resolveDirectShader(renderer);\n\n        const geometry = this._geometry;\n        const tint = this.tint;\n        const worldAlpha = this.worldAlpha;\n        const uniforms = shader.uniforms;\n        const drawCalls = geometry.drawCalls;\n\n        // lets set the transfomr\n        uniforms.translationMatrix = this.transform.worldTransform;\n\n        // and then lets set the tint..\n        uniforms.tint[0] = (((tint >> 16) & 0xFF) / 255) * worldAlpha;\n        uniforms.tint[1] = (((tint >> 8) & 0xFF) / 255) * worldAlpha;\n        uniforms.tint[2] = ((tint & 0xFF) / 255) * worldAlpha;\n        uniforms.tint[3] = worldAlpha;\n\n        // the first draw call, we can set the uniforms of the shader directly here.\n\n        // this means that we can tack advantage of the sync function of pixi!\n        // bind and sync uniforms..\n        // there is a way to optimise this..\n        renderer.shader.bind(shader);\n        renderer.geometry.bind(geometry, shader);\n\n        // set state..\n        renderer.state.set(this.state);\n\n        // then render the rest of them...\n        for (let i = 0, l = drawCalls.length; i < l; i++)\n        {\n            this._renderDrawCallDirect(renderer, geometry.drawCalls[i]);\n        }\n    }\n\n    /** Renders specific DrawCall */\n    protected _renderDrawCallDirect(renderer: Renderer, drawCall: BatchDrawCall): void\n    {\n        const { texArray, type, size, start } = drawCall;\n        const groupTextureCount = texArray.count;\n\n        for (let j = 0; j < groupTextureCount; j++)\n        {\n            renderer.texture.bind(texArray.elements[j], j);\n        }\n\n        renderer.geometry.draw(type, size, start);\n    }\n\n    /**\n     * Resolves shader for direct rendering\n     *\n     * @param renderer - The renderer\n     */\n    protected _resolveDirectShader(renderer: Renderer): Shader\n    {\n        let shader = this.shader;\n\n        const pluginName = this.pluginName;\n\n        if (!shader)\n        {\n            // if there is no shader here, we can use the default shader.\n            // and that only gets created if we actually need it..\n            // but may be more than one plugins for graphics\n            if (!DEFAULT_SHADERS[pluginName])\n            {\n                const MAX_TEXTURES = renderer.plugins.batch.MAX_TEXTURES;\n                const sampleValues = new Int32Array(MAX_TEXTURES);\n\n                for (let i = 0; i < MAX_TEXTURES; i++)\n                {\n                    sampleValues[i] = i;\n                }\n\n                const uniforms = {\n                    tint: new Float32Array([1, 1, 1, 1]),\n                    translationMatrix: new Matrix(),\n                    default: UniformGroup.from({ uSamplers: sampleValues }, true),\n                };\n\n                const program = renderer.plugins[pluginName]._shader.program;\n\n                DEFAULT_SHADERS[pluginName] = new Shader(program, uniforms);\n            }\n\n            shader = DEFAULT_SHADERS[pluginName];\n        }\n\n        return shader;\n    }\n\n    /** Retrieves the bounds of the graphic shape as a rectangle object. */\n    protected _calculateBounds(): void\n    {\n        this.finishPoly();\n\n        const geometry = this._geometry;\n\n        // skipping when graphics is empty, like a container\n        if (!geometry.graphicsData.length)\n        {\n            return;\n        }\n\n        const { minX, minY, maxX, maxY } = geometry.bounds;\n\n        this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\n    }\n\n    /**\n     * Tests if a point is inside this graphics object\n     *\n     * @param point - the point to test\n     * @return - the result of the test\n     */\n    public containsPoint(point: IPointData): boolean\n    {\n        this.worldTransform.applyInverse(point, Graphics._TEMP_POINT);\n\n        return this._geometry.containsPoint(Graphics._TEMP_POINT);\n    }\n\n    /** Recalculate the tint by applying tint to batches using Graphics tint. */\n    protected calculateTints(): void\n    {\n        if (this.batchTint !== this.tint)\n        {\n            this.batchTint = this.tint;\n\n            const tintRGB = hex2rgb(this.tint, temp);\n\n            for (let i = 0; i < this.batches.length; i++)\n            {\n                const batch = this.batches[i];\n\n                const batchTint = batch._batchRGB;\n\n                const r = (tintRGB[0] * batchTint[0]) * 255;\n                const g = (tintRGB[1] * batchTint[1]) * 255;\n                const b = (tintRGB[2] * batchTint[2]) * 255;\n\n                // TODO Ivan, can this be done in one go?\n                const color = (r << 16) + (g << 8) + (b | 0);\n\n                batch._tintRGB = (color >> 16)\n                        + (color & 0xff00)\n                        + ((color & 0xff) << 16);\n            }\n        }\n    }\n\n    /**\n     * If there's a transform update or a change to the shape of the\n     * geometry, recalculate the vertices.\n     */\n    protected calculateVertices(): void\n    {\n        const wtID = this.transform._worldID;\n\n        if (this._transformID === wtID)\n        {\n            return;\n        }\n\n        this._transformID = wtID;\n\n        const wt = this.transform.worldTransform;\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        const data = this._geometry.points;// batch.vertexDataOriginal;\n        const vertexData = this.vertexData;\n\n        let count = 0;\n\n        for (let i = 0; i < data.length; i += 2)\n        {\n            const x = data[i];\n            const y = data[i + 1];\n\n            vertexData[count++] = (a * x) + (c * y) + tx;\n            vertexData[count++] = (d * y) + (b * x) + ty;\n        }\n    }\n\n    /**\n     * Closes the current path.\n     *\n     * @return - Returns itself.\n     */\n    public closePath(): this\n    {\n        const currentPath = this.currentPath;\n\n        if (currentPath)\n        {\n            // we don't need to add extra point in the end because buildLine will take care of that\n            currentPath.closeStroke = true;\n            // ensure that the polygon is completed, and is available for hit detection\n            // (even if the graphics is not rendered yet)\n            this.finishPoly();\n        }\n\n        return this;\n    }\n\n    /**\n     * Apply a matrix to the positional data.\n     *\n     * @param matrix - Matrix to use for transform current shape.\n     * @return - Returns itself.\n     */\n    public setMatrix(matrix: Matrix): this\n    {\n        this._matrix = matrix;\n\n        return this;\n    }\n\n    /**\n     * Begin adding holes to the last draw shape\n     * IMPORTANT: holes must be fully inside a shape to work\n     * Also weirdness ensues if holes overlap!\n     * Ellipses, Circles, Rectangles and Rounded Rectangles cannot be holes or host for holes in CanvasRenderer,\n     * please use `moveTo` `lineTo`, `quadraticCurveTo` if you rely on pixi-legacy bundle.\n     *\n     * @return - Returns itself.\n     */\n    public beginHole(): this\n    {\n        this.finishPoly();\n        this._holeMode = true;\n\n        return this;\n    }\n\n    /**\n     * End adding holes to the last draw shape.\n     *\n     * @return - Returns itself.\n     */\n    public endHole(): this\n    {\n        this.finishPoly();\n        this._holeMode = false;\n\n        return this;\n    }\n\n    /**\n     * Destroys the Graphics object.\n     *\n     * @param options - Options parameter. A boolean will act as if all\n     *  options have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have\n     *  their destroy method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the texture of the child sprite\n     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the base texture of the child sprite\n     */\n    public destroy(options?: IDestroyOptions|boolean): void\n    {\n        this._geometry.refCount--;\n        if (this._geometry.refCount === 0)\n        {\n            this._geometry.dispose();\n        }\n\n        this._matrix = null;\n        this.currentPath = null;\n        this._lineStyle.destroy();\n        this._lineStyle = null;\n        this._fillStyle.destroy();\n        this._fillStyle = null;\n        this._geometry = null;\n        this.shader = null;\n        this.vertexData = null;\n        this.batches.length = 0;\n        this.batches = null;\n\n        super.destroy(options);\n    }\n}\n","export * from './const';\nexport * from './styles/FillStyle';\nexport * from './Graphics';\nexport * from './GraphicsData';\nexport * from './GraphicsGeometry';\nexport * from './styles/LineStyle';\n\nimport {\n    buildPoly,\n    buildCircle,\n    buildRectangle,\n    buildRoundedRectangle,\n    buildLine,\n    ArcUtils,\n    BezierUtils,\n    QuadraticUtils,\n    BatchPart,\n    FILL_COMMANDS,\n    BATCH_POOL,\n    DRAW_CALL_POOL\n} from './utils';\nimport type { BatchDrawCall } from '@pixi/core/';\nimport type { IShapeBuildCommand } from './utils/IShapeBuildCommand';\nimport type { SHAPES } from '@pixi/math';\n\nexport const graphicsUtils = {\n    buildPoly: buildPoly as IShapeBuildCommand,\n    buildCircle: buildCircle as IShapeBuildCommand,\n    buildRectangle: buildRectangle as IShapeBuildCommand,\n    buildRoundedRectangle: buildRoundedRectangle as IShapeBuildCommand,\n    buildLine,\n    ArcUtils,\n    BezierUtils,\n    QuadraticUtils,\n    BatchPart,\n    FILL_COMMANDS: FILL_COMMANDS as Record<SHAPES, IShapeBuildCommand>,\n    BATCH_POOL: BATCH_POOL as Array<BatchPart>,\n    DRAW_CALL_POOL: DRAW_CALL_POOL as Array<BatchDrawCall>\n};\n"]},"metadata":{},"sourceType":"module"}