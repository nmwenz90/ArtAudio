{"ast":null,"code":"import _classCallCheck from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Volume } from \"../component/channel/Volume\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\n/**\n * Base-class for all instruments\n */\n\nexport var Instrument = /*#__PURE__*/function (_ToneAudioNode) {\n  _inherits(Instrument, _ToneAudioNode);\n\n  var _super = _createSuper(Instrument);\n\n  function Instrument() {\n    var _this;\n\n    _classCallCheck(this, Instrument);\n\n    _this = _super.call(this, optionsFromArguments(Instrument.getDefaults(), arguments));\n    /**\n     * Keep track of all events scheduled to the transport\n     * when the instrument is 'synced'\n     */\n\n    _this._scheduledEvents = [];\n    /**\n     * If the instrument is currently synced\n     */\n\n    _this._synced = false;\n    _this._original_triggerAttack = _this.triggerAttack;\n    _this._original_triggerRelease = _this.triggerRelease;\n    var options = optionsFromArguments(Instrument.getDefaults(), arguments);\n    _this._volume = _this.output = new Volume({\n      context: _this.context,\n      volume: options.volume\n    });\n    _this.volume = _this._volume.volume;\n    readOnly(_assertThisInitialized(_this), \"volume\");\n    return _this;\n  }\n\n  _createClass(Instrument, [{\n    key: \"sync\",\n    value:\n    /**\n     * Sync the instrument to the Transport. All subsequent calls of\n     * [[triggerAttack]] and [[triggerRelease]] will be scheduled along the transport.\n     * @example\n     * const fmSynth = new Tone.FMSynth().toDestination();\n     * fmSynth.volume.value = -6;\n     * fmSynth.sync();\n     * // schedule 3 notes when the transport first starts\n     * fmSynth.triggerAttackRelease(\"C4\", \"8n\", 0);\n     * fmSynth.triggerAttackRelease(\"E4\", \"8n\", \"8n\");\n     * fmSynth.triggerAttackRelease(\"G4\", \"8n\", \"4n\");\n     * // start the transport to hear the notes\n     * Tone.Transport.start();\n     */\n    function sync() {\n      if (this._syncState()) {\n        this._syncMethod(\"triggerAttack\", 1);\n\n        this._syncMethod(\"triggerRelease\", 0);\n      }\n\n      return this;\n    }\n    /**\n     * set _sync\n     */\n\n  }, {\n    key: \"_syncState\",\n    value: function _syncState() {\n      var changed = false;\n\n      if (!this._synced) {\n        this._synced = true;\n        changed = true;\n      }\n\n      return changed;\n    }\n    /**\n     * Wrap the given method so that it can be synchronized\n     * @param method Which method to wrap and sync\n     * @param  timePosition What position the time argument appears in\n     */\n\n  }, {\n    key: \"_syncMethod\",\n    value: function _syncMethod(method, timePosition) {\n      var _this2 = this;\n\n      var originalMethod = this[\"_original_\" + method] = this[method];\n\n      this[method] = function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        var time = args[timePosition];\n\n        var id = _this2.context.transport.schedule(function (t) {\n          args[timePosition] = t;\n          originalMethod.apply(_this2, args);\n        }, time);\n\n        _this2._scheduledEvents.push(id);\n      };\n    }\n    /**\n     * Unsync the instrument from the Transport\n     */\n\n  }, {\n    key: \"unsync\",\n    value: function unsync() {\n      var _this3 = this;\n\n      this._scheduledEvents.forEach(function (id) {\n        return _this3.context.transport.clear(id);\n      });\n\n      this._scheduledEvents = [];\n\n      if (this._synced) {\n        this._synced = false;\n        this.triggerAttack = this._original_triggerAttack;\n        this.triggerRelease = this._original_triggerRelease;\n      }\n\n      return this;\n    }\n    /**\n     * Trigger the attack and then the release after the duration.\n     * @param  note     The note to trigger.\n     * @param  duration How long the note should be held for before\n     *                         triggering the release. This value must be greater than 0.\n     * @param time  When the note should be triggered.\n     * @param  velocity The velocity the note should be triggered at.\n     * @example\n     * const synth = new Tone.Synth().toDestination();\n     * // trigger \"C4\" for the duration of an 8th note\n     * synth.triggerAttackRelease(\"C4\", \"8n\");\n     */\n\n  }, {\n    key: \"triggerAttackRelease\",\n    value: function triggerAttackRelease(note, duration, time, velocity) {\n      var computedTime = this.toSeconds(time);\n      var computedDuration = this.toSeconds(duration);\n      this.triggerAttack(note, computedTime, velocity);\n      this.triggerRelease(computedTime + computedDuration);\n      return this;\n    }\n    /**\n     * clean up\n     * @returns {Instrument} this\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(Instrument.prototype), \"dispose\", this).call(this);\n\n      this._volume.dispose();\n\n      this.unsync();\n      this._scheduledEvents = [];\n      return this;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(ToneAudioNode.getDefaults(), {\n        volume: 0\n      });\n    }\n  }]);\n\n  return Instrument;\n}(ToneAudioNode);","map":{"version":3,"mappings":"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","names":["Volume","ToneAudioNode","optionsFromArguments","readOnly","Instrument","getDefaults","arguments","triggerAttack","triggerRelease","options","_volume","output","context","volume","_syncState","_syncMethod","changed","_synced","method","timePosition","originalMethod","args","time","id","transport","schedule","t","apply","_scheduledEvents","push","forEach","clear","_original_triggerAttack","_original_triggerRelease","note","duration","velocity","computedTime","toSeconds","computedDuration","dispose","unsync","Object","assign"],"sourceRoot":"","sources":["../../../Tone/instrument/Instrument.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}