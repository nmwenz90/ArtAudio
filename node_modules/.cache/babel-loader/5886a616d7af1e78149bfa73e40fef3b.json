{"ast":null,"code":"import _classCallCheck from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Param } from \"../context/Param\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isUndef } from \"../util/TypeCheck\";\n/**\n * A Param class just for computing ticks. Similar to the [[Param]] class,\n * but offers conversion to BPM values as well as ability to compute tick\n * duration and elapsed ticks\n */\n\nexport var TickParam = /*#__PURE__*/function (_Param) {\n  _inherits(TickParam, _Param);\n\n  var _super = _createSuper(TickParam);\n\n  function TickParam() {\n    var _this;\n\n    _classCallCheck(this, TickParam);\n\n    _this = _super.call(this, optionsFromArguments(TickParam.getDefaults(), arguments, [\"value\"]));\n    _this.name = \"TickParam\";\n    /**\n     * The timeline which tracks all of the automations.\n     */\n\n    _this._events = new Timeline(Infinity);\n    /**\n     * The internal holder for the multiplier value\n     */\n\n    _this._multiplier = 1;\n    var options = optionsFromArguments(TickParam.getDefaults(), arguments, [\"value\"]); // set the multiplier\n\n    _this._multiplier = options.multiplier; // clear the ticks from the beginning\n\n    _this._events.cancel(0); // set an initial event\n\n\n    _this._events.add({\n      ticks: 0,\n      time: 0,\n      type: \"setValueAtTime\",\n      value: _this._fromType(options.value)\n    });\n\n    _this.setValueAtTime(options.value, 0);\n\n    return _this;\n  }\n\n  _createClass(TickParam, [{\n    key: \"setTargetAtTime\",\n    value: function setTargetAtTime(value, time, constant) {\n      // approximate it with multiple linear ramps\n      time = this.toSeconds(time);\n      this.setRampPoint(time);\n\n      var computedValue = this._fromType(value); // start from previously scheduled value\n\n\n      var prevEvent = this._events.get(time);\n\n      var segments = Math.round(Math.max(1 / constant, 1));\n\n      for (var i = 0; i <= segments; i++) {\n        var segTime = constant * i + time;\n\n        var rampVal = this._exponentialApproach(prevEvent.time, prevEvent.value, computedValue, constant, segTime);\n\n        this.linearRampToValueAtTime(this._toType(rampVal), segTime);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"setValueAtTime\",\n    value: function setValueAtTime(value, time) {\n      var computedTime = this.toSeconds(time);\n\n      _get(_getPrototypeOf(TickParam.prototype), \"setValueAtTime\", this).call(this, value, time);\n\n      var event = this._events.get(computedTime);\n\n      var previousEvent = this._events.previousEvent(event);\n\n      var ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);\n\n      event.ticks = Math.max(ticksUntilTime, 0);\n      return this;\n    }\n  }, {\n    key: \"linearRampToValueAtTime\",\n    value: function linearRampToValueAtTime(value, time) {\n      var computedTime = this.toSeconds(time);\n\n      _get(_getPrototypeOf(TickParam.prototype), \"linearRampToValueAtTime\", this).call(this, value, time);\n\n      var event = this._events.get(computedTime);\n\n      var previousEvent = this._events.previousEvent(event);\n\n      var ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);\n\n      event.ticks = Math.max(ticksUntilTime, 0);\n      return this;\n    }\n  }, {\n    key: \"exponentialRampToValueAtTime\",\n    value: function exponentialRampToValueAtTime(value, time) {\n      // aproximate it with multiple linear ramps\n      time = this.toSeconds(time);\n\n      var computedVal = this._fromType(value); // start from previously scheduled value\n\n\n      var prevEvent = this._events.get(time); // approx 10 segments per second\n\n\n      var segments = Math.round(Math.max((time - prevEvent.time) * 10, 1));\n      var segmentDur = (time - prevEvent.time) / segments;\n\n      for (var i = 0; i <= segments; i++) {\n        var segTime = segmentDur * i + prevEvent.time;\n\n        var rampVal = this._exponentialInterpolate(prevEvent.time, prevEvent.value, time, computedVal, segTime);\n\n        this.linearRampToValueAtTime(this._toType(rampVal), segTime);\n      }\n\n      return this;\n    }\n    /**\n     * Returns the tick value at the time. Takes into account\n     * any automation curves scheduled on the signal.\n     * @param  event The time to get the tick count at\n     * @return The number of ticks which have elapsed at the time given any automations.\n     */\n\n  }, {\n    key: \"_getTicksUntilEvent\",\n    value: function _getTicksUntilEvent(event, time) {\n      if (event === null) {\n        event = {\n          ticks: 0,\n          time: 0,\n          type: \"setValueAtTime\",\n          value: 0\n        };\n      } else if (isUndef(event.ticks)) {\n        var previousEvent = this._events.previousEvent(event);\n\n        event.ticks = this._getTicksUntilEvent(previousEvent, event.time);\n      }\n\n      var val0 = this._fromType(this.getValueAtTime(event.time));\n\n      var val1 = this._fromType(this.getValueAtTime(time)); // if it's right on the line, take the previous value\n\n\n      var onTheLineEvent = this._events.get(time);\n\n      if (onTheLineEvent && onTheLineEvent.time === time && onTheLineEvent.type === \"setValueAtTime\") {\n        val1 = this._fromType(this.getValueAtTime(time - this.sampleTime));\n      }\n\n      return 0.5 * (time - event.time) * (val0 + val1) + event.ticks;\n    }\n    /**\n     * Returns the tick value at the time. Takes into account\n     * any automation curves scheduled on the signal.\n     * @param  time The time to get the tick count at\n     * @return The number of ticks which have elapsed at the time given any automations.\n     */\n\n  }, {\n    key: \"getTicksAtTime\",\n    value: function getTicksAtTime(time) {\n      var computedTime = this.toSeconds(time);\n\n      var event = this._events.get(computedTime);\n\n      return Math.max(this._getTicksUntilEvent(event, computedTime), 0);\n    }\n    /**\n     * Return the elapsed time of the number of ticks from the given time\n     * @param ticks The number of ticks to calculate\n     * @param  time The time to get the next tick from\n     * @return The duration of the number of ticks from the given time in seconds\n     */\n\n  }, {\n    key: \"getDurationOfTicks\",\n    value: function getDurationOfTicks(ticks, time) {\n      var computedTime = this.toSeconds(time);\n      var currentTick = this.getTicksAtTime(time);\n      return this.getTimeOfTick(currentTick + ticks) - computedTime;\n    }\n    /**\n     * Given a tick, returns the time that tick occurs at.\n     * @return The time that the tick occurs.\n     */\n\n  }, {\n    key: \"getTimeOfTick\",\n    value: function getTimeOfTick(tick) {\n      var before = this._events.get(tick, \"ticks\");\n\n      var after = this._events.getAfter(tick, \"ticks\");\n\n      if (before && before.ticks === tick) {\n        return before.time;\n      } else if (before && after && after.type === \"linearRampToValueAtTime\" && before.value !== after.value) {\n        var val0 = this._fromType(this.getValueAtTime(before.time));\n\n        var val1 = this._fromType(this.getValueAtTime(after.time));\n\n        var delta = (val1 - val0) / (after.time - before.time);\n        var k = Math.sqrt(Math.pow(val0, 2) - 2 * delta * (before.ticks - tick));\n        var sol1 = (-val0 + k) / delta;\n        var sol2 = (-val0 - k) / delta;\n        return (sol1 > 0 ? sol1 : sol2) + before.time;\n      } else if (before) {\n        if (before.value === 0) {\n          return Infinity;\n        } else {\n          return before.time + (tick - before.ticks) / before.value;\n        }\n      } else {\n        return tick / this._initialValue;\n      }\n    }\n    /**\n     * Convert some number of ticks their the duration in seconds accounting\n     * for any automation curves starting at the given time.\n     * @param  ticks The number of ticks to convert to seconds.\n     * @param  when  When along the automation timeline to convert the ticks.\n     * @return The duration in seconds of the ticks.\n     */\n\n  }, {\n    key: \"ticksToTime\",\n    value: function ticksToTime(ticks, when) {\n      return this.getDurationOfTicks(ticks, when);\n    }\n    /**\n     * The inverse of [[ticksToTime]]. Convert a duration in\n     * seconds to the corresponding number of ticks accounting for any\n     * automation curves starting at the given time.\n     * @param  duration The time interval to convert to ticks.\n     * @param  when When along the automation timeline to convert the ticks.\n     * @return The duration in ticks.\n     */\n\n  }, {\n    key: \"timeToTicks\",\n    value: function timeToTicks(duration, when) {\n      var computedTime = this.toSeconds(when);\n      var computedDuration = this.toSeconds(duration);\n      var startTicks = this.getTicksAtTime(computedTime);\n      var endTicks = this.getTicksAtTime(computedTime + computedDuration);\n      return endTicks - startTicks;\n    }\n    /**\n     * Convert from the type when the unit value is BPM\n     */\n\n  }, {\n    key: \"_fromType\",\n    value: function _fromType(val) {\n      if (this.units === \"bpm\" && this.multiplier) {\n        return 1 / (60 / val / this.multiplier);\n      } else {\n        return _get(_getPrototypeOf(TickParam.prototype), \"_fromType\", this).call(this, val);\n      }\n    }\n    /**\n     * Special case of type conversion where the units === \"bpm\"\n     */\n\n  }, {\n    key: \"_toType\",\n    value: function _toType(val) {\n      if (this.units === \"bpm\" && this.multiplier) {\n        return val / this.multiplier * 60;\n      } else {\n        return _get(_getPrototypeOf(TickParam.prototype), \"_toType\", this).call(this, val);\n      }\n    }\n    /**\n     * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.\n     */\n\n  }, {\n    key: \"multiplier\",\n    get: function get() {\n      return this._multiplier;\n    },\n    set: function set(m) {\n      // get and reset the current value with the new multiplier\n      // might be necessary to clear all the previous values\n      var currentVal = this.value;\n      this._multiplier = m;\n      this.cancelScheduledValues(0);\n      this.setValueAtTime(currentVal, 0);\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(Param.getDefaults(), {\n        multiplier: 1,\n        units: \"hertz\",\n        value: 1\n      });\n    }\n  }]);\n\n  return TickParam;\n}(Param);","map":{"version":3,"mappings":"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","names":["Param","optionsFromArguments","Timeline","isUndef","TickParam","getDefaults","arguments","Infinity","options","_multiplier","multiplier","_events","cancel","add","ticks","time","type","value","_fromType","setValueAtTime","constant","toSeconds","setRampPoint","computedValue","prevEvent","get","segments","Math","round","max","i","segTime","rampVal","_exponentialApproach","linearRampToValueAtTime","_toType","computedTime","event","previousEvent","ticksUntilTime","_getTicksUntilEvent","computedVal","segmentDur","_exponentialInterpolate","val0","getValueAtTime","val1","onTheLineEvent","sampleTime","currentTick","getTicksAtTime","getTimeOfTick","tick","before","after","getAfter","delta","k","sqrt","pow","sol1","sol2","_initialValue","when","getDurationOfTicks","duration","computedDuration","startTicks","endTicks","val","units","m","currentVal","cancelScheduledValues","Object","assign"],"sourceRoot":"","sources":["../../../../Tone/core/clock/TickParam.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}