{"ast":null,"code":"import _classCallCheck from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { isAudioNode, isAudioParam } from \"../util/AdvancedTypeCheck\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { Param } from \"./Param\";\nimport { ToneWithContext } from \"./ToneWithContext\";\nimport { assert, warn } from \"../util/Debug\";\n/**\n * ToneAudioNode is the base class for classes which process audio.\n */\n\nexport var ToneAudioNode = /*#__PURE__*/function (_ToneWithContext) {\n  _inherits(ToneAudioNode, _ToneWithContext);\n\n  var _super = _createSuper(ToneAudioNode);\n\n  function ToneAudioNode() {\n    var _this;\n\n    _classCallCheck(this, ToneAudioNode);\n\n    _this = _super.apply(this, arguments);\n    /**\n     * The name of the class\n     */\n\n    _this.name = \"ToneAudioNode\";\n    /**\n     * List all of the node that must be set to match the ChannelProperties\n     */\n\n    _this._internalChannels = [];\n    return _this;\n  }\n  /**\n   * The number of inputs feeding into the AudioNode.\n   * For source nodes, this will be 0.\n   * @example\n   * const node = new Tone.Gain();\n   * console.log(node.numberOfInputs);\n   */\n\n\n  _createClass(ToneAudioNode, [{\n    key: \"numberOfInputs\",\n    get: function get() {\n      if (isDefined(this.input)) {\n        if (isAudioParam(this.input) || this.input instanceof Param) {\n          return 1;\n        } else {\n          return this.input.numberOfInputs;\n        }\n      } else {\n        return 0;\n      }\n    }\n    /**\n     * The number of outputs of the AudioNode.\n     * @example\n     * const node = new Tone.Gain();\n     * console.log(node.numberOfOutputs);\n     */\n\n  }, {\n    key: \"numberOfOutputs\",\n    get: function get() {\n      if (isDefined(this.output)) {\n        return this.output.numberOfOutputs;\n      } else {\n        return 0;\n      }\n    } //-------------------------------------\n    // AUDIO PROPERTIES\n    //-------------------------------------\n\n    /**\n     * Used to decide which nodes to get/set properties on\n     */\n\n  }, {\n    key: \"_isAudioNode\",\n    value: function _isAudioNode(node) {\n      return isDefined(node) && (node instanceof ToneAudioNode || isAudioNode(node));\n    }\n    /**\n     * Get all of the audio nodes (either internal or input/output) which together\n     * make up how the class node responds to channel input/output\n     */\n\n  }, {\n    key: \"_getInternalNodes\",\n    value: function _getInternalNodes() {\n      var nodeList = this._internalChannels.slice(0);\n\n      if (this._isAudioNode(this.input)) {\n        nodeList.push(this.input);\n      }\n\n      if (this._isAudioNode(this.output)) {\n        if (this.input !== this.output) {\n          nodeList.push(this.output);\n        }\n      }\n\n      return nodeList;\n    }\n    /**\n     * Set the audio options for this node such as channelInterpretation\n     * channelCount, etc.\n     * @param options\n     */\n\n  }, {\n    key: \"_setChannelProperties\",\n    value: function _setChannelProperties(options) {\n      var nodeList = this._getInternalNodes();\n\n      nodeList.forEach(function (node) {\n        node.channelCount = options.channelCount;\n        node.channelCountMode = options.channelCountMode;\n        node.channelInterpretation = options.channelInterpretation;\n      });\n    }\n    /**\n     * Get the current audio options for this node such as channelInterpretation\n     * channelCount, etc.\n     */\n\n  }, {\n    key: \"_getChannelProperties\",\n    value: function _getChannelProperties() {\n      var nodeList = this._getInternalNodes();\n\n      assert(nodeList.length > 0, \"ToneAudioNode does not have any internal nodes\"); // use the first node to get properties\n      // they should all be the same\n\n      var node = nodeList[0];\n      return {\n        channelCount: node.channelCount,\n        channelCountMode: node.channelCountMode,\n        channelInterpretation: node.channelInterpretation\n      };\n    }\n    /**\n     * channelCount is the number of channels used when up-mixing and down-mixing\n     * connections to any inputs to the node. The default value is 2 except for\n     * specific nodes where its value is specially determined.\n     */\n\n  }, {\n    key: \"channelCount\",\n    get: function get() {\n      return this._getChannelProperties().channelCount;\n    },\n    set: function set(channelCount) {\n      var props = this._getChannelProperties(); // merge it with the other properties\n\n\n      this._setChannelProperties(Object.assign(props, {\n        channelCount: channelCount\n      }));\n    }\n    /**\n     * channelCountMode determines how channels will be counted when up-mixing and\n     * down-mixing connections to any inputs to the node.\n     * The default value is \"max\". This attribute has no effect for nodes with no inputs.\n     * * \"max\" - computedNumberOfChannels is the maximum of the number of channels of all connections to an input. In this mode channelCount is ignored.\n     * * \"clamped-max\" - computedNumberOfChannels is determined as for \"max\" and then clamped to a maximum value of the given channelCount.\n     * * \"explicit\" - computedNumberOfChannels is the exact value as specified by the channelCount.\n     */\n\n  }, {\n    key: \"channelCountMode\",\n    get: function get() {\n      return this._getChannelProperties().channelCountMode;\n    },\n    set: function set(channelCountMode) {\n      var props = this._getChannelProperties(); // merge it with the other properties\n\n\n      this._setChannelProperties(Object.assign(props, {\n        channelCountMode: channelCountMode\n      }));\n    }\n    /**\n     * channelInterpretation determines how individual channels will be treated\n     * when up-mixing and down-mixing connections to any inputs to the node.\n     * The default value is \"speakers\".\n     */\n\n  }, {\n    key: \"channelInterpretation\",\n    get: function get() {\n      return this._getChannelProperties().channelInterpretation;\n    },\n    set: function set(channelInterpretation) {\n      var props = this._getChannelProperties(); // merge it with the other properties\n\n\n      this._setChannelProperties(Object.assign(props, {\n        channelInterpretation: channelInterpretation\n      }));\n    } //-------------------------------------\n    // CONNECTIONS\n    //-------------------------------------\n\n    /**\n     * connect the output of a ToneAudioNode to an AudioParam, AudioNode, or ToneAudioNode\n     * @param destination The output to connect to\n     * @param outputNum The output to connect from\n     * @param inputNum The input to connect to\n     */\n\n  }, {\n    key: \"connect\",\n    value: function connect(destination) {\n      var outputNum = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var inputNum = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n      _connect(this, destination, outputNum, inputNum);\n\n      return this;\n    }\n    /**\n     * Connect the output to the context's destination node.\n     * @example\n     * const osc = new Tone.Oscillator(\"C2\").start();\n     * osc.toDestination();\n     */\n\n  }, {\n    key: \"toDestination\",\n    value: function toDestination() {\n      this.connect(this.context.destination);\n      return this;\n    }\n    /**\n     * Connect the output to the context's destination node.\n     * See [[toDestination]]\n     * @deprecated\n     */\n\n  }, {\n    key: \"toMaster\",\n    value: function toMaster() {\n      warn(\"toMaster() has been renamed toDestination()\");\n      return this.toDestination();\n    }\n    /**\n     * disconnect the output\n     */\n\n  }, {\n    key: \"disconnect\",\n    value: function disconnect(destination) {\n      var outputNum = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var inputNum = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n      _disconnect(this, destination, outputNum, inputNum);\n\n      return this;\n    }\n    /**\n     * Connect the output of this node to the rest of the nodes in series.\n     * @example\n     * const player = new Tone.Player(\"https://tonejs.github.io/audio/drum-samples/handdrum-loop.mp3\");\n     * player.autostart = true;\n     * const filter = new Tone.AutoFilter(4).start();\n     * const distortion = new Tone.Distortion(0.5);\n     * // connect the player to the filter, distortion and then to the master output\n     * player.chain(filter, distortion, Tone.Destination);\n     */\n\n  }, {\n    key: \"chain\",\n    value: function chain() {\n      for (var _len = arguments.length, nodes = new Array(_len), _key = 0; _key < _len; _key++) {\n        nodes[_key] = arguments[_key];\n      }\n\n      connectSeries.apply(void 0, [this].concat(nodes));\n      return this;\n    }\n    /**\n     * connect the output of this node to the rest of the nodes in parallel.\n     * @example\n     * const player = new Tone.Player(\"https://tonejs.github.io/audio/drum-samples/conga-rhythm.mp3\");\n     * player.autostart = true;\n     * const pitchShift = new Tone.PitchShift(4).toDestination();\n     * const filter = new Tone.Filter(\"G5\").toDestination();\n     * // connect a node to the pitch shift and filter in parallel\n     * player.fan(pitchShift, filter);\n     */\n\n  }, {\n    key: \"fan\",\n    value: function fan() {\n      var _this2 = this;\n\n      for (var _len2 = arguments.length, nodes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        nodes[_key2] = arguments[_key2];\n      }\n\n      nodes.forEach(function (node) {\n        return _this2.connect(node);\n      });\n      return this;\n    }\n    /**\n     * Dispose and disconnect\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(ToneAudioNode.prototype), \"dispose\", this).call(this);\n\n      if (isDefined(this.input)) {\n        if (this.input instanceof ToneAudioNode) {\n          this.input.dispose();\n        } else if (isAudioNode(this.input)) {\n          this.input.disconnect();\n        }\n      }\n\n      if (isDefined(this.output)) {\n        if (this.output instanceof ToneAudioNode) {\n          this.output.dispose();\n        } else if (isAudioNode(this.output)) {\n          this.output.disconnect();\n        }\n      }\n\n      this._internalChannels = [];\n      return this;\n    }\n  }]);\n\n  return ToneAudioNode;\n}(ToneWithContext); //-------------------------------------\n// CONNECTIONS\n//-------------------------------------\n\n/**\n * connect together all of the arguments in series\n * @param nodes\n */\n\nexport function connectSeries() {\n  for (var _len3 = arguments.length, nodes = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    nodes[_key3] = arguments[_key3];\n  }\n\n  var first = nodes.shift();\n  nodes.reduce(function (prev, current) {\n    if (prev instanceof ToneAudioNode) {\n      prev.connect(current);\n    } else if (isAudioNode(prev)) {\n      _connect(prev, current);\n    }\n\n    return current;\n  }, first);\n}\n/**\n * Connect two nodes together so that signal flows from the\n * first node to the second. Optionally specify the input and output channels.\n * @param srcNode The source node\n * @param dstNode The destination node\n * @param outputNumber The output channel of the srcNode\n * @param inputNumber The input channel of the dstNode\n */\n\nfunction _connect(srcNode, dstNode) {\n  var outputNumber = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var inputNumber = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  assert(isDefined(srcNode), \"Cannot connect from undefined node\");\n  assert(isDefined(dstNode), \"Cannot connect to undefined node\");\n\n  if (dstNode instanceof ToneAudioNode || isAudioNode(dstNode)) {\n    assert(dstNode.numberOfInputs > 0, \"Cannot connect to node with no inputs\");\n  }\n\n  assert(srcNode.numberOfOutputs > 0, \"Cannot connect from node with no outputs\"); // resolve the input of the dstNode\n\n  while (dstNode instanceof ToneAudioNode || dstNode instanceof Param) {\n    if (isDefined(dstNode.input)) {\n      dstNode = dstNode.input;\n    }\n  }\n\n  while (srcNode instanceof ToneAudioNode) {\n    if (isDefined(srcNode.output)) {\n      srcNode = srcNode.output;\n    }\n  } // make the connection\n\n\n  if (isAudioParam(dstNode)) {\n    srcNode.connect(dstNode, outputNumber);\n  } else {\n    srcNode.connect(dstNode, outputNumber, inputNumber);\n  }\n}\n/**\n * Disconnect a node from all nodes or optionally include a destination node and input/output channels.\n * @param srcNode The source node\n * @param dstNode The destination node\n * @param outputNumber The output channel of the srcNode\n * @param inputNumber The input channel of the dstNode\n */\n\n\nexport { _connect as connect };\n\nfunction _disconnect(srcNode, dstNode) {\n  var outputNumber = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var inputNumber = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n  // resolve the destination node\n  if (isDefined(dstNode)) {\n    while (dstNode instanceof ToneAudioNode) {\n      dstNode = dstNode.input;\n    }\n  } // resolve the src node\n\n\n  while (!isAudioNode(srcNode)) {\n    if (isDefined(srcNode.output)) {\n      srcNode = srcNode.output;\n    }\n  }\n\n  if (isAudioParam(dstNode)) {\n    srcNode.disconnect(dstNode, outputNumber);\n  } else if (isAudioNode(dstNode)) {\n    srcNode.disconnect(dstNode, outputNumber, inputNumber);\n  } else {\n    srcNode.disconnect();\n  }\n}\n\nexport { _disconnect as disconnect };","map":{"version":3,"mappings":"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","names":["isAudioNode","isAudioParam","isDefined","Param","ToneWithContext","assert","warn","ToneAudioNode","input","numberOfInputs","output","numberOfOutputs","node","nodeList","_internalChannels","slice","_isAudioNode","push","options","_getInternalNodes","forEach","channelCount","channelCountMode","channelInterpretation","length","_getChannelProperties","props","_setChannelProperties","Object","assign","destination","outputNum","inputNum","connect","context","toDestination","disconnect","nodes","connectSeries","dispose","first","shift","reduce","prev","current","srcNode","dstNode","outputNumber","inputNumber"],"sourceRoot":"","sources":["../../../../Tone/core/context/ToneAudioNode.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}