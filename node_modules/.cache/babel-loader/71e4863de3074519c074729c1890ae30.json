{"ast":null,"code":"import _classCallCheck from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/natewamwenze/Documents/personalProjects/musicidea/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { TimeClass } from \"../../core/type/Time\";\nimport { TimelineValue } from \"../../core/util/TimelineValue\";\nimport { onContextClose, onContextInit } from \"../context/ContextInitialization\";\nimport { Gain } from \"../context/Gain\";\nimport { ToneWithContext } from \"../context/ToneWithContext\";\nimport { TicksClass } from \"../type/Ticks\";\nimport { TransportTimeClass } from \"../type/TransportTime\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { readOnly, writable } from \"../util/Interface\";\nimport { IntervalTimeline } from \"../util/IntervalTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isArray, isDefined } from \"../util/TypeCheck\";\nimport { Clock } from \"./Clock\";\nimport { TransportEvent } from \"./TransportEvent\";\nimport { TransportRepeatEvent } from \"./TransportRepeatEvent\";\n/**\n * Transport for timing musical events.\n * Supports tempo curves and time changes. Unlike browser-based timing (setInterval, requestAnimationFrame)\n * Transport timing events pass in the exact time of the scheduled event\n * in the argument of the callback function. Pass that time value to the object\n * you're scheduling. <br><br>\n * A single transport is created for you when the library is initialized.\n * <br><br>\n * The transport emits the events: \"start\", \"stop\", \"pause\", and \"loop\" which are\n * called with the time of that event as the argument.\n *\n * @example\n * const osc = new Tone.Oscillator().toDestination();\n * // repeated event every 8th note\n * Tone.Transport.scheduleRepeat((time) => {\n * \t// use the callback time to schedule events\n * \tosc.start(time).stop(time + 0.1);\n * }, \"8n\");\n * // transport must be started before it starts invoking events\n * Tone.Transport.start();\n * @category Core\n */\n\nexport var Transport = /*#__PURE__*/function (_ToneWithContext) {\n  _inherits(Transport, _ToneWithContext);\n\n  var _super = _createSuper(Transport);\n\n  function Transport() {\n    var _this;\n\n    _classCallCheck(this, Transport);\n\n    _this = _super.call(this, optionsFromArguments(Transport.getDefaults(), arguments));\n    _this.name = \"Transport\"; //-------------------------------------\n    // \tLOOPING\n    //-------------------------------------\n\n    /**\n     * If the transport loops or not.\n     */\n\n    _this._loop = new TimelineValue(false);\n    /**\n     * The loop start position in ticks\n     */\n\n    _this._loopStart = 0;\n    /**\n     * The loop end position in ticks\n     */\n\n    _this._loopEnd = 0; //-------------------------------------\n    // \tTIMELINE EVENTS\n    //-------------------------------------\n\n    /**\n     * All the events in an object to keep track by ID\n     */\n\n    _this._scheduledEvents = {};\n    /**\n     * The scheduled events.\n     */\n\n    _this._timeline = new Timeline();\n    /**\n     * Repeated events\n     */\n\n    _this._repeatedEvents = new IntervalTimeline();\n    /**\n     * All of the synced Signals\n     */\n\n    _this._syncedSignals = [];\n    /**\n     * The swing amount\n     */\n\n    _this._swingAmount = 0;\n    var options = optionsFromArguments(Transport.getDefaults(), arguments); // CLOCK/TEMPO\n\n    _this._ppq = options.ppq;\n    _this._clock = new Clock({\n      callback: _this._processTick.bind(_assertThisInitialized(_this)),\n      context: _this.context,\n      frequency: 0,\n      units: \"bpm\"\n    });\n\n    _this._bindClockEvents();\n\n    _this.bpm = _this._clock.frequency;\n    _this._clock.frequency.multiplier = options.ppq;\n\n    _this.bpm.setValueAtTime(options.bpm, 0);\n\n    readOnly(_assertThisInitialized(_this), \"bpm\");\n    _this._timeSignature = options.timeSignature; // SWING\n\n    _this._swingTicks = options.ppq / 2; // 8n\n\n    return _this;\n  }\n\n  _createClass(Transport, [{\n    key: \"_processTick\",\n    value: //-------------------------------------\n    // \tTICKS\n    //-------------------------------------\n\n    /**\n     * called on every tick\n     * @param  tickTime clock relative tick time\n     */\n    function _processTick(tickTime, ticks) {\n      // do the loop test\n      if (this._loop.get(tickTime)) {\n        if (ticks >= this._loopEnd) {\n          this.emit(\"loopEnd\", tickTime);\n\n          this._clock.setTicksAtTime(this._loopStart, tickTime);\n\n          ticks = this._loopStart;\n          this.emit(\"loopStart\", tickTime, this._clock.getSecondsAtTime(tickTime));\n          this.emit(\"loop\", tickTime);\n        }\n      } // handle swing\n\n\n      if (this._swingAmount > 0 && ticks % this._ppq !== 0 && // not on a downbeat\n      ticks % (this._swingTicks * 2) !== 0) {\n        // add some swing\n        var progress = ticks % (this._swingTicks * 2) / (this._swingTicks * 2);\n\n        var amount = Math.sin(progress * Math.PI) * this._swingAmount;\n\n        tickTime += new TicksClass(this.context, this._swingTicks * 2 / 3).toSeconds() * amount;\n      } // invoke the timeline events scheduled on this tick\n\n\n      this._timeline.forEachAtTime(ticks, function (event) {\n        return event.invoke(tickTime);\n      });\n    } //-------------------------------------\n    // \tSCHEDULABLE EVENTS\n    //-------------------------------------\n\n    /**\n     * Schedule an event along the timeline.\n     * @param callback The callback to be invoked at the time.\n     * @param time The time to invoke the callback at.\n     * @return The id of the event which can be used for canceling the event.\n     * @example\n     * // schedule an event on the 16th measure\n     * Tone.Transport.schedule((time) => {\n     * \t// invoked on measure 16\n     * \tconsole.log(\"measure 16!\");\n     * }, \"16:0:0\");\n     */\n\n  }, {\n    key: \"schedule\",\n    value: function schedule(callback, time) {\n      var event = new TransportEvent(this, {\n        callback: callback,\n        time: new TransportTimeClass(this.context, time).toTicks()\n      });\n      return this._addEvent(event, this._timeline);\n    }\n    /**\n     * Schedule a repeated event along the timeline. The event will fire\n     * at the `interval` starting at the `startTime` and for the specified\n     * `duration`.\n     * @param  callback   The callback to invoke.\n     * @param  interval   The duration between successive callbacks. Must be a positive number.\n     * @param  startTime  When along the timeline the events should start being invoked.\n     * @param  duration How long the event should repeat.\n     * @return  The ID of the scheduled event. Use this to cancel the event.\n     * @example\n     * const osc = new Tone.Oscillator().toDestination().start();\n     * // a callback invoked every eighth note after the first measure\n     * Tone.Transport.scheduleRepeat((time) => {\n     * \tosc.start(time).stop(time + 0.1);\n     * }, \"8n\", \"1m\");\n     */\n\n  }, {\n    key: \"scheduleRepeat\",\n    value: function scheduleRepeat(callback, interval, startTime) {\n      var duration = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;\n      var event = new TransportRepeatEvent(this, {\n        callback: callback,\n        duration: new TimeClass(this.context, duration).toTicks(),\n        interval: new TimeClass(this.context, interval).toTicks(),\n        time: new TransportTimeClass(this.context, startTime).toTicks()\n      }); // kick it off if the Transport is started\n      // @ts-ignore\n\n      return this._addEvent(event, this._repeatedEvents);\n    }\n    /**\n     * Schedule an event that will be removed after it is invoked.\n     * @param callback The callback to invoke once.\n     * @param time The time the callback should be invoked.\n     * @returns The ID of the scheduled event.\n     */\n\n  }, {\n    key: \"scheduleOnce\",\n    value: function scheduleOnce(callback, time) {\n      var event = new TransportEvent(this, {\n        callback: callback,\n        once: true,\n        time: new TransportTimeClass(this.context, time).toTicks()\n      });\n      return this._addEvent(event, this._timeline);\n    }\n    /**\n     * Clear the passed in event id from the timeline\n     * @param eventId The id of the event.\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear(eventId) {\n      if (this._scheduledEvents.hasOwnProperty(eventId)) {\n        var item = this._scheduledEvents[eventId.toString()];\n\n        item.timeline.remove(item.event);\n        item.event.dispose();\n        delete this._scheduledEvents[eventId.toString()];\n      }\n\n      return this;\n    }\n    /**\n     * Add an event to the correct timeline. Keep track of the\n     * timeline it was added to.\n     * @returns the event id which was just added\n     */\n\n  }, {\n    key: \"_addEvent\",\n    value: function _addEvent(event, timeline) {\n      this._scheduledEvents[event.id.toString()] = {\n        event: event,\n        timeline: timeline\n      };\n      timeline.add(event);\n      return event.id;\n    }\n    /**\n     * Remove scheduled events from the timeline after\n     * the given time. Repeated events will be removed\n     * if their startTime is after the given time\n     * @param after Clear all events after this time.\n     */\n\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      var _this2 = this;\n\n      var after = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var computedAfter = this.toTicks(after);\n\n      this._timeline.forEachFrom(computedAfter, function (event) {\n        return _this2.clear(event.id);\n      });\n\n      this._repeatedEvents.forEachFrom(computedAfter, function (event) {\n        return _this2.clear(event.id);\n      });\n\n      return this;\n    } //-------------------------------------\n    // \tSTART/STOP/PAUSE\n    //-------------------------------------\n\n    /**\n     * Bind start/stop/pause events from the clock and emit them.\n     */\n\n  }, {\n    key: \"_bindClockEvents\",\n    value: function _bindClockEvents() {\n      var _this3 = this;\n\n      this._clock.on(\"start\", function (time, offset) {\n        offset = new TicksClass(_this3.context, offset).toSeconds();\n\n        _this3.emit(\"start\", time, offset);\n      });\n\n      this._clock.on(\"stop\", function (time) {\n        _this3.emit(\"stop\", time);\n      });\n\n      this._clock.on(\"pause\", function (time) {\n        _this3.emit(\"pause\", time);\n      });\n    }\n    /**\n     * Returns the playback state of the source, either \"started\", \"stopped\", or \"paused\"\n     */\n\n  }, {\n    key: \"state\",\n    get: function get() {\n      return this._clock.getStateAtTime(this.now());\n    }\n    /**\n     * Start the transport and all sources synced to the transport.\n     * @param  time The time when the transport should start.\n     * @param  offset The timeline offset to start the transport.\n     * @example\n     * // start the transport in one second starting at beginning of the 5th measure.\n     * Tone.Transport.start(\"+1\", \"4:0:0\");\n     */\n\n  }, {\n    key: \"start\",\n    value: function start(time, offset) {\n      var offsetTicks;\n\n      if (isDefined(offset)) {\n        offsetTicks = this.toTicks(offset);\n      } // start the clock\n\n\n      this._clock.start(time, offsetTicks);\n\n      return this;\n    }\n    /**\n     * Stop the transport and all sources synced to the transport.\n     * @param time The time when the transport should stop.\n     * @example\n     * Tone.Transport.stop();\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop(time) {\n      this._clock.stop(time);\n\n      return this;\n    }\n    /**\n     * Pause the transport and all sources synced to the transport.\n     */\n\n  }, {\n    key: \"pause\",\n    value: function pause(time) {\n      this._clock.pause(time);\n\n      return this;\n    }\n    /**\n     * Toggle the current state of the transport. If it is\n     * started, it will stop it, otherwise it will start the Transport.\n     * @param  time The time of the event\n     */\n\n  }, {\n    key: \"toggle\",\n    value: function toggle(time) {\n      time = this.toSeconds(time);\n\n      if (this._clock.getStateAtTime(time) !== \"started\") {\n        this.start(time);\n      } else {\n        this.stop(time);\n      }\n\n      return this;\n    } //-------------------------------------\n    // \tSETTERS/GETTERS\n    //-------------------------------------\n\n    /**\n     * The time signature as just the numerator over 4.\n     * For example 4/4 would be just 4 and 6/8 would be 3.\n     * @example\n     * // common time\n     * Tone.Transport.timeSignature = 4;\n     * // 7/8\n     * Tone.Transport.timeSignature = [7, 8];\n     * // this will be reduced to a single number\n     * Tone.Transport.timeSignature; // returns 3.5\n     */\n\n  }, {\n    key: \"timeSignature\",\n    get: function get() {\n      return this._timeSignature;\n    },\n    set: function set(timeSig) {\n      if (isArray(timeSig)) {\n        timeSig = timeSig[0] / timeSig[1] * 4;\n      }\n\n      this._timeSignature = timeSig;\n    }\n    /**\n     * When the Transport.loop = true, this is the starting position of the loop.\n     */\n\n  }, {\n    key: \"loopStart\",\n    get: function get() {\n      return new TimeClass(this.context, this._loopStart, \"i\").toSeconds();\n    },\n    set: function set(startPosition) {\n      this._loopStart = this.toTicks(startPosition);\n    }\n    /**\n     * When the Transport.loop = true, this is the ending position of the loop.\n     */\n\n  }, {\n    key: \"loopEnd\",\n    get: function get() {\n      return new TimeClass(this.context, this._loopEnd, \"i\").toSeconds();\n    },\n    set: function set(endPosition) {\n      this._loopEnd = this.toTicks(endPosition);\n    }\n    /**\n     * If the transport loops or not.\n     */\n\n  }, {\n    key: \"loop\",\n    get: function get() {\n      return this._loop.get(this.now());\n    },\n    set: function set(loop) {\n      this._loop.set(loop, this.now());\n    }\n    /**\n     * Set the loop start and stop at the same time.\n     * @example\n     * // loop over the first measure\n     * Tone.Transport.setLoopPoints(0, \"1m\");\n     * Tone.Transport.loop = true;\n     */\n\n  }, {\n    key: \"setLoopPoints\",\n    value: function setLoopPoints(startPosition, endPosition) {\n      this.loopStart = startPosition;\n      this.loopEnd = endPosition;\n      return this;\n    }\n    /**\n     * The swing value. Between 0-1 where 1 equal to the note + half the subdivision.\n     */\n\n  }, {\n    key: \"swing\",\n    get: function get() {\n      return this._swingAmount;\n    },\n    set: function set(amount) {\n      // scale the values to a normal range\n      this._swingAmount = amount;\n    }\n    /**\n     * Set the subdivision which the swing will be applied to.\n     * The default value is an 8th note. Value must be less\n     * than a quarter note.\n     */\n\n  }, {\n    key: \"swingSubdivision\",\n    get: function get() {\n      return new TicksClass(this.context, this._swingTicks).toNotation();\n    },\n    set: function set(subdivision) {\n      this._swingTicks = this.toTicks(subdivision);\n    }\n    /**\n     * The Transport's position in Bars:Beats:Sixteenths.\n     * Setting the value will jump to that position right away.\n     */\n\n  }, {\n    key: \"position\",\n    get: function get() {\n      var now = this.now();\n\n      var ticks = this._clock.getTicksAtTime(now);\n\n      return new TicksClass(this.context, ticks).toBarsBeatsSixteenths();\n    },\n    set: function set(progress) {\n      var ticks = this.toTicks(progress);\n      this.ticks = ticks;\n    }\n    /**\n     * The Transport's position in seconds\n     * Setting the value will jump to that position right away.\n     */\n\n  }, {\n    key: \"seconds\",\n    get: function get() {\n      return this._clock.seconds;\n    },\n    set: function set(s) {\n      var now = this.now();\n\n      var ticks = this._clock.frequency.timeToTicks(s, now);\n\n      this.ticks = ticks;\n    }\n    /**\n     * The Transport's loop position as a normalized value. Always\n     * returns 0 if the transport if loop is not true.\n     */\n\n  }, {\n    key: \"progress\",\n    get: function get() {\n      if (this.loop) {\n        var now = this.now();\n\n        var ticks = this._clock.getTicksAtTime(now);\n\n        return (ticks - this._loopStart) / (this._loopEnd - this._loopStart);\n      } else {\n        return 0;\n      }\n    }\n    /**\n     * The transports current tick position.\n     */\n\n  }, {\n    key: \"ticks\",\n    get: function get() {\n      return this._clock.ticks;\n    },\n    set: function set(t) {\n      if (this._clock.ticks !== t) {\n        var now = this.now(); // stop everything synced to the transport\n\n        if (this.state === \"started\") {\n          var ticks = this._clock.getTicksAtTime(now); // schedule to start on the next tick, #573\n\n\n          var remainingTick = this._clock.frequency.getDurationOfTicks(Math.ceil(ticks) - ticks, now);\n\n          var time = now + remainingTick;\n          this.emit(\"stop\", time);\n\n          this._clock.setTicksAtTime(t, time); // restart it with the new time\n\n\n          this.emit(\"start\", time, this._clock.getSecondsAtTime(time));\n        } else {\n          this._clock.setTicksAtTime(t, now);\n        }\n      }\n    }\n    /**\n     * Get the clock's ticks at the given time.\n     * @param  time  When to get the tick value\n     * @return The tick value at the given time.\n     */\n\n  }, {\n    key: \"getTicksAtTime\",\n    value: function getTicksAtTime(time) {\n      return Math.round(this._clock.getTicksAtTime(time));\n    }\n    /**\n     * Return the elapsed seconds at the given time.\n     * @param  time  When to get the elapsed seconds\n     * @return  The number of elapsed seconds\n     */\n\n  }, {\n    key: \"getSecondsAtTime\",\n    value: function getSecondsAtTime(time) {\n      return this._clock.getSecondsAtTime(time);\n    }\n    /**\n     * Pulses Per Quarter note. This is the smallest resolution\n     * the Transport timing supports. This should be set once\n     * on initialization and not set again. Changing this value\n     * after other objects have been created can cause problems.\n     */\n\n  }, {\n    key: \"PPQ\",\n    get: function get() {\n      return this._clock.frequency.multiplier;\n    },\n    set: function set(ppq) {\n      this._clock.frequency.multiplier = ppq;\n    } //-------------------------------------\n    // \tSYNCING\n    //-------------------------------------\n\n    /**\n     * Returns the time aligned to the next subdivision\n     * of the Transport. If the Transport is not started,\n     * it will return 0.\n     * Note: this will not work precisely during tempo ramps.\n     * @param  subdivision  The subdivision to quantize to\n     * @return  The context time of the next subdivision.\n     * @example\n     * // the transport must be started, otherwise returns 0\n     * Tone.Transport.start();\n     * Tone.Transport.nextSubdivision(\"4n\");\n     */\n\n  }, {\n    key: \"nextSubdivision\",\n    value: function nextSubdivision(subdivision) {\n      subdivision = this.toTicks(subdivision);\n\n      if (this.state !== \"started\") {\n        // if the transport's not started, return 0\n        return 0;\n      } else {\n        var now = this.now(); // the remainder of the current ticks and the subdivision\n\n        var transportPos = this.getTicksAtTime(now);\n        var remainingTicks = subdivision - transportPos % subdivision;\n        return this._clock.nextTickTime(remainingTicks, now);\n      }\n    }\n    /**\n     * Attaches the signal to the tempo control signal so that\n     * any changes in the tempo will change the signal in the same\n     * ratio.\n     *\n     * @param signal\n     * @param ratio Optionally pass in the ratio between the two signals.\n     * \t\t\tOtherwise it will be computed based on their current values.\n     */\n\n  }, {\n    key: \"syncSignal\",\n    value: function syncSignal(signal, ratio) {\n      if (!ratio) {\n        // get the sync ratio\n        var now = this.now();\n\n        if (signal.getValueAtTime(now) !== 0) {\n          var bpm = this.bpm.getValueAtTime(now);\n          var computedFreq = 1 / (60 / bpm / this.PPQ);\n          ratio = signal.getValueAtTime(now) / computedFreq;\n        } else {\n          ratio = 0;\n        }\n      }\n\n      var ratioSignal = new Gain(ratio); // @ts-ignore\n\n      this.bpm.connect(ratioSignal); // @ts-ignore\n\n      ratioSignal.connect(signal._param);\n\n      this._syncedSignals.push({\n        initial: signal.value,\n        ratio: ratioSignal,\n        signal: signal\n      });\n\n      signal.value = 0;\n      return this;\n    }\n    /**\n     * Unsyncs a previously synced signal from the transport's control.\n     * See Transport.syncSignal.\n     */\n\n  }, {\n    key: \"unsyncSignal\",\n    value: function unsyncSignal(signal) {\n      for (var i = this._syncedSignals.length - 1; i >= 0; i--) {\n        var syncedSignal = this._syncedSignals[i];\n\n        if (syncedSignal.signal === signal) {\n          syncedSignal.ratio.dispose();\n          syncedSignal.signal.value = syncedSignal.initial;\n\n          this._syncedSignals.splice(i, 1);\n        }\n      }\n\n      return this;\n    }\n    /**\n     * Clean up.\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(Transport.prototype), \"dispose\", this).call(this);\n\n      this._clock.dispose();\n\n      writable(this, \"bpm\");\n\n      this._timeline.dispose();\n\n      this._repeatedEvents.dispose();\n\n      return this;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(ToneWithContext.getDefaults(), {\n        bpm: 120,\n        loopEnd: \"4m\",\n        loopStart: 0,\n        ppq: 192,\n        swing: 0,\n        swingSubdivision: \"8n\",\n        timeSignature: 4\n      });\n    }\n  }]);\n\n  return Transport;\n}(ToneWithContext);\nEmitter.mixin(Transport); //-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\n\nonContextInit(function (context) {\n  context.transport = new Transport({\n    context: context\n  });\n});\nonContextClose(function (context) {\n  context.transport.dispose();\n});","map":{"version":3,"mappings":"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","names":["TimeClass","TimelineValue","onContextClose","onContextInit","Gain","ToneWithContext","TicksClass","TransportTimeClass","optionsFromArguments","Emitter","readOnly","writable","IntervalTimeline","Timeline","isArray","isDefined","Clock","TransportEvent","TransportRepeatEvent","Transport","getDefaults","arguments","options","_ppq","ppq","_clock","callback","_processTick","bind","context","frequency","units","_bindClockEvents","bpm","multiplier","setValueAtTime","_timeSignature","timeSignature","_swingTicks","tickTime","ticks","_loop","get","_loopEnd","emit","setTicksAtTime","_loopStart","getSecondsAtTime","_swingAmount","progress","amount","Math","sin","PI","toSeconds","_timeline","forEachAtTime","event","invoke","time","toTicks","_addEvent","interval","startTime","duration","Infinity","_repeatedEvents","once","eventId","_scheduledEvents","hasOwnProperty","item","toString","timeline","remove","dispose","id","add","after","computedAfter","forEachFrom","clear","on","offset","getStateAtTime","now","offsetTicks","start","stop","pause","timeSig","startPosition","endPosition","loop","set","loopStart","loopEnd","toNotation","subdivision","getTicksAtTime","toBarsBeatsSixteenths","seconds","s","timeToTicks","t","state","remainingTick","getDurationOfTicks","ceil","round","transportPos","remainingTicks","nextTickTime","signal","ratio","getValueAtTime","computedFreq","PPQ","ratioSignal","connect","_param","_syncedSignals","push","initial","value","i","length","syncedSignal","splice","Object","assign","swing","swingSubdivision","mixin","transport"],"sourceRoot":"","sources":["../../../../Tone/core/clock/Transport.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}