var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { OfflineRender } from "./OfflineRender";
import { analyse } from "./Spectrum";
import { TestAudioBuffer } from "./TestAudioBuffer";
export function compareSpectra(bufferA, bufferB) {
    if (bufferA.length !== bufferB.length) {
        throw new Error("buffers must be the same length to compare");
    }
    const analysisA = analyse(bufferA, 1024, 64);
    const analysisB = analyse(bufferB, 1024, 64);
    let diff = 0;
    analysisA.forEach((columnA, columnNum) => {
        const columnB = analysisB[columnNum];
        columnA.forEach((valA, index) => {
            const valB = columnB[index];
            diff += Math.pow(valA - valB, 2);
        });
    });
    return Math.sqrt(diff / analysisA.length);
}
export function compareSignals(bufferA, bufferB) {
    const arrayA = bufferA.toArray();
    const arrayB = bufferB.toArray();
    const diffs = arrayA.map((channelA, channelNum) => {
        let diff = 0;
        const channelB = arrayB[channelNum];
        channelA.forEach((valA, index) => {
            const valB = channelB[index];
            diff += Math.pow(valA - valB, 2);
        });
        return Math.sqrt(diff / channelA.length);
    });
    // average across the channels
    return diffs.reduce((t, v) => t + v, 0) / diffs.length;
}
function getBuffersToCompare(callback, filename, duration = 0.5, channels = 1, sampleRate = 11025, forceRender = false) {
    return __awaiter(this, void 0, void 0, function* () {
        if (forceRender) {
            const buffer = yield OfflineRender(callback, duration, channels, sampleRate);
            buffer.downloadWav(filename);
            return Promise.resolve();
        }
        else {
            const bufferB = yield fetch(filename).then(response => response.arrayBuffer()).then(buffer => {
                const context = new OfflineAudioContext(channels, 1, sampleRate);
                return context.decodeAudioData(buffer);
            }).then(audioBuffer => new TestAudioBuffer(audioBuffer));
            const bufferA = yield OfflineRender(callback, bufferB.duration, bufferB.numberOfChannels, bufferB.sampleRate);
            // const [bufferA, bufferB] = await Promise.all([bufferAPromise, bufferBPromise]);
            return {
                bufferA, bufferB,
            };
        }
    });
}
export function toFile(callback, filename, threshold = 0.1, forceRender = false, duration = 0.1, channels = 1, sampleRate = 11025) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield getBuffersToCompare(callback, filename, duration, channels, sampleRate, forceRender);
        if (response) {
            const { bufferA, bufferB } = response;
            const error = compareSpectra(bufferA, bufferB);
            if (error > threshold) {
                throw new Error(`Error ${error} greater than threshold ${threshold}`);
            }
        }
    });
}
export function toFileSignal(callback, filename, threshold = 0.1, forceRender = false, duration = 0.1, channels = 1, sampleRate = 11025) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield getBuffersToCompare(callback, filename, duration, channels, sampleRate, forceRender);
        if (response) {
            const { bufferA, bufferB } = response;
            if (compareSignals(bufferA, bufferB) > threshold) {
                throw new Error(`generated buffer does not match file ${filename}`);
            }
        }
    });
}
