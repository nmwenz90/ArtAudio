var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
// eslint-disable-next-line @typescript-eslint/no-var-requires
const toWav = require("audiobuffer-to-wav");
export class TestAudioBuffer {
    constructor(buffer) {
        if (buffer instanceof AudioBuffer) {
            this._buffer = buffer;
        }
        else if (buffer instanceof TestAudioBuffer) {
            this._buffer = buffer._buffer;
        }
        else {
            this._buffer = buffer.get();
        }
    }
    static fromUrl(url, channels = 1, sampleRate = 11025) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield fetch(url);
            if (response.ok) {
                const buffer = yield response.arrayBuffer();
                const context = new OfflineAudioContext(channels, 1, sampleRate);
                const audioBuffer = yield context.decodeAudioData(buffer);
                return new TestAudioBuffer(audioBuffer);
            }
            else {
                throw new Error(`could not load url ${url}`);
            }
        });
    }
    static fromTone(buffer) {
        return new TestAudioBuffer(buffer);
    }
    /**
     * The number of channels of the audio file.
     */
    get numberOfChannels() {
        return this._buffer.numberOfChannels;
    }
    /**
     * The duration in seconds
     */
    get duration() {
        return this._buffer.duration;
    }
    /**
     * The length in samples
     */
    get length() {
        return this._buffer.length;
    }
    /**
     * The sample rate of the audio file
     */
    get sampleRate() {
        return this._buffer.sampleRate;
    }
    /**
     * Return the buffer as a nested array where the first axis is the number of channels
     */
    toArray() {
        if (!this._array) {
            const output = [];
            for (let channel = 0; channel < this._buffer.numberOfChannels; channel++) {
                output[channel] = this._buffer.getChannelData(channel);
            }
            this._array = output;
        }
        return this._array;
    }
    /**
     * Return a new TestAudioBuffer which has all of the channels summed to a single channel
     */
    toMono() {
        const context = new OfflineAudioContext(1, 1, this._buffer.sampleRate);
        const buffer = context.createBuffer(1, this._buffer.length, this._buffer.sampleRate);
        // sum all the channels into a single channel
        const bufferArray = buffer.getChannelData(0);
        this.toArray().forEach(channel => {
            channel.forEach((value, index) => {
                bufferArray[index] += value;
            });
        });
        return new TestAudioBuffer(buffer);
    }
    /**
     * Return the Root Mean Square of the channels at that slice of time.
     * If buffer is mono, it will return a single value, otherwise it returns an array of numbers
     * @param time Seconds
     */
    getRmsAtTime(time) {
        if (!this._rms) {
            const blockSize = 512;
            this._rms = [];
            this.toArray().forEach(channel => {
                const channelRMS = new Float32Array(channel.length);
                this._rms.push(channelRMS);
                for (let i = 0; i < channel.length; i++) {
                    const sqrSum = channel.slice(i, i + blockSize).reduce((total, value) => {
                        return total + value * value;
                    }, 0);
                    channelRMS[i] = Math.sqrt(sqrSum / blockSize);
                }
            });
        }
        const sampleTime = Math.floor(time * this._buffer.sampleRate);
        if (sampleTime < this._rms[0].length) {
            const values = this._rms.map(rms => rms[sampleTime]);
            if (values.length === 1) {
                return values[0];
            }
            else {
                return values;
            }
        }
        else {
            return 0;
        }
    }
    /**
     * Get the value of a sample at the given time. if the buffer has multiple
     * channels, will return an array.
     * @param time seconds
     */
    getValueAtTime(time) {
        const sampleTime = Math.floor(time * this._buffer.sampleRate);
        const array = this.toArray();
        if (sampleTime < array[0].length) {
            const values = array.map(channel => channel[sampleTime]);
            if (values.length === 1) {
                return values[0];
            }
            else {
                return values;
            }
        }
        else {
            return 0;
        }
    }
    /**
     * return the time in seconds of the first time
     * the AudioBuffer rose above the silence threshold
     */
    getTimeOfFirstSound(threshold = 1e-6) {
        const firstSampleTimes = this.toArray().map(channel => {
            for (let i = 0; i < channel.length; i++) {
                const sample = channel[i];
                if (sample > threshold) {
                    return i / this._buffer.sampleRate;
                }
            }
            return -1;
        });
        return Math.min(...firstSampleTimes);
    }
    /**
     * Return the last time a sample rose above the threshold
     * @param threshold
     */
    getTimeOfLastSound(threshold = 1e-6) {
        const lastSampleTimes = this.toArray().map(channel => {
            for (let i = channel.length - 1; i >= 0; i--) {
                const sample = channel[i];
                if (sample > threshold) {
                    return i / this._buffer.sampleRate;
                }
            }
            return -1;
        });
        return Math.max(...lastSampleTimes);
    }
    /**
     * The maximum sample value across all the channels
     */
    max() {
        let max = -Infinity;
        this.toArray().forEach(channel => {
            max = Math.max(max, ...Array.from(channel));
        });
        return max;
    }
    /**
     * The minimum sample value across all the channels
     */
    min() {
        let min = Infinity;
        this.toArray().forEach(channel => {
            min = Math.min(min, ...Array.from(channel));
        });
        return min;
    }
    /**
     * The value (only if it is consistent throughout the entire buffer).
     * Throws an error if there are multiple values found.
     */
    value() {
        const max = this.max();
        const min = this.min();
        if (max - min > 1e-6) {
            throw new Error("multiple values found in this buffer");
        }
        return max;
    }
    /**
     * Test if the buffer has no audio data. if it is at or near 0 the entire buffer.
     */
    isSilent(threshold = 1e-6) {
        try {
            return Math.abs(this.value()) < threshold;
        }
        catch (e) {
            return false;
        }
    }
    /**
     * Return a copy of the TestAudioBuffer
     */
    clone() {
        // should probably also clone the buffer
        return new TestAudioBuffer(this._buffer);
    }
    /**
     * Return a new TestAudioBuffer at the given sample rate.
     * @param sampleRate a new sample rate to compute the buffer ar
     */
    resample(sampleRate) {
        return __awaiter(this, void 0, void 0, function* () {
            const offlineCtx = new OfflineAudioContext(this._buffer.numberOfChannels, this._buffer.duration * sampleRate, sampleRate);
            const resampledBuffer = offlineCtx.createBuffer(this._buffer.numberOfChannels, this._buffer.length, this._buffer.sampleRate);
            // Copy the source data into the offline AudioBuffer
            for (let channel = 0; channel < resampledBuffer.numberOfChannels; channel++) {
                resampledBuffer.copyToChannel(this._buffer.getChannelData(channel), channel);
            }
            // Play it from the beginning.
            const source = offlineCtx.createBufferSource();
            source.buffer = resampledBuffer;
            source.connect(offlineCtx.destination);
            source.start(0);
            // compute the results
            const computedBuffer = yield offlineCtx.startRendering();
            return new TestAudioBuffer(computedBuffer);
        });
    }
    toWav() {
        // check that the min and max are between -1 and 1
        return toWav(this._buffer, {
            float32: false
        });
    }
    downloadWav(filename = "test_audio") {
        const wave = this.toWav();
        const blob = new Blob([wave], { type: "audio/wav" });
        const blobUrl = window.URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = blobUrl;
        a.download = filename;
        a.click();
        window.URL.revokeObjectURL(blobUrl);
    }
    forEach(callback) {
        const channels = this.toMono().toArray();
        channels[0].forEach((sample, index) => {
            callback(sample, index / this.sampleRate);
        });
    }
    forEachBetween(callback, startTime = 0, endTime = this.duration) {
        const channels = this.toMono().toArray();
        const startSamples = Math.floor(startTime * this.sampleRate);
        const endSamples = Math.floor(Math.min(endTime * this.sampleRate, this.length));
        for (let s = startSamples; s < endSamples; s++) {
            const sample = channels[0][s];
            callback(sample, s / this.sampleRate);
        }
    }
}
