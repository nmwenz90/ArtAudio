var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { TestAudioBuffer } from "./TestAudioBuffer";
export function OfflineRender(callback, duration = 0.001, channels = 1, sampleRate = 11025) {
    return __awaiter(this, void 0, void 0, function* () {
        // the offline context
        const offlineContext = new OfflineAudioContext(channels, Math.floor(duration * sampleRate), sampleRate);
        // wait for the callback
        yield callback(offlineContext);
        // render the buffer
        const buffer = yield offlineContext.startRendering();
        // wrap the buffer
        return new TestAudioBuffer(buffer);
    });
}
/**
 * Returns true if the input passes audio to the output
 */
export function PassesAudio(callback) {
    return __awaiter(this, void 0, void 0, function* () {
        const buffer = yield OfflineRender((context) => __awaiter(this, void 0, void 0, function* () {
            const source = context.createConstantSource();
            source.start(0);
            source.offset.setValueAtTime(0, 0);
            source.offset.setValueAtTime(1, 0.25);
            const destination = context.destination;
            yield callback(context, source, destination);
        }), 0.5, 1, 11025);
        const sample0 = buffer.getValueAtTime(0) === 0;
        const sample1 = buffer.getValueAtTime(0.2) === 0;
        const sample2 = buffer.getValueAtTime(0.26) > 0;
        const sample3 = buffer.getValueAtTime(0.49) > 0;
        return sample0 && sample1 && sample2 && sample3;
    });
}
/**
 * Returns true if the callback makes a sound
 */
export function MakesSound(callback, duration = 0.001, channels = 1, sampleRate = 11025) {
    return __awaiter(this, void 0, void 0, function* () {
        const buffer = yield OfflineRender(callback, duration, channels, sampleRate);
        return !buffer.isSilent();
    });
}
