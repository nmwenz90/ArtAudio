export declare class TestAudioBuffer {
    static fromUrl(url: string, channels?: number, sampleRate?: number): Promise<TestAudioBuffer>;
    static fromTone(buffer: import("tone").ToneAudioBuffer): TestAudioBuffer;
    private _buffer;
    private _rms;
    private _array;
    constructor(buffer: AudioBuffer | TestAudioBuffer | import("tone").ToneAudioBuffer);
    /**
     * The number of channels of the audio file.
     */
    readonly numberOfChannels: number;
    /**
     * The duration in seconds
     */
    readonly duration: number;
    /**
     * The length in samples
     */
    readonly length: number;
    /**
     * The sample rate of the audio file
     */
    readonly sampleRate: number;
    /**
     * Return the buffer as a nested array where the first axis is the number of channels
     */
    toArray(): Float32Array[];
    /**
     * Return a new TestAudioBuffer which has all of the channels summed to a single channel
     */
    toMono(): TestAudioBuffer;
    /**
     * Return the Root Mean Square of the channels at that slice of time.
     * If buffer is mono, it will return a single value, otherwise it returns an array of numbers
     * @param time Seconds
     */
    getRmsAtTime(time: number): number[] | number;
    /**
     * Get the value of a sample at the given time. if the buffer has multiple
     * channels, will return an array.
     * @param time seconds
     */
    getValueAtTime(time: number): number[] | number;
    /**
     * return the time in seconds of the first time
     * the AudioBuffer rose above the silence threshold
     */
    getTimeOfFirstSound(threshold?: number): number;
    /**
     * Return the last time a sample rose above the threshold
     * @param threshold
     */
    getTimeOfLastSound(threshold?: number): number;
    /**
     * The maximum sample value across all the channels
     */
    max(): number;
    /**
     * The minimum sample value across all the channels
     */
    min(): number;
    /**
     * The value (only if it is consistent throughout the entire buffer).
     * Throws an error if there are multiple values found.
     */
    value(): number;
    /**
     * Test if the buffer has no audio data. if it is at or near 0 the entire buffer.
     */
    isSilent(threshold?: number): boolean;
    /**
     * Return a copy of the TestAudioBuffer
     */
    clone(): TestAudioBuffer;
    /**
     * Return a new TestAudioBuffer at the given sample rate.
     * @param sampleRate a new sample rate to compute the buffer ar
     */
    resample(sampleRate: number): Promise<TestAudioBuffer>;
    toWav(): ArrayBuffer;
    downloadWav(filename?: string): void;
    forEach(callback: (sample: number, time: number) => void): void;
    forEachBetween(callback: (sample: number, time: number) => void, startTime?: number, endTime?: number): void;
}
